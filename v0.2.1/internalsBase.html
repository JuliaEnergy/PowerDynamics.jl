<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PowerDynBase.jl · PowerDynamics.jl</title><link rel="canonical" href="https://juliaenergy.github.io/PowerDynamics.jl/latest/internalsBase.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PowerDynamics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Dynamic Power System Analysis</span><ul><li><a class="toctext" href="index.html">PowerDynamics.jl</a></li><li><a class="toctext" href="language_conventions.html">Language &amp; Conventions</a></li><li><a class="toctext" href="node_dynamics_types.html">Node Dynamics Types</a></li><li><a class="toctext" href="node_types.html">Node Types</a></li><li><a class="toctext" href="custom_node_types.html">Custom Node Types</a></li><li><a class="toctext" href="error_types.html">Error Types</a></li></ul></li><li><span class="toctext">Documentation of Internals</span><ul><li class="current"><a class="toctext" href="internalsBase.html">PowerDynBase.jl</a><ul class="internal"></ul></li><li><a class="toctext" href="internalsSolve.html">PowerDynSolve.jl</a></li></ul></li><li><a class="toctext" href="fullindex.html">Index</a></li><li><a class="toctext" href="contact.html">Contact</a></li></ul></nav><article id="docs"><header><nav><ul><li>Documentation of Internals</li><li><a href="internalsBase.html">PowerDynBase.jl</a></li></ul><a class="edit-page" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/master/docs/src/internalsBase.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>PowerDynBase.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="PowerDynBase.jl-1" href="#PowerDynBase.jl-1">PowerDynBase.jl</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractAlgebraicGridDynamics" href="#PowerDynBase.AbstractAlgebraicGridDynamics"><code>PowerDynBase.AbstractAlgebraicGridDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all grid dynamics represented by DAEs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractAlgebraicNodeDynamics" href="#PowerDynBase.AbstractAlgebraicNodeDynamics"><code>PowerDynBase.AbstractAlgebraicNodeDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all node dynamics represented by DAEs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractDAEVariable" href="#PowerDynBase.AbstractDAEVariable"><code>PowerDynBase.AbstractDAEVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all Variables for DAE-type node dynamics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractDEVariable" href="#PowerDynBase.AbstractDEVariable"><code>PowerDynBase.AbstractDEVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all variables that AbstractNodeDynamics sub types can be called with.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractNetworkFunction" href="#PowerDynBase.AbstractNetworkFunction"><code>PowerDynBase.AbstractNetworkFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type AbstractNetworkFunction{T&lt;:AbstractNodeDynamics, M&lt;:AbstractMatrix} end</code></pre><p>Abstract super type of all functions that define how a differential equation for the whole network / power grid behaves, e.g. the full right-hand-side function of the ODE.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractNodeDynamics" href="#PowerDynBase.AbstractNodeDynamics"><code>PowerDynBase.AbstractNodeDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all abstract node dynamics types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractODEVariable" href="#PowerDynBase.AbstractODEVariable"><code>PowerDynBase.AbstractODEVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all Variables for ODE-type node dynamics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractOrdinaryGridDynamics" href="#PowerDynBase.AbstractOrdinaryGridDynamics"><code>PowerDynBase.AbstractOrdinaryGridDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all grid dynamics represented by ODEs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractOrdinaryNodeDynamics" href="#PowerDynBase.AbstractOrdinaryNodeDynamics"><code>PowerDynBase.AbstractOrdinaryNodeDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all node dynamics represented by ODEs.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AlgebraicGridDynamics" href="#PowerDynBase.AlgebraicGridDynamics"><code>PowerDynBase.AlgebraicGridDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TBD</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AlgebraicNodeDynamics" href="#PowerDynBase.AlgebraicNodeDynamics"><code>PowerDynBase.AlgebraicNodeDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>DOCS TBD!</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.BaseState" href="#PowerDynBase.BaseState"><code>PowerDynBase.BaseState</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">
    BaseState(grid, vec)
</code></pre><p>Encode a state vector and the corresponding rhs information.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>grid</code> is a <a href="@ref"><code>GridDynamics</code></a> instance that contains the overall system rhs.</li><li><code>vec</code> is a state vector of the system who&#39;s length is given by the total       number of internal and voltage variables.</li></ul><p><strong>Indexing</strong></p><p>In an instance <code>b</code> of of a <code>BaseState</code> behaves like an <a href="@ref"><code>Array</code></a>, i.e. you can access the <span>$j$</span>-th element of the state vector (and set it to a value <span>$ξ$</span>) by calling <code>b[j] ( = ξ )</code>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.DAEVariable" href="#PowerDynBase.DAEVariable"><code>PowerDynBase.DAEVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Variables for DAE-type node dynamics.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.ODEVariable" href="#PowerDynBase.ODEVariable"><code>PowerDynBase.ODEVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Variables for ODE-type node dynamics.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.OrdinaryGridDynamics" href="#PowerDynBase.OrdinaryGridDynamics"><code>PowerDynBase.OrdinaryGridDynamics</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TBD</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.OrdinaryGridDynamicsWithMass" href="#PowerDynBase.OrdinaryGridDynamicsWithMass"><code>PowerDynBase.OrdinaryGridDynamicsWithMass</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TBD</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.view-Tuple{PowerDynBase.AbstractDEVariable,Any}" href="#Base.view-Tuple{PowerDynBase.AbstractDEVariable,Any}"><code>Base.view</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Extend view from arrays to subtypes of <a href="#ref"><code>AbstractDEVariable</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.DynamicNode-NTuple{4,Any}" href="#PowerDynBase.DynamicNode-NTuple{4,Any}"><code>PowerDynBase.DynamicNode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>See <a href="#ref"><code>DPSABase.@DynamicNode</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase._GridDynamics-Tuple{AbstractArray{#s30,1} where #s30&lt;:OrdinaryNodeDynamics,AbstractArray{T,2} where T}" href="#PowerDynBase._GridDynamics-Tuple{AbstractArray{#s30,1} where #s30&lt;:OrdinaryNodeDynamics,AbstractArray{T,2} where T}"><code>PowerDynBase._GridDynamics</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create for each subtype of <a href="#ref"><code>DPSABase.AbstractNodeDynamics</code></a> the corresponding subtype of <a href="#ref"><code>DPSABase.GridDynamics</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.checkLY-Tuple{AbstractArray{T,2} where T}" href="#PowerDynBase.checkLY-Tuple{AbstractArray{T,2} where T}"><code>PowerDynBase.checkLY</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Check whether the admittance laplacian has no purely nodal admittances, i.e. that the sum of columns and rows equals to zero.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.complexview-Tuple{PowerDynBase.AbstractDEVariable,Any,Any}" href="#PowerDynBase.complexview-Tuple{PowerDynBase.AbstractDEVariable,Any,Any}"><code>PowerDynBase.complexview</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Extend complexview from arrays to subtypes of <a href="#ref"><code>AbstractDEVariable</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.complexview-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Any,Any}} where T" href="#PowerDynBase.complexview-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Any,Any}} where T"><code>PowerDynBase.complexview</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Interpret (part of) an array of real values as an array with complex values.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.create_DEVariable-Tuple{Any,Symbol}" href="#PowerDynBase.create_DEVariable-Tuple{Any,Symbol}"><code>PowerDynBase.create_DEVariable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Basically, this macro generates all the constructors (internal and external) for a subtype of AbstracDEVariable.</p><p>If you really want to understand this macro, uncomment the <code>println(ex)</code> statement at the end and check the resulting generated expression.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.excomparison-Tuple{Any}" href="#PowerDynBase.excomparison-Tuple{Any}"><code>PowerDynBase.excomparison</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create an expresseion where <code>==</code> is applied between all the expressions given as argument here.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.getDEVariableType-Tuple{Type{Val{OrdinaryNodeDynamics}}}" href="#PowerDynBase.getDEVariableType-Tuple{Type{Val{OrdinaryNodeDynamics}}}"><code>PowerDynBase.getDEVariableType</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Identify each subtype of <a href="#ref"><code>AbstractNodeDynamics</code></a> with its corresponding subtype of <a href="#ref"><code>AbstractDEVariable</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.internal_unitranges-Tuple{AbstractArray{#s30,1} where #s30&lt;:PowerDynBase.AbstractNodeDynamics}" href="#PowerDynBase.internal_unitranges-Tuple{AbstractArray{#s30,1} where #s30&lt;:PowerDynBase.AbstractNodeDynamics}"><code>PowerDynBase.internal_unitranges</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the unit ranges that indicate where in the array the internal variables for each of the nodes is saved.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.mapfields-Tuple{Any,Any,Vararg{Any,N} where N}" href="#PowerDynBase.mapfields-Tuple{Any,Any,Vararg{Any,N} where N}"><code>PowerDynBase.mapfields</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function mapfields(f, s, args...)</code></pre><p>Applies <code>f</code> to all fields of (the struct) <code>s</code> giving <code>args...</code> as additional arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.nint-Tuple{OrdinaryNodeDynamics}" href="#PowerDynBase.nint-Tuple{OrdinaryNodeDynamics}"><code>PowerDynBase.nint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get number of internal arguments of the node.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.nodeiterator-Tuple{NetworkRHS,PowerDynBase.AbstractDEVariable,Any}" href="#PowerDynBase.nodeiterator-Tuple{NetworkRHS,PowerDynBase.AbstractDEVariable,Any}"><code>PowerDynBase.nodeiterator</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nodeiterator(rhs::NetworkRHS, x::AbstractDEVariable, t)</code></pre><p>Distribute the values in <code>x</code> over all the nodes that are summarized in <code>rhs</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.rhs2root-Tuple{Function}" href="#PowerDynBase.rhs2root-Tuple{Function}"><code>PowerDynBase.rhs2root</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>A function converting a rhs-type function to a root-type function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.total_nint-Tuple{AbstractArray{#s30,1} where #s30&lt;:PowerDynBase.AbstractNodeDynamics}" href="#PowerDynBase.total_nint-Tuple{AbstractArray{#s30,1} where #s30&lt;:PowerDynBase.AbstractNodeDynamics}"><code>PowerDynBase.total_nint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the total number of internal variables for an array of node dynamics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.total_nvars-Tuple{AbstractArray{#s30,1} where #s30&lt;:PowerDynBase.AbstractNodeDynamics}" href="#PowerDynBase.total_nvars-Tuple{AbstractArray{#s30,1} where #s30&lt;:PowerDynBase.AbstractNodeDynamics}"><code>PowerDynBase.total_nvars</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the total number of dynamic variables for an array of node dynamics.</p><p>This is basically the (real) dimension of the system, hence the sum of internal dynamic variables + 2*(number of nodes = number of complex voltages). The 2 is due to the fact that the complex voltages are treated as two real variables.</p></div></div></section><footer><hr/><a class="previous" href="error_types.html"><span class="direction">Previous</span><span class="title">Error Types</span></a><a class="next" href="internalsSolve.html"><span class="direction">Next</span><span class="title">PowerDynSolve.jl</span></a></footer></article></body></html>
