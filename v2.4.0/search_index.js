var documenterSearchIndex = {"docs":
[{"location":"import_export/#Import/export-1","page":"Import/export","title":"Import/export","text":"","category":"section"},{"location":"import_export/#","page":"Import/export","title":"Import/export","text":"PowerDynamics.jl supports import and export of power models into a custom JSON format.","category":"page"},{"location":"import_export/#Import-1","page":"Import/export","title":"Import","text":"","category":"section"},{"location":"import_export/#","page":"Import/export","title":"Import/export","text":"read_powergrid","category":"page"},{"location":"import_export/#PowerDynamics.read_powergrid","page":"Import/export","title":"PowerDynamics.read_powergrid","text":"read_powergrid(file, Json)\n\nParses an existing model in JSON format into a PowerGrid\n\n\n\n\n\n","category":"function"},{"location":"import_export/#Export-1","page":"Import/export","title":"Export","text":"","category":"section"},{"location":"import_export/#","page":"Import/export","title":"Import/export","text":"write_powergrid","category":"page"},{"location":"import_export/#PowerDynamics.write_powergrid","page":"Import/export","title":"PowerDynamics.write_powergrid","text":"write_powergrid(powergrid, file, Json)\n\nWrites a PowerGrid model into a file as JSON.\n\n\n\n\n\n","category":"function"},{"location":"custom_node_types/#Custom-Node-Types-1","page":"Custom Node Types","title":"Custom Node Types","text":"","category":"section"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"To define your own Node Types, use the PowerDynamics.@DynamicNode macro. The new node type will be a subtype of PowerDynamics.AbstractNode.","category":"page"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"@DynamicNode","category":"page"},{"location":"custom_node_types/#PowerDynamics.@DynamicNode","page":"Custom Node Types","title":"PowerDynamics.@DynamicNode","text":"Macro for creating a new type of dynamic nodes.\n\nSyntax Description:\n\n@DynamicNode MyNewNodeName(Par1, Par2, ...) begin\n    [MassMatrix definition]\nend begin\n    [all prepratory things that need to be run just once]\nend [[x1, dx1], [x2, dx2]] begin\n    [the actual dynamics equation]\n    [important to set the output variables]\nend\n\nwhere MyNewNodeName is the name of the new type of dynamic node, Par1, Par2, ... are the names of the parameters, x1, x2, ... the internal variables of the node and dx1, dx2, ... the corresponding differentials.\n\nIn the first block a MassMatrix may be specified. Using the MassMatrix helper function here is recommended. The whole block can be omitted and the identity matrix I is then used as default.\n\nIn the second block, the preparation code that needs to be run only once is inserted. Finally, the third block contains the dynamics description, where it's important that the output variables need to be set. These are du and the differentials of the internal variables (here dx1, dx2).\n\nBelow are two examples:\n\n@DynamicNode SwingEqParameters(H, P, D, Ω) begin\n    @assert D > 0 \"damping (D) should be >0\"\n    @assert H > 0 \"inertia (H) should be >0\"\n    Ω_H = Ω * 2pi / H\nend [[ω, dω]] begin\n    p = real(u * conj(i_c))\n    dϕ = ω # dϕ is only a temp variable that Julia should optimize out\n    du = u * im * dϕ\n    dω = (P - D*ω - p)*Ω_H\nend\n\n@DynamicNode SlackAlgebraicParameters(U) begin\n    MassMatrix() # no masses\nend begin\n    # empty prep block\nend [] begin\n        du = u - U\nend\n\n\n\n\n\n","category":"macro"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"PowerDynamics.MassMatrix","category":"page"},{"location":"custom_node_types/#PowerDynamics.MassMatrix","page":"Custom Node Types","title":"PowerDynamics.MassMatrix","text":"MassMatrix(;m_u::Bool = false, m_int = no_internal_masses)\n\nCreates a massmatrix. Calling:\n\nMassMatrix()\n\ncreates a mass matrix with all masses turned off.\n\nKeyword Arguments\n\nm_u::Bool=false: Mass matrix value for the complex voltage u.\nm_int::Vector{Bool}=Vector{Bool}(): A vector representing the diagonal of the mass matrix. Specifies the masses for the remaining/internal variables.\n\n\n\n\n\n","category":"function"},{"location":"error_types/#Error-Types-1","page":"Error Types","title":"Error Types","text":"","category":"section"},{"location":"error_types/#","page":"Error Types","title":"Error Types","text":"PowerDynamicsError\nNodeDynamicsError\nStateError\nGridSolutionError\nOperationPointError","category":"page"},{"location":"error_types/#PowerDynamics.PowerDynamicsError","page":"Error Types","title":"PowerDynamics.PowerDynamicsError","text":"Abstract super type of all PowerDynamics.jl Errors.\n\n\n\n\n\n","category":"type"},{"location":"error_types/#PowerDynamics.NodeDynamicsError","page":"Error Types","title":"PowerDynamics.NodeDynamicsError","text":"Error to be thrown if something goes wrong during the node dynamics construction.\n\n\n\n\n\n","category":"type"},{"location":"error_types/#PowerDynamics.StateError","page":"Error Types","title":"PowerDynamics.StateError","text":"Error to be thrown if something goes wrong when creating or modifying states.\n\n\n\n\n\n","category":"type"},{"location":"error_types/#PowerDynamics.GridSolutionError","page":"Error Types","title":"PowerDynamics.GridSolutionError","text":"Error to be thrown if something goes wrong during power grid solving\n\n\n\n\n\n","category":"type"},{"location":"error_types/#PowerDynamics.OperationPointError","page":"Error Types","title":"PowerDynamics.OperationPointError","text":"Error to be thrown if something goes wrong during the operation point search.\n\n\n\n\n\n","category":"type"},{"location":"powergrid_model/#PowerGrid-model-1","page":"PowerGrid model","title":"PowerGrid model","text":"","category":"section"},{"location":"powergrid_model/#","page":"PowerGrid model","title":"PowerGrid model","text":"Modules = [PowerDynamics]\nPages   = [\"PowerGrid.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"powergrid_model/#PowerDynamics.systemsize-Tuple{PowerGrid}","page":"PowerGrid model","title":"PowerDynamics.systemsize","text":"Returns the total size of dynamical variables of the whole powergrid\n\n\n\n\n\n","category":"method"},{"location":"powergrid_model/#PowerDynamics.PowerGrid","page":"PowerGrid model","title":"PowerDynamics.PowerGrid","text":"Powergrid(graph, nodes, lines)\n\nOur model describes a powergrid as an undirected graph consisting of edges that represent electrical lines and vertices that represent specific electrical nodes i.e. generators, inverters etc.\n\n\n\n\n\n","category":"type"},{"location":"powergrid_model/#PowerDynamics.PowerGrid-Tuple{Any,Any}","page":"PowerGrid model","title":"PowerDynamics.PowerGrid","text":"Powergrid(nodes, lines)\n\ncreates a PowerGrid from nodes and lines (either given as a list or as a dictionay).  The underlying graph is created automatically.\n\n\n\n\n\n","category":"method"},{"location":"node_types/#Node-Types-1","page":"Node Types","title":"Node Types","text":"","category":"section"},{"location":"node_types/#","page":"Node Types","title":"Node Types","text":"The currently implemented node types are","category":"page"},{"location":"node_types/#","page":"Node Types","title":"Node Types","text":"using InteractiveUtils, PowerDynamics, Markdown\nnodetypes = subtypes(PowerDynamics.AbstractNode)\njoin([\"* [`$n`](@ref PowerDynamics.$n)\" for n in nodetypes], \"\\n\") |> Markdown.parse","category":"page"},{"location":"node_types/#Detailed-Node-Type-Documentation-1","page":"Node Types","title":"Detailed Node Type Documentation","text":"","category":"section"},{"location":"node_types/#","page":"Node Types","title":"Node Types","text":"Modules = [PowerDynamics]\nFilter = t -> typeof(t) === DataType && t <: PowerDynamics.AbstractNode","category":"page"},{"location":"node_types/#PowerDynamics.AbstractNode","page":"Node Types","title":"PowerDynamics.AbstractNode","text":"Abstract base type for all nodes\n\n\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.CSIMinimal","page":"Node Types","title":"PowerDynamics.CSIMinimal","text":"CSIMinimal(;I_r)\n\nA node type that keeps the current fixed as a desired values I_r.\n\nCSIMinimal models an inverters as an ideal current source. This can be the most simple representation of an inverter in grid-feeding mode, according to Rocabert, Joan, et al. \"Control of power converters in AC microgrids.\" (2012). Here, additionally to u, there are no internal dynamic variables.\n\nKeyword Arguments\n\nI_r: reference/ desired current\n\nMathematical Representation\n\nUsing CSIMinimal for node a gives:\n\n0 = I_ra - lefti_aright\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.CurtailedPowerPlantWithInertia","page":"Node Types","title":"PowerDynamics.CurtailedPowerPlantWithInertia","text":"CurtailedPowerPlantWithInertia(;)\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.ExponentialRecoveryLoad","page":"Node Types","title":"PowerDynamics.ExponentialRecoveryLoad","text":"ExponentialRecoveryLoad(P0, Q0, Nps, Npt, Nqs, Nqt, Tp, Tq, V0)\n\nA node type that represents the exponential recovery load model. The exponential recovery load model aims to capture the load restoration characteristics with an exponential recovery process expressed as an input–output relationship between powers (real and reactive) and voltage.\n\nKeyword Arguments\n\nP0: Active power load demand [pu]\nQ0: Reactive power load demand [pu]\nNps: Steady-state load voltage dependence p-axis [pu]\nNpt: Transient load voltage dependence p-axis [pu]\nNqs: Steady-state load voltage dependence q-axis [pu]\nNqt: Transient load voltage dependence q-axis [ pu]\nTp: Load recovery constant p-axis [s]\nTq: Load recovery constant q-axis [s]\nV0: Reference grid voltage [pu]\n\nMathematical Representation\n\n\tdfracdx_pdt = dfrac1T_p(-x_p + P_0(dfracuV_0)^N_ps - P_0(dfracuV_0)^N_pt) \n    dfracdx_qdt = dfrac1T_q(-x_q + Q_0(dfracuV_0)^N_qs - Q_0(dfracuV_0)^N_qt) \n    P = x_p + P_0(dfracuV_0)^N_pt \n    Q = x_q - Q_0(dfracuV_0)^N_qt \n\nIEEE TRANSACTIONS ON POWER SYSTEMS, VOL. 21, NO. 3, AUGUST 2006 Measurement-Based Dynamic Load Models: Derivation, Comparison, and Validation Byoung-Kon Choi, Member, IEEE, Hsiao-Dong Chiang, Fellow, IEEE, Yinhong Li, Hua Li, Member, IEEE, Yung-Tien Chen, Der-Hua Huang, and Mark G. Lauby\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.FourthOrderEq","page":"Node Types","title":"PowerDynamics.FourthOrderEq","text":"FourthEq(H, P, D, Ω, E_f, T_d_dash ,T_q_dash ,X_q_dash ,X_d_dash,X_d, X_q)\n\nA node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics, which is implemented according to P. Sauer, \"Power System Dynamics and Stability\". For an illustration of a synchronous machine schematic see P. Sauer, Fig. 3.1 on p. 25.\n\nUsually the swing equation (SwingEq) is used for short time periods to analyze the transient behavior of generators in a power grid, the so-called first swing. The 4th-order model  also takes the back reaction of the power flow onto the voltage into account. This has the effect that the angle of the voltage as seen by the power grid, and the angle of the rotating mass are no longer the same but become dynamically coupled.\n\nAdditionally to u, it has the internal dynamic variables\n\nω representing the frequency of the rotator relative to the grid frequency Ω, i.e. the real frequency ω_r of the rotator is given as omega_r = Omega + omega and\nθ representing the relative angle of the rotor with respect to the voltage angle ϕ.\n\nKeyword Arguments\n\nH: shaft inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)\nP: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]\nD: damping coefficient (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal Dω)\nΩ: rated frequency of the power grid, often 2π50Hz\nT_d_dash: time constant of d-axis, given in [s], see P. Sauer, chapter 3.7, p. 54 for a general explanation on time constants\nT_q_dash: time constant of q-axis, given in [s]\nX_d_dash: transient reactance of d-axis, given in [pu]\nX_q_dash: transient reactance of q-axis, given in [pu]\nX_d: reactance of d-, given in [pu]\nX_d: reactance of q-axis, given in [pu]\nE_f: scaled field voltage, which, if set equal to 1.0 pu, gives 1.0 pu open-circuit terminal voltage. The physical device that provides the value of E_f is called the exciter (according to P. Sauer, p. 65)\n\nMathematical Representation\n\nUsing FourthEq for node a applies the equations\n\n    u = -je_c e^jtheta = -j(e_d + je_q)e^jtheta\n    e_c= e_d + je_q = jue^-jtheta\n    i  = -jie^jtheta = -j(i_d+ j i_q )e^jtheta = Y^L cdot u \n    i_c= i_d + ji_q = jie^-jtheta\n    p = Re (i^* u)\n\nwhere complex voltage and current are described in a co-rotating frame with axes labeled d and q.\n\nThe fourth-order equations read (according to P. Sauer, \"Power System Dynamics and Stability\", p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)\n\n    fracdthetadt = omega \n     fracdomegadt = (P-Domega - p -(X_q-X_d)i_d i_q)Ω_H\n    fracd e_qdt = frac1T_d (- e_q - (X_d - X_d) i_d+ E_f) \n    fracd e_ddt = frac1T_q (- e_d + (X_q - X_q) i_q)  \n\nThe equations for frequency and phase represent energy conservation and phase shift. The dynamic equations for the complex voltage show the relationship between the dynamicy of flux linkages and currents which must reflect a conservative coupling field.\n\nWith the PowerDynamics.jl naming conventions of i and u they read as\n\n   dot u = fracddt(-j e_c e^jtheta)=-j(dot e_d + jdot e_q)e^jtheta + ujomega\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.FourthOrderEqGovernorExciterAVR","page":"Node Types","title":"PowerDynamics.FourthOrderEqGovernorExciterAVR","text":"FourthOrderEqGovernorExciterAVR(H, P, D, Ω, T_d_dash ,T_q_dash ,X_q_dash ,X_d_dash,X_d, X_q, T_e, T_a, T_f, K_e, K_a, K_f, V_ref, R_d, T_sv, T_ch)\n\nA node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics, including an Exciter, Automatic Voltage Regulator and Governor which is implemented according to P. Sauer, \"Power System Dynamics and Stability\". For an illustration of a synchronous machine schematic see P. Sauer, Fig. 3.1 on p. 25.\n\nExciter and Automatic Voltage Regulator: The equations for the systems that balance the AC synchronous machine voltage level by increasing or decreasing the exciter DC voltage. Note, within this model, the transient reactance in the d-axis of the generator needs to be included into the nodal admittance matrix. As the bus of this generator node type is constructed to be an internal generator bus.\n\nGovernor: The prime mover provides the mechanism for controlling the synchronous machine speed and, hence, terminal voltage frequency.\n\nUsually the swing equation (SwingEq) is used for short time periods to analyze the transient behavior of generators in a power grid, the so-called first swing. The 4th-order model  also takes the back reaction of the power flow onto the voltage into account. This has the effect that the angle of the voltage as seen by the power grid, and the angle of the rotating mass are no longer the same but become dynamically coupled.\n\nAdditionally to u, it has the internal dynamic variables\n\nω representing the frequency of the rotator relative to the grid frequency Ω, i.e. the real frequency ω_r of the rotator is given as omega_r = Omega + omega and\nθ representing the relative angle of the rotor with respect to the voltage angle ϕ.\n\nKeyword Arguments\n\nH: shaft inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)\nP: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]\nD: damping coefficient (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal Dω)\nΩ: rated frequency of the power grid, often 2π50Hz\nT_d_dash: time constant of d-axis, given in [s], see P. Sauer, chapter 3.7, p. 54 for a general explanation on time constants\nT_q_dash: time constant of q-axis, given in [s]\nX_d_dash: transient reactance of d-axis, given in [pu]\nX_q_dash: transient reactance of q-axis, given in [pu]\nX_d: reactance of d-, given in [pu]\nX_d: reactance of q-axis, given in [pu]\nT_e : Exciter time constant, integration rate associated with exciter control [s]\nT_a : Maximum voltage regulator output [s]\nT_f : Excitation control system stabilizer time constant [s]\nK_e : Exciter constant related to self-excited field [pu]\nK_a : Voltage Regulator gain [pu]\nK_f : Excitation control system stabilizer gains [pu]\nV_ref : Reference voltage for the AVR [pu]\nR_d : Speed regulation R_d=2π droopΩ [s]\nT_sv : Steam Valve time constant [s]\nT_ch : Steam Chest time constant [s]\n\nMathematical Representation Synchronous Machine\n\nUsing FourthEq for node a applies the equations\n\n    u = -je_c e^jtheta = -j(e_d + je_q)e^jtheta\n    e_c= e_d + je_q = jue^-jtheta\n    i  = -jie^jtheta = -j(i_d+ j i_q )e^jtheta = Y^L cdot u \n    i_c= i_d + ji_q = jie^-jtheta\n    p = Re (i^* u) \n\nwhere complex voltage and current are described in a co-rotating frame with axes labeled d and q.\n\nThe fourth-order equations read (according to P. Sauer, \"Power System Dynamics and Stability\", p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)\n\n    fracdthetadt = omega \n    fracdomegadt = (P-Domega - p -(X_q-X_d)i_d i_q)Ω_H\n    fracd e_qdt = frac1T_d (- e_q - (X_d - X_d) i_d+ E_f) \n    fracd e_ddt = frac1T_q (- e_d + (X_q - X_q) i_q) \n\nExciter and AVR equations\n\n\tu_terminal = e_c - j X_d i \n\tS_e(e_fd) = 0098e^055 e_fd text(according to P Sauer p 70) \n\tdfracdR_fdt = dfrac1T_f (-R_f + dfracK_fT_f e_f) \n\tdfracdv_rdt = dfrac1T_a (-v_r + (K_a R_f) -dfracK_a K_fT_fe_fd + K_a (V_ref - u_terminal)) \n\tdfracde_fddt = dfrac1T_e (-K_e + S_e(e_fd)e_fd + v_r) \n\nGovernor equations\n\n    dfracdP_mdt = dfrac1T_ch (-P_m + P_sv) \n    textAssumption T_m = P_m \n    dfracdP_svdt = dfrac1T_sv (-P_sv + P_c -dfrac1R_d (dfracomegaΩ - 1)) \n\nThe equations for frequency and phase represent energy conservation and phase shift. The dynamic equations for the complex voltage show the relationship between the dynamicy of flux linkages and currents which must reflect a conservative coupling field.\n\nWith the PowerDynamics.jl naming conventions of i and u they read as\n\n   dot u = fracddt(-j e_c e^jtheta)=-j(dot e_d + jdot e_q)e^jtheta + ujomega \n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.PQAlgebraic","page":"Node Types","title":"PowerDynamics.PQAlgebraic","text":"    PQAlgebraic(; P,Q)\n\nA node type that locally fixes the active (P) and reactive power (Q) output of the node.\n\nKeyword Arguments\n\nP: active power set point\nQ: reactive power set point\n\nMathematical Representation\n\nUsing PQAlgebraic for node a applies the equation\n\n0 = (P_a + Q_a*im) - u_a cdot i_a^*\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.PVAlgebraic","page":"Node Types","title":"PowerDynamics.PVAlgebraic","text":"PVAlgebraic(;P,V)\n\nA node type that locally fixes the active power (P) and the voltage magnitude (V) of the node.\n\nKeyword Arguments\n\nP: the active (real) power output\nV: voltage magnitude\n\nMathematical Representation\n\nUsing PVAlgebraic for node a applies the equations\n\n0 = P_a - Releft(u_a cdot i_a^*right) \n0 = V_a - leftu_aright\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.PVInverterWithFrequencyControl","page":"Node Types","title":"PowerDynamics.PVInverterWithFrequencyControl","text":"PVInverterWithFrequencyControl(;I_n,k_PLL,f,f_s,T_m,k_P,τ_ω)\n\nThis implementation of a generic inverter model is built with standard components according to the report on \"Modelling of Inverter-Based Generation for Power System Dynamic Studies\" of the joint CIGRE working group.\n\nAdditionally to u, the global network-side voltage, it has the internal dynamic variables:\n\nθ_PLL: phase determined by the PLL\nv_xm: x-component of measured grid-side voltage\nv_ym: y-component of measured grid-side voltage\nP: power infeed of power plant\nω: frequeny deviation in rad/s.\n\nKeyword arguments are:\n\nI_n: the nominal current of the PV plant\nk_PLL: the PLL constant,\nf: the nominal frequency (50Hz usually)\nf_s: the set point at which droop control is triggered\nT_m: the time constant of the low pass filter for measuring the voltage locally at the inverter\nk_P: the droop control constant\nτ_ω time constant of the frequeny filter\n\nMathematical Representation\n\nUsing PVInverterWithFrequencyControl applies the equations\n\n    v_x = real(u)\n    v_y = imag(u)\n\nThe network-side power is\n\np = real(u cdot conj(i))\n\nThe nominal current of the PV inverter, I_n, is completely active current (we do not consider voltage regulation so far):\n\n    I_Pmax = I_n \n    I_Qmax = 0\n\n    fracdv_xmdt = 1T_m(v_x-v_xm)\n    fracdv_ymdt = 1T_m(v_y-v_ym)\n\nSince PowerDynamics is working with phasor units, this model has two d-q-systems (for the power plant and for the grid), I_pv_d and I_qv_q are the local coordinates and i_xv_x and i_yv_y are the global (grid) coordinates.\n\n    u_dq = (v_xm+j v_ym)e^-jtheta_PLL\n    v_d = real(u_dq)\n    v_q = imag(u_dq)\n\nThe local coordinates are chosen such that v_q=0:\n\n    dottheta_PLL = v_q(k_PLL)\n\nThe frequency deviation, dottheta_PLL,  is obtained thanks to the PLL controller of the units. Therefore, the measured frequency in Hz is given by\n\n        f_m = (1+dottheta_PLL)f\n\nAn additional filter is added to avoid a too fast PV reaction leading to unwanted oscillations of the active current during a short-term fault:\n\n    fracdomegadt = 1tau_omega(-omega + dottheta_PLLcdot2pi f)\n\nWith the active power determined by the droop control the current I_Pequals:\n\n    I_P=Pv_d\n\nImplementing the frequency dead band for overfrequnency control with:\n\n    fracdPdt =-k_P cdot domega cdot P_ext   textif (f_mf_s)\n    fracdPdt  = 0   textelse\n\nwhere f_s is the frequency at which the active power output starts decreasing and k_P is the droop control constant (in percentage of the rated power P_ext):\n\n    P_ext = real(I_Pmaxcdot(v_d+jv_q))= I_N v_d\n\n    0cdot dotu =i - (I_P+ j I_Q)e^jtheta_PLL\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.RLCLoad","page":"Node Types","title":"PowerDynamics.RLCLoad","text":"RLCLoad(R,L,C)\n\nEXPERIMENTAL A node type that represents the RLC load model according to \"Power Systems Electromagnetic Transients Simulation\", Neville Watson and Jos Arrillaga, IET 2007, p.59, eq. (3.47)\n\nKeyword Arguments\n\nR: resistance in [?]\nL: inductance in [?]\nC: capacitance in [?]\n\nMathematical Representation\n\n\tdfracdu_Cdt = frac1Ci_L(t)\n    dfracdi_Ldt = -fracRL i_L(t)+frac1L u(t)\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.SlackAlgebraic","page":"Node Types","title":"PowerDynamics.SlackAlgebraic","text":"SlackAlgebraic(;U)\n\nA node type that locally fixes the complex voltage (U) of the node.\n\nAs the complex voltage can be represented as U=Ve^iphi, this is equivlant to fixing the voltage magnitude V and the angle phi.\n\nKeyword Arguments\n\nU: the complex voltage\n\nMathematical Representation\n\nUsing SlackAlgebraic for node a applies the equation\n\n0 = U_a - u_a\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.SwingEq","page":"Node Types","title":"PowerDynamics.SwingEq","text":"SwingEq(;H, P, D, Ω)\n\nA node type that applies the swing equation to the frequency/angle dynamics and keeps the voltage magnitude as is. In the following, we followed the implementation of the 2nd-order Synchronous Machine Model according to  Sauer et. al. \"Power system dynamics and stability\", 1998.\n\nAdditionally to u, it has the internal dynamic variable omega representing the frequency of the rotator relative to the grid frequency Omega, i.e. the real frequency omega_r of the rotator is given as omega_r = Omega + omega.\n\nKeyword Arguments\n\nH: inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)\nP: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]\nD: damping coefficient, (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal Dω)\nΩ: rated frequency in [1/s] of the power grid, often 2pi50Hz\n\nMathematical Representation\n\nUsing SwingEq for node a applies the equations\n\nfracdu_adt = i u_a  omega_a \nfrac2HOmegafracdomega_adt = P_a - D_aomega_a - Releft(u_a cdot i_a^*right)\n\nwhich is equivalent to\n\nfracdphi_adt = omega \nv = v(t=0) = textconst \nfrac2HOmegafracdomega_adt = P_a - D_aomega_a - Releft(u_a cdot i_a^*right)\n\nwhere H = frac12fracJOmega^2S_b for a two-pole machine accoding to Sauer et. al. eq. (3.60) on p. 33. S_b is the rated three-phase MVA of the power system.\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.SwingEqLVS","page":"Node Types","title":"PowerDynamics.SwingEqLVS","text":"SwingEqLVS(;H, P, D, Ω, Γ, V)\n\nA node type that applies the swing equation to the frequency/angle dynamics and has a linear voltage stability (LVS) term.\n\nAdditionally to u, it has the internal dynamic variable omega representing the frequency of the rotator relative to the grid frequency Omega, i.e. the real frequency omega_r of the rotator is given as omega_r = Omega + omega.\n\nKeyword Arguments\n\nH: inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)\nP: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]\nD: damping coefficient, (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal Dω)\nΩ: rated frequency in [1/s] of the power grid, often 2pi50Hz\nΓ: voltage stability coefficient\nV: set voltage, usually 1\n\nMathematical Representation\n\nUsing SwingEq for node a applies the equations\n\nfracdu_adt = i u_a omega - fracuu Γ_a  (v_a - V_a) \nfrac2HOmegafracdomega_adt = P_a - D_aomega_a - Releft(u_a cdot i_a^*right)\n\nwhich is equivalent to\n\nfracdphi_adt = omega_a \nfracdv_adt = - Γ_a  (v_a - V_a) \nfrac2HOmegafracdomega_adt = P_a - D_aomega_a - Releft(u_a cdot i_a^*right)\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.VSIMinimal","page":"Node Types","title":"PowerDynamics.VSIMinimal","text":"VSIMinimal(;τ_P,τ_Q,K_P,K_Q,E_r,P,Q)\n\nA node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics. Implemented according to  Schiffer et. al., \"Conditions for stability of droop-controlled inverter-based microgrids\", Automatica, 2014.\n\nVSIMinimal models an inverters as AC voltage source which means the amplitude and frequency can defined by the designer (often called grid-forming inverter mode). The frequency and voltage regulation is assumed to be instantaneous. In addition simple proportional controllers are implemented for frequency and voltage such that the frequency ω and voltage amplitudes v of the inverters are modified depending on the deviations (with respect to a desired value) of the active and reactive powers, respectively. it is assumed that active and reactive power are measured via low pass filters with time constant τ_P and τ_Q, respectively. VSIMinimal can be derived from VSIVoltagePT1 by assuming an instantaneous voltage regulation without delay.\n\nAdditionally to u, it has the internal dynamic variable ω representing the frequency of the inverter frequency relative to the grid frequency Ω=2π50Hz, i.e. the real frequency ω_r of the inverter frequency is given as ω_r = Ω + ω.\n\nKeyword Arguments\n\nτ_p: time constant active power measurement\nτ_Q: time constant reactive power measurement\nK_P: droop constant frequency droop\nK_Q: droop constant voltage droop\nV_r: reference/ desired voltage\nP: active (real) power infeed\nQ: reactive (imag) power infeed\n\nMathematical Representation\n\nUsing VSIMinimal for node a (according to J. Schiffer et. al., eq. (7)) gives the equations\n\ndotphi_a=omega_a\n dotomega_a=frac1tau_Pa-omega_a-K_Pa (Releft(u_a cdot i_a^*right)-P_a)\ntau_Qdotv_a=-v_a+V_r-K_Qa (Imleft(u_a cdot i_a^*right)-Q_a)\n dotu_a=dotv_ae^jphi+jomega_a u_a\n\n```\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.VSIVoltagePT1","page":"Node Types","title":"PowerDynamics.VSIVoltagePT1","text":"VSIVoltagePT1(;τ_v,τ_P,τ_Q,K_P,K_Q,E_r,P,Q)\n\nA node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics. Implemented according to  Schiffer et. al., \"Conditions for stability of droop-controlled inverter-based microgrids\", Automatica, 2014.\n\nVSIVoltagePT1 models an inverters as AC voltage source which means the amplitude and frequency can defined by the designer (often called grid-forming inverter mode). The frequency regulation is assumed to be instantaneous, but the voltage control happens with a delay τ_v that is represented by a first order filter. In addition simple proportional controllers are implemented for frequency and voltage such that the frequency ω and voltage amplitudes v of the inverters are modified depending on the deviations (with respect to a desired value) of the active and reactive powers, respectively. ift is assumed that active and reactive power are measured via low pass fileters with time constant τ_P and τ_Q, respectively.\n\nHence, additionally to u, it has the internal dynamic variables\n\nω representing the frequency of the inverter relative to the grid frequency Ω=2π50Hz, i.e. the real frequency ω_r of the inverter is given as ω_r = Ω + ω.\nq_m is the measured reactive power at the grid connection point.\n\nKeyword Arguments\n\nτ_v: time constant voltage control delay\nτ_P: time constant active power measurement\nτ_Q: time constant reactive power measurement\nK_P: droop constant frequency droop\nK_Q: droop constant voltage droop\nV_r: reference/ desired voltage\nP: active (real) power infeed\nQ: reactive (imag) power infeed\n\nMathematical Representation\n\nUsing VSIVoltagePT1 for node a (according to J. Schiffer et. al., eq. (6)) gives the equations\n\ndotphi_a=omega_a\n dotomega_a=frac1tau_Pa-omega_a-K_Pa (Releft(u_a cdot i_a^*right)-P_refa)\n tau_vdotv_a=-v_a+V_ref-K_Qa(q_ma-Q_refa)\n tau_Q dotq_ma=-q_ma+Imleft(u_a cdot i_a^*right)\n dotu_a=dotv_ae^jphi+jomega_a u_a\n\nIn general τ_V  τ_P, assuming τ_V = 0 would then lead to VSIMinimal.\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.VoltageDependentLoad","page":"Node Types","title":"PowerDynamics.VoltageDependentLoad","text":"    VoltageDependentLoad(;P, Q, U, A, B)\n\nA node type that locally fixes the active (P) and reactive power (Q) output of the node.\n\nKeyword Arguments\n\nP: active power demand\nQ: reactive power demand\nU : the voltage set point\nA : relative share of quadratic voltage dependence \nB : relative share of linear voltage dependence \n\nMathematical Representation\n\nUsing VoltageDependentLoad for node a applies the equation\n\n0 = S_a ( A * (u_aU_a)^2 + B * (u_aU_a) + 1 - A - B) - u_a cdot i_a^*\n\n\n\n","category":"type"},{"location":"contact/#","page":"Contact","title":"Contact","text":"(Image: Build Status) (Image: Chat on Slack.) (Image: Get your Slack invitation.) (Image: Code on Github.)","category":"page"},{"location":"contact/#Contact-1","page":"Contact","title":"Contact","text":"","category":"section"},{"location":"contact/#","page":"Contact","title":"Contact","text":"In case of questions, please submit an issue on github or ask on our slack channel (get your invitation here).","category":"page"},{"location":"simulations/#Simulations-1","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"simulations/#","page":"Simulations","title":"Simulations","text":"After having defined a PowerGrid a simulation can be run.","category":"page"},{"location":"simulations/#","page":"Simulations","title":"Simulations","text":"Currently PowerDynamics supports the following simulations:","category":"page"},{"location":"simulations/#","page":"Simulations","title":"Simulations","text":"Perturbation\nLineFault\nNodeShortCircuit\nPowerPerturbation","category":"page"},{"location":"simulations/#","page":"Simulations","title":"Simulations","text":"Modules = [PowerDynamics]\nPages   = [\"simulations.jl\",\"NodeShortCircuit.jl\",\"PowerPerturbation.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"line_types/#Line-Types-1","page":"Line Types","title":"Line Types","text":"","category":"section"},{"location":"line_types/#","page":"Line Types","title":"Line Types","text":"The currently implemented line types are","category":"page"},{"location":"line_types/#","page":"Line Types","title":"Line Types","text":"using InteractiveUtils, PowerDynamics, Markdown\nlinetypes = subtypes(PowerDynamics.AbstractLine)\njoin([\"* [`$n`](@ref PowerDynamics.$n)\" for n in linetypes], \"\\n\") |> Markdown.parse","category":"page"},{"location":"line_types/#Detailed-Line-Type-Documentation-1","page":"Line Types","title":"Detailed Line Type Documentation","text":"","category":"section"},{"location":"line_types/#","page":"Line Types","title":"Line Types","text":"Modules = [PowerDynamics]\nFilter = t -> typeof(t) === DataType && t <: PowerDynamics.AbstractLine","category":"page"},{"location":"line_types/#PowerDynamics.PiModelLine","page":"Line Types","title":"PowerDynamics.PiModelLine","text":"    PiModelLine(from, to, y, y_shunt_km, y_shunt_mk)\n\nA line modelled according to the PI-Model.\n\nSee also the Chapter 2 in   Göran Andersson, Power System Analysis, Lecture 227-0526-00, ITET ETH Zurich, 2012\n\nArguments\n\nfrom : node k\nto : node m\ny: admittance of line between k and m\ny_shunt_km: shunt admittance at the end connected to node k\ny_shunt_mk: shunt admittance at the end connected to node m\nt_km: transformer ratio at the end connected to node k\nt_mk: transformer ratio at the end connected to node m\n\nAssumptions:\n\nthe line admittance is symmetric\n\n\n\n\n\n","category":"type"},{"location":"line_types/#PowerDynamics.RLLine","page":"Line Types","title":"PowerDynamics.RLLine","text":"RLLine(; from, to, R, L, ω0)\n\ndynamic line with series resistance R and series inductance L.\n\nKeyword Arguments\n\nfrom: start node of the line\nto: end node of the line\nR: series resistance R\nL: series inductance L\nω0: rated frequency in [rad/s] of the power grid, often 2π50Hz\n\nMathematical Representation\n\nUsing RLLine for the line from–to applies Eqn. (2) from Brouillon, J. S., Colombino, M., Groß, D., & Dörfler, F. (2018). The effect of transmission-line dynamics on a globally synchronizing controller for power inverters. In 2018 European Control Conference (ECC) (pp. 2242-2247). IEEE.\n\n\n\n\n\n","category":"type"},{"location":"line_types/#PowerDynamics.StaticLine","page":"Line Types","title":"PowerDynamics.StaticLine","text":"    StaticLine(from, to, Y)\n\nA static model that represents a line with an admittance Y.\n\nArguments\n\nfrom : start node\nto : end node\nY: scalar admittance of line between from and to\n\n\n\n\n\n","category":"type"},{"location":"line_types/#PowerDynamics.Transformer","page":"Line Types","title":"PowerDynamics.Transformer","text":"    Transformer(from, to, y, t_ratio)\n\nassuming an ideal transformer in series with an admittance. The representation uses the Π model.\n\nMathematical Representation\n\nThe voltage transforms as:\n\n    u_to = t_ratio u_from\n\nArguments\n\nfrom : start node\nto : end node\ny: transformer admittance\nt_ratio: transformation ration\n\nAssumptions\n\nThe admittance is here taken to be on the high-voltage side.\n\n\n\n\n\n","category":"type"},{"location":"line_types/#PowerDynamics.AbstractLine","page":"Line Types","title":"PowerDynamics.AbstractLine","text":"Abstract base type for all lines\n\n\n\n\n\n","category":"type"},{"location":"language_conventions/#Language-and-Conventions-1","page":"Language & Conventions","title":"Language & Conventions","text":"","category":"section"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"Generally, variables are miniscule (e.g. u, i, ω) and parameters are capitalized (e.g. H, D, P, Ω). As it is common to use greek letters for modeling equations and Julia supports Unicode, greek letters are used within the Code, e.g. Ω and ω in PowerDynamics.SwingEq. If you don't want to use greek keyboard (which I am currently switching to) you can simply type the latex representating \\Omega and Atom can complete it with Ω using Tab.","category":"page"},{"location":"language_conventions/#List-of-symbols-and-corresponding-names-1","page":"Language & Conventions","title":"List of symbols and corresponding names","text":"","category":"section"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"Symbol (Code) Symbol (Math) Name within PowerDynamics.jl Common alternative names\n  node bus, vertex\n  grid network, power grid, power network\n y_ab = y_ba admittance between nodes a and b \nLY Y^L admittance laplacian (nodal) admittance matrix\nt t time \nim j imaginary element sqrt-1\nu = v \\cdot exp(im*φ) u = v cdot e^jφ complex voltage \nv v voltage magnitude absolute voltage\nφ phi voltage angle \ni_c = i \\cdot exp(im*δ) i_c = i cdot e^jdelta nodal complex current \ni i magnitude of the current \nδ delta angle of the current \ns = p + im*q s = p + jq complex power \np p real power active power\nq q imaginary power reactive power","category":"page"},{"location":"language_conventions/#List-of-modeling-conventions-1","page":"Language & Conventions","title":"List of modeling conventions","text":"","category":"section"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"Counting of nodes starts at 1.\nRanges of nodes are mathematical, i.e. they include the first and the last element. For example sum_k=3^6 sums over 3, 4, 5, and 6.\nFor now, no selfadmittance is allowed, i.e. y_aa = 0 for all nodes a.\nThe admittance laplacian uses the following definition (convention from wikipedia)","category":"page"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"Y^L_ab = begincases\n  sum_c y_ac  textif  a=b \n  -y_ab  textotherwise\nendcases","category":"page"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"The nodal complex current is calculated as","category":"page"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"i_c_a = sum_b LY_ab u_b ","category":"page"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"The complex power is calculated as (with ^* as complex conjugation)","category":"page"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"s_a = u_a cdot i_c_a^*","category":"page"},{"location":"fullindex/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"fullindex/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"states_solutions/#States,-Solutions-and-Plotting-1","page":"States, Solutions & Plotting","title":"States, Solutions & Plotting","text":"","category":"section"},{"location":"states_solutions/#","page":"States, Solutions & Plotting","title":"States, Solutions & Plotting","text":"In order to properly interact with the state space of the power grid model, we defined two data structures PowerDynamics.State and PowerDynamics.PowerGridSolution.","category":"page"},{"location":"states_solutions/#States-1","page":"States, Solutions & Plotting","title":"States","text":"","category":"section"},{"location":"states_solutions/#","page":"States, Solutions & Plotting","title":"States, Solutions & Plotting","text":"State","category":"page"},{"location":"states_solutions/#PowerDynamics.State","page":"States, Solutions & Plotting","title":"PowerDynamics.State","text":"\n    State(base; t=nothing)\n    State(grid, vec; t=nothing)\n\n\nEncode the information on the value of a state vector at a particular time point.\n\nKeyword Arguments\n\nUse a PowerGrid instance grid and a properly sized   state vector vec to instantiate a State.\n\nIndexing\n\nConcerning the indexing, a State object s basically behaves like a an array. There are plenty of convenient ways to access its contents at a node j by using a particular symbol:\n\ns[j, :u]: complex voltage\ns[j, :v]: voltage magnitude\ns[j, :φ]: voltage angle\ns[j, :i]: complex nodal current\ns[j, :iabs]: nodal current magnitude\ns[j, :δ]: nodal current angle\ns[j, :s]: apparent power\ns[j, :p]: real power\ns[j, :q]: reactive power\n\nCurrently, setting the state value is only implemented for u and v, the other quantities are derived automatically.\n\nYou can access (and set) the k-th variable by calling\n\ns[j, :var, k].\n\nThe variables can be also directly accessed with symbols, i.e.\n\ns[j, :ω]\n\nreturns the frequency ω at node j. To find out the proper symbol, the easiest way is to look into the docs of the corresponding node type, check the output of symbolsof or simply look at the output of println:\n\njulia> symbolsof(SwingEq(H=2, P=3, D=4, Ω=5))\n1-element Array{Symbol,1}:\n :ω\n\njulia> println(SwingEq(H=2, P=3, D=4, Ω=5))\nSwingEq[:ω](H=2, P=3, D=4, Ω=5)\n\n\n\n\n\n","category":"type"},{"location":"states_solutions/#Solutions-and-Plotting-1","page":"States, Solutions & Plotting","title":"Solutions & Plotting","text":"","category":"section"},{"location":"states_solutions/#","page":"States, Solutions & Plotting","title":"States, Solutions & Plotting","text":"PowerGridSolution","category":"page"},{"location":"states_solutions/#PowerDynamics.PowerGridSolution","page":"States, Solutions & Plotting","title":"PowerDynamics.PowerGridSolution","text":"struct PowerGridSolution\n    dqsol::AbstractTimeseriesSolution\n    powergrid::PowerGrid\nend\n\nThe data structure interfacing to the solution of the differential equations of a power grid. Normally, it is not created by hand but return from PowerDynSolve.solve.\n\nAccessing the solution in a similar interface as State.\n\nFor some grid solution sol, one can access the variables as\n\nsol(t, n, s)\n\nwhere t is the time (either float or array), n the node number(s) (either integer, array, range (e.g. 2:3) or colon (:, for all nodes)), and s is the symbol represnting the chosen value. s can be either: :v, :φ, :i, :iabs, :δ, :s, :p, :q, or the symbol of the internal variable of the nodes. The meaning of the symbols derives from the conventions of PowerDynamics.jl. Finally, one can access the a-th internal variable of a node by using sol(t, n, :int, a).\n\nInterfacing the Plots.jl library via plotting recipes, that follow similar instructions as the direct access to the solution.\n\nFor some grid solution sol, one plot variables of the solution asin\n\nusing Plots\nplot(sol, n, s, plots_kwargs...)\n\nwhere n and s are as in the accessing of plots, and plots_kwargs are the keyword arguments for Plots.jl.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"General","title":"General","text":"(Image: Build Status) (Image: Chat on Slack.) (Image: Get your Slack invitation.) (Image: Code on Github.)","category":"page"},{"location":"#PowerDynamics.jl-Dynamic-Power-System-Analysis-in-Julia-1","page":"General","title":"PowerDynamics.jl - Dynamic Power System Analysis in Julia","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"This package provides all the tools you need to create a dynamic power grid model and analyze it.","category":"page"},{"location":"#","page":"General","title":"General","text":"The source code is licensed under GPLv3 and published on github.","category":"page"},{"location":"#","page":"General","title":"General","text":"These Docs have been built","category":"page"},{"location":"#","page":"General","title":"General","text":"using Dates\nfunction printBuiltTime()\n  println(Dates.format(now(), \"on YYYY-mm-dd at HH:MM\"))\nend","category":"page"},{"location":"#","page":"General","title":"General","text":"printBuiltTime() # hide","category":"page"},{"location":"#Installation-1","page":"General","title":"Installation","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"The installation can be done via the new package manager. Either use","category":"page"},{"location":"#","page":"General","title":"General","text":"]add PowerDynamics","category":"page"},{"location":"#","page":"General","title":"General","text":"or copy","category":"page"},{"location":"#","page":"General","title":"General","text":"using Pkg; Pkg.add(\"PowerDynamics\")","category":"page"},{"location":"#","page":"General","title":"General","text":"Please note that PowerDynamics.jl is a fast developing library whose API is not settled yet. In order to ensure that your old code will still work in the future while using the latest version of PowerDynamics.jl for your new code, we strongly recommend the usage of environments. Please check out this video from the introduction of Pkg3, where environments are introduced, too.","category":"page"},{"location":"#Compatibility-1","page":"General","title":"Compatibility","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"PowerDynamics.jl is written for Julia 1.0 and above. We will quickly switch to new Julia version as they come out, but support older versions and enable long transition periods for users. Julia versions 0.x are not supported.","category":"page"},{"location":"#Usage-1","page":"General","title":"Usage","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Generally, we distinguish three types of user for PowerDynamics.jl:","category":"page"},{"location":"#","page":"General","title":"General","text":"Grid Modeler\nGrid Component Developer\nPowerDynamics.jl Developer","category":"page"},{"location":"#Grid-Modeler-1","page":"General","title":"Grid Modeler","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Your Goal is to use PowerDynamics.jl to model your grid of preference. You don't want to implement new types of nodes.","category":"page"},{"location":"#","page":"General","title":"General","text":"We recommend you to choose your favorite example from PowerDynamicsExamples, read Node Types and try to understand it. That should give you the kickstart you need. If you have any questions, contact us.","category":"page"},{"location":"#Grid-Component-Developer-1","page":"General","title":"Grid Component Developer","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Your Goal is to use PowerDynamics.jl to develop types of nodes, e.g. new control schemes for inverters or new descriptions of synchronous machines.","category":"page"},{"location":"#","page":"General","title":"General","text":"After going through the introduction for a Grid Modeler, we recommend that you read through PowerGrid model and Custom Node Types and try to implement a new node type for an example grid. With that, you should have all the tools you need. If you have any questions, contact us.","category":"page"},{"location":"#PowerDynamics.jl-Developer-1","page":"General","title":"PowerDynamics.jl Developer","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Your Goal is to extend PowerDynamics.jl with new fundamental functionalities.","category":"page"},{"location":"#","page":"General","title":"General","text":"After going throught the introduction for a Grid Modeler and a Grid Component Developer, read through the code where hopefully all of this documentation will helpful for you. Afterwards, it's probably best to open an issue explainng the idea you want to implement and we can discuss how you can transform your idea into a pull request.","category":"page"}]
}
