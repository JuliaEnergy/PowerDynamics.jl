# (C) 2018 Potsdam Institute for Climate Impact Research, authors and contributors (see AUTHORS file)
# Licensed under GNU GPL v3 (see LICENSE file)

import Base: length, view, @__doc__
using MacroTools

issymbol(::Symbol) = true
issymbol(::Any) = false

"""
    abstract type AbstractDEVariable end

Abstract super type for all variables that [`PowerDynBase.AbstractNetworkFunction`](@ref) sub-types can be called with.

DEVariable stands for Differential Equation Variable.

The basic idea of a DEVariable is to combine (the arrays of) all necessary variables for a sub-type of [`PowerDynBase.GridDynamics`](@ref).
E.g. for a [`PowerDynBase.OrdinaryGridDynamics`](@ref) one needs only the state variable (here called `val` for value) and the derivative
(here called `ddt`). Hence, the definition for the corresponding [`PowerDynBase.ODEVariable`](@ref) is:

    @DEVariable struct ODEVariable{Tval, Tddt} <: AbstractODEVariable
        val::AbstractVector{Tval}
        ddt::AbstractVector{Tddt}
    end ddt

The final `ddt` statement is part of the [`PowerDynBase.@DEVariable`](@ref) macro stating that the output variable of this kind of DEVariable
is `ddt`. Further, the [`PowerDynBase.@DEVariable`](@ref) macro generates all the necessary constructors. Check its docs for more details.
"""
abstract type AbstractDEVariable end

"""
    function mapfields(f, s, args...)

Applies `f` to all fields of (the struct) `s` giving `args...` as additional arguments.

It's written as a `@generated` function in order to ensure that the compiler can infer the types.
"""
@generated function mapfields(f, s, args...)
    Expr(:call, nameof(s), [:(f(s.$field, args...)) for field in fieldnames(s) ]...)
end

"Extend view from arrays to subtypes of [`AbstractDEVariable`](@ref)."
function view(var::AbstractDEVariable, range)
    mapfields(view, var, range)
end

"Extend [`PowerDynBase.complexview`](@ref) from arrays to subtypes of [`AbstractDEVariable`](@ref)."
function complexview(var::AbstractDEVariable, i0, num)
    mapfields(complexview, var, i0, num)
end

length(var::AbstractDEVariable) = length(var.val)

_excomparison(ex) = [ex]
_excomparison(ex, exs...) = [[ex, :(==)]; _excomparison(exs...)]
"Create an expresseion where `==` is applied between all the expressions given as argument here."
excomparison(exs) = Expr(:comparison, _excomparison(exs...)...)

"""
Basically, this macro generates all the constructors (internal and external) for a subtype of AbstracDEVariable.

If you want to understand what this macro does, call [`PowerDynBase.showdefinition`](@ref) with a type that was generated by this macro, e.g.
`showdefinition(ODEVariable)`. It will output the full defintion that the macro actually creates.
"""
function create_DEVariable(structdef, outputfield::Symbol)
    structdef = deepcopy(structdef)
    @assert MacroTools.isstructdef(structdef)
    @assert @capture(structdef, struct name_{elementtypevars__} <: supername_
        typedfields__
    end)
    @capture(structdef, struct typedname_ <: _
        __
    end)
    @assert length(typedfields) >= 1
    fields = [field.args[1] for field in typedfields]
    typedinputfields = [field for field in typedfields if field.args[1] != outputfield]
    inputfields = [field.args[1] for field in typedinputfields]
    basic_constructor = Expr(:function, Expr(:where, Expr(:call, typedname, typedfields...), elementtypevars...), quote
            $( length(fields) > 1 ? :(@assert $(excomparison(map(field -> Expr(:call, :length, field), fields)))) : nothing)
            $(Expr(:call, :new, fields...))
        end
    )
    external_basic_constructor = :($(Expr(:where, Expr(:call, name, typedfields...), elementtypevars...)) = $(Expr(:call, typedname, fields...)))
    external_add_constructor = :($(Expr(:where, Expr(:call, name, typedinputfields...), elementtypevars...)) = $(Expr(:call, name, typedinputfields..., :(similar($(inputfields[1]))) )) )
    kw_constructor = Expr(:function, Expr(:call, name, Expr(:parameters, inputfields..., Expr(:kw, outputfield, :(nothing)))), quote
            if $outputfield == nothing
                $(Expr(:call, name, inputfields...))
            else
                $(Expr(:call, name, fields...))
            end
        end
    )
    append!(structdef.args[3].args, [basic_constructor])
    ex = quote
        @__doc__ $structdef
        $external_basic_constructor
        $external_add_constructor
        $kw_constructor
    end
    ex
end

"""
    @DEVariable struct DEVariableName{Type1, Type2, ...} <: AbstractODEVariable
        ...
    end outputVariableName

Basically, this macro generates all the constructors (internal and external) for a subtype of AbstracDEVariable.
In particular, it creates an external constructor that automatically chooses the type for the `outputVariableName` and instantiates this variable.

If you want to understand what this macro does, call [`PowerDynBase.showdefinition`](@ref) with a type that was generated by this macro, e.g.
`showdefinition(ODEVariable)`. It will output the full defintion that the macro actually creates.

Furthermore, the macro is just the interface for the [`PowerDynBase.create_DEVariable`](@ref) function.
"""
macro DEVariable(structdef, outputfield)
    mainex = create_DEVariable(structdef, outputfield)
    @capture(structdef, struct name_{__} <: _
        __
    end)
    mainexstr = "$(copy(mainex)|>rlr)"
    showex = :(showdefinition(io::IO, ::Type{$name}) = println(io, $mainexstr))
    append!(mainex.args, [showex])
    return esc(mainex)
end

"Abstract super type for all Variables for ODE-type node dynamics."
abstract type AbstractODEVariable <: AbstractDEVariable end
"Variables for ODE-type node dynamics."
@DEVariable struct ODEVariable{Tval, Tddt} <: AbstractODEVariable
    val::AbstractVector{Tval}
    ddt::AbstractVector{Tddt}
end ddt

"Abstract super type for all Variables for DAE-type node dynamics."
abstract type AbstractDAEVariable <: AbstractDEVariable end
"Variables for DAE-type node dynamics."
@DEVariable struct DAEVariable{Tval, Tddt, Tout} <: AbstractDAEVariable
    val::AbstractVector{Tval}
    ddt::AbstractVector{Tddt}
    out::AbstractVector{Tout}
end out
