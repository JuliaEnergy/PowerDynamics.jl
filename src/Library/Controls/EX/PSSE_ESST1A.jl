# PSSE ESST1A Excitation System
#
# Original work Copyright (c) 2016-2022 Luigi Vanfretti, ALSETLab, and contributors
# Original work licensed under BSD 3-Clause License
# Original source: https://github.com/OpenIPSL/OpenIPSL
#
# This Julia/PowerDynamics port maintains the same mathematical formulation
# while adapting to PowerDynamics/ModelingToolkit framework conventions.

"""
    PSSE_ESST1A

This model is a port of the OpenIPSL [`Electrical.Controls.PSSE.ES.ESST1A`](https://github.com/OpenIPSL/OpenIPSL/blob/fe8aa5c/OpenIPSL/Electrical/Controls/PSSE/ES/ESST1A.mo) model,
maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.

# Validation

Validated against the OpenIPSL SMIB testcase
[`Tests.Controls.PSSE.ES.ESST1A`](https://github.com/OpenIPSL/OpenIPSL/blob/fe8aa5c/OpenIPSL/Tests/Controls/PSSE/ES/ESST1A.mo).
See [validation plot](../assets/OpenIPSL_valid/ESST1A.png) generated by automatic validation script in `/test/OpenIPSL_test`.
"""
@mtkmodel PSSE_ESST1A begin
    @structural_parameters begin
        vothsg_input = false
        vuel_input = false
        voel_input = false
        UEL=0           # Under-excitation limiter input selection: 0=none, 1=VOEL, 2=VOEL2, 3=VOEL3
        VOS=0           # Overexcitation signal input selection: 0=none, 1=VOTHSG, 2=VOTHSG2
    end
    begin
        if UEL == 0 || VOS == 0
            throw(ArgumentError("PSSE_ESST1A: UEL and VOS structural parameters must be set >0! Got UEL=$UEL, VOS=$VOS"))
        end
    end

    @parameters begin
        # Fixed parameters with OpenIPSL defaults
        T_R=0, [description="Regulator input filter time constant [s]"]
        V_IMAX=99, [description="Maximum voltage error (regulator input) [pu]"]
        V_IMIN=-99, [description="Minimum voltage error (regulator input) [pu]"]
        T_C=0, [description="Regulator numerator (lead) time constant. First lead-lag [s]"]
        T_B=0, [description="Regulator denominator (lag) time constant. First lead-lag [s]"]
        T_C1=0, [description="Regulator numerator (lead) time constant. Second lead-lag [s]"]
        T_B1=0, [description="Regulator denominator (lag) time constant. Second lead-lag [s]"]
        K_A=400, [description="Voltage regulator gain [pu]"]
        T_A=0.02, [description="Voltage regulator time constant [s]"]
        V_AMAX=9, [description="Maximum regulator output [pu]"]
        V_AMIN=-5.43, [description="Minimum regulator output [pu]"]
        V_RMAX=9, [description="Maximum exciter output [pu]"]
        V_RMIN=-5.43, [description="Minimum exciter output [pu]"]
        K_C=0.2, [description="Rectifier loading factor proportional to commutating reactance [pu]"]
        K_F=0.03, [description="Rate feedback gain [pu]"]
        T_F=1, [description="Rate feedback time constant [s]"]
        K_LR=4.54, [description="Exciter output current limiter gain [pu]"]
        I_LR=4.4, [description="Exciter output current limit reference [pu]"]

        # optional input default values (when inputs are disabled)
        if !vothsg_input
            VOTHSG_set=0.0, [description="Other signal setpoint (i.e. PSS) [pu]"]
        end
        if !vuel_input
            VUEL_set=(UEL==1 ? 0.0 : -Inf), [description="Under-excitation limiter setpoint [pu]"]
        end
        if !voel_input
            VOEL_set=Inf, [description="Over-excitation limiter setpoint [pu]"]
        end

        # Free initialization parameter
        V_REF, [guess=1, description="Voltage reference setpoint [pu]"]
    end

    @components begin
        # Always required input/output interfaces
        ECOMP_in = RealInput()     # Terminal voltage measurement
        EFD_out = RealOutput()     # Field voltage output
        XADIFD_in = RealInput()    # Machine field current
        VT_in = RealInput()        # Terminal voltage for rectifier limiting

        # Optional auxiliary inputs (conditional on structural parameters)
        if vothsg_input
            VOTHSG_in = RealInput()    # Other signal input
        end
        if vuel_input
            VUEL_in = RealInput()      # Under-excitation limiter
        end
        if voel_input
            VOEL_in = RealInput()      # Over-excitation limiter
        end

        # Building block components
        transducer = SimpleLag(K=1, T=T_R)
        leadlag1 = LeadLag(K=1, T1=T_C, T2=T_B)
        leadlag2 = LeadLag(K=1, T1=T_C1, T2=T_B1)
        amplifier = SimpleLagLim(K=K_A, T=T_A, outMin=V_AMIN, outMax=V_AMAX)
        derivative_feedback = Derivative(K=K_F, T=T_F)
    end

    @variables begin
        # Signal processing variables
        voltage_error(t), [description="Voltage error signal [pu]"]
        sum_with_optional(t), [description="Sum signal with optional inputs"]
        voltage_limited(t), [description="Limited voltage error input [pu]"]

        current_limit_contribution(t), [description="Current limiter contribution [pu]"]
        hv_gate_input(t), [description="high-value gate input [pu]"]
        lv_gate_input(t), [description="low-value gate input [pu]"]
        EFD_unlimited(t), [description="Exciter output before rectifier limiting [pu]"]

        rectifier_v_max(t), [description="Rectifier upper voltage limit [pu]"]
        rectifier_v_min(t), [description="Rectifier lower voltage limit [pu]"]
    end
    begin
        _vothsg = vothsg_input ? VOTHSG_in.u : VOTHSG_set
        _voel = voel_input ? VOEL_in.u : VOEL_set
        _vuel = vuel_input ? VUEL_in.u : VUEL_set
    end
    @equations begin
        # Input transducer
        transducer.in ~ ECOMP_in.u
        voltage_error ~ V_REF - transducer.out

        if VOS == 1 && UEL == 1
            sum_with_optional ~ voltage_error + _vothsg + _vuel
        elseif VOS == 1 && UEL != 1
            sum_with_optional ~ voltage_error + _vothsg
        elseif VOS != 1 && UEL == 1
            sum_with_optional ~ voltage_error + _vuel
        else
            sum_with_optional ~ voltage_error
        end

        # Voltage error limiting
        voltage_limited ~ clamp(sum_with_optional - derivative_feedback.out, V_IMIN, V_IMAX)

        # first lead-lag compensator
        if UEL == 2
            leadlag1.in ~ max(voltage_limited, _vuel)
        else
            leadlag1.in ~ voltage_limited
        end

        # Second lead-lag compensator
        leadlag2.in ~ leadlag1.out

        # Voltage regulator/amplifier
        amplifier.in ~ leadlag2.out

        # Current limiting contribution
        current_limit_contribution ~ max(0, K_LR * (XADIFD_in.u - I_LR))

        # pre output hv gate
        if VOS==2
            hv_gate_input ~ amplifier.out - current_limit_contribution + _vothsg
        else
            hv_gate_input ~ amplifier.out - current_limit_contribution
        end

        if UEL == 3
            lv_gate_input ~ hv_gate_input
        else
            lv_gate_input ~ max(hv_gate_input, _vuel)
        end

        EFD_unlimited ~ min(lv_gate_input, _voel)
        derivative_feedback.in ~ EFD_unlimited

        # Rectifier commutation voltage drop limits
        rectifier_v_max ~ VT_in.u * V_RMAX - K_C * XADIFD_in.u
        rectifier_v_min ~ VT_in.u * V_RMIN - K_C * XADIFD_in.u

        # Final output with all limiting
        EFD_out.u ~ clamp(EFD_unlimited, rectifier_v_min, rectifier_v_max)
    end
end
