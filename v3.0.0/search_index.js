var documenterSearchIndex = {"docs":
[{"location":"import_export/#Import/export-1","page":"Import/export","title":"Import/export","text":"","category":"section"},{"location":"import_export/#","page":"Import/export","title":"Import/export","text":"PowerDynamics.jl supports import and export of power models into a custom JSON format.","category":"page"},{"location":"import_export/#Import-1","page":"Import/export","title":"Import","text":"","category":"section"},{"location":"import_export/#","page":"Import/export","title":"Import/export","text":"read_powergrid","category":"page"},{"location":"import_export/#PowerDynamics.read_powergrid","page":"Import/export","title":"PowerDynamics.read_powergrid","text":"read_powergrid(file, Json)\n\nParses an existing model in JSON format into a PowerGrid\n\n\n\n\n\n","category":"function"},{"location":"import_export/#Export-1","page":"Import/export","title":"Export","text":"","category":"section"},{"location":"import_export/#","page":"Import/export","title":"Import/export","text":"write_powergrid","category":"page"},{"location":"import_export/#PowerDynamics.write_powergrid","page":"Import/export","title":"PowerDynamics.write_powergrid","text":"write_powergrid(powergrid, file, Json)\n\nWrites a PowerGrid model into a file as JSON.\n\n\n\n\n\n","category":"function"},{"location":"custom_node_types/#Custom-Node-Types-1","page":"Custom Node Types","title":"Custom Node Types","text":"","category":"section"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"There are two ways to define custom node types:","category":"page"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"equation based modeling using ModelingToolkit.jl and BlockSystems.jl\nusing the @DynamicNode macro","category":"page"},{"location":"custom_node_types/#Custom-Nodes-using-BlockSystems.jl-1","page":"Custom Node Types","title":"Custom Nodes using BlockSystems.jl","text":"","category":"section"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"PowerDynmaics.jl provides a node constructor to build nodes from BlockSystem.jl objects based on voltage setting blocks:","category":"page"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"IONode","category":"page"},{"location":"custom_node_types/#PowerDynamics.IONode","page":"Custom Node Types","title":"PowerDynamics.IONode","text":"IONode{T,M} <: AbstractNode\nIONode(bp::BlockPara)\nIONode(blk::IOBlock, parameters::Dict)\n\nCreate an IONode based on an IOBlock and a parameter dict.\n\nThe block needs to fulfil the folowing interface:\n\ninputs:  i_r, i_i\noutputs: u_r, u_i\n\nThe block gets the flow sum of the connected lines as an input. It should calculate the resulting node voltage as an output (either per DGL or constraint).\n\nThe parameters should be provided as a Dict{Symbol,Float} such as\n\np = Dict(:a => 1.0,\n         :b => -π)\n\n\n\n\n\n","category":"type"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"Check out the examples/BlockSystems folder for more examples.","category":"page"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"There is another constructor to combine several current injecting blocks to a single node:","category":"page"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"BusNode\nBlockPara","category":"page"},{"location":"custom_node_types/#PowerDynamics.BusNode","page":"Custom Node Types","title":"PowerDynamics.BusNode","text":"BusNode(inj::BlockPara...; name=gensym(:Bus), verbose=false)\n\nCreate an IONode based on several current injectors/draws. Each current injector has to be provided as a BlockPara object, a composite of an IOBlock and a parameter dict. Each IOBlock has to fulfil the interface u_r, u_i ↦ i_r, i_i.\n\n\n\n\n\n","category":"function"},{"location":"custom_node_types/#PowerDynamics.BlockPara","page":"Custom Node Types","title":"PowerDynamics.BlockPara","text":"BlockPara(block, para; strict=true)\n\nComposite type holdes an IOBlock and a parameter Dict. Parameter Dict may be provided with Symbols (:a) or Symbolic types (blk.a). The latter will be transformed to Symbols.\n\nIf strict=true the construtor asserts that the given parameters match the internal parameters of the IOBlock.\n\n\n\n\n\n","category":"type"},{"location":"custom_node_types/#Component-library-1","page":"Custom Node Types","title":"Component library","text":"","category":"section"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"PowerDynamics has a submodule IOComponents which contains several predefined building blocks which may be used to build complex nodes.","category":"page"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"Modules = [PowerDynamics.IOComponents]","category":"page"},{"location":"custom_node_types/#PowerDynamics.IOComponents.DroopControl-Tuple{}","page":"Custom Node Types","title":"PowerDynamics.IOComponents.DroopControl","text":"DroopControl(;name, renamings...)\n\nReturns a DroopControl. The name of the system and the names of the vars can be changed with keyword arguments name=:myname, K=:myK, ….\n\nu = - K*(x - x_ref) + u_ref\n\n       +-----------------+\nx(t) --| K, x_ref, u_ref |-- u(t)\n       +-----------------+\n\nIOBlock :##droop# with 1 eqs\n├ inputs:  x(t)\n├ outputs: u(t)\n├ istates: (empty)\n└ iparams: K, x_ref, u_ref\n\n\n\n\n\n","category":"method"},{"location":"custom_node_types/#PowerDynamics.IOComponents.ImpedanceConstraint-Tuple{}","page":"Custom Node Types","title":"PowerDynamics.IOComponents.ImpedanceConstraint","text":"ImpedanceConstraint(;name, renamings...)\n\nReturns a Block that calculates complex current for fixed impedance: i = u/Z\n\ni_r = (R u_r + X u_i)/(R² + X²)\ni_i = (R u_i - X u_r)/(R² + X²)\n\n         +-----+\nu_r(t) --|  R  |-- i_r(t)\nu_i(t) --|  X  |-- i_i(t)\n         +-----+\n\n\n\n\n\n","category":"method"},{"location":"custom_node_types/#PowerDynamics.IOComponents.InversePowerConstraint-Tuple{}","page":"Custom Node Types","title":"PowerDynamics.IOComponents.InversePowerConstraint","text":"InversePowerConstraint(;name, renamings...)\n\nReturns a Block that calculates complex current for fixed complex power: i = conj(S/u)\n\ni_r = (P u_r + Q u_i)/(u_r² + u_i²)\ni_i = (P u_i - Q u_r)/(u_r² + u_i²)\n\n         +-----+\nu_r(t) --|  P  |-- i_r(t)\nu_i(t) --|  Q  |-- i_i(t)\n         +-----+\n\n\n\n\n\n","category":"method"},{"location":"custom_node_types/#PowerDynamics.IOComponents.LowPassFilter-Tuple{}","page":"Custom Node Types","title":"PowerDynamics.IOComponents.LowPassFilter","text":"LowPassFilter(;name, renamings...)\n\nReturns a low pass filter. The name of the system and the names of the vars can be changed with keyword arguments name=:myname, τ=:mytau, ….\n\nout'(t) = 1/τ (in(t) - out(t))\n\n           +-----+\ninput(t) --|  τ  |-- output(t)\n           +-----+\n\nIOBlock :##LPF# with 1 eqs\n├ inputs:  input(t)\n├ outputs: output(t)\n├ istates: (empty)\n└ iparams: τ\n\n\n\n\n\n","category":"method"},{"location":"custom_node_types/#PowerDynamics.IOComponents.Power-Tuple{}","page":"Custom Node Types","title":"PowerDynamics.IOComponents.Power","text":"Power(;name, renamings...)\n\nReturns a Block which calculates the active and reactive power for a given complex input.\n\nP = uᵣ iᵣ + uᵢ iᵢ\nQ = uᵢ iᵣ - uᵣ iᵢ\n\n         +-----+\nu_r(t) --|     |-- P(t)\nu_i(t) --|     |\ni_r(t) --|     |\ni_i(t) --|     |-- Q(t)\n         +-----+\n\nIOBlock :##power# with 2 eqs\n├ inputs:  u_i(t), u_r(t), i_i(t), i_r(t)\n├ outputs: P(t), Q(t)\n├ istates: (empty)\n└ iparams: (empty)\n\n\n\n\n\n","category":"method"},{"location":"custom_node_types/#PowerDynamics.IOComponents.PowerConstraint-Tuple{}","page":"Custom Node Types","title":"PowerDynamics.IOComponents.PowerConstraint","text":"PowerConstraint(;name, renamings...)\n\nReturns a Block that calculates complex voltage for fixed complex power: u = S/conj(i)\n\nu_r = (P i_r - Q i_i)/(i_r² + i_i²)\nu_i = (P i_i + Q i_r)/(i_r² + i_i²)\n\n         +-----+\ni_r(t) --|  P  |-- u_r(t)\ni_i(t) --|  Q  |-- u_i(t)\n         +-----+\n\n\n\n\n\n","category":"method"},{"location":"custom_node_types/#PowerDynamics.IOComponents.VoltageSource-Tuple{}","page":"Custom Node Types","title":"PowerDynamics.IOComponents.VoltageSource","text":"VoltageSource(;name, renamings...)\n\nReturns a VoltageSource Block. Models the complex voltage dynamic as a low pass inspired by Schiffer et. al. for a reference frequency ω and voltage magnitude V.\n\n   A = 1/τ ⋅ (V/√(uᵢ² + uᵣ²) - 1)\nu_r' = -ω uᵢ + A uᵣ\nu_i' =  ω uᵣ + A uᵢ\n\n       +-----+\nω(t) --|  τ  |-- u_r(t)\nV(t) --|     |-- u_i(t)\n       +-----+\n\nIOBlock :##vsource# with 3 eqs\n├ inputs:  ω(t), V(t)\n├ outputs: u_i(t), u_r(t)\n├ istates: A(t)\n└ iparams: τ\n\n\n\n\n\n","category":"method"},{"location":"custom_node_types/#PowerDynamics.IOComponents.Adder","page":"Custom Node Types","title":"PowerDynamics.IOComponents.Adder","text":"Adder(n=2; name, renamings...)\n\nReturns a simple block which adds n inputs.\n\nout(t) = a₁(t) + a₂(t) + ...\n\n\n\n\n\n","category":"function"},{"location":"custom_node_types/#PowerDynamics.IOComponents.Constants-Tuple","page":"Custom Node Types","title":"PowerDynamics.IOComponents.Constants","text":"Constants(constants...)\n\nReturns in IOBlock with outputs which are directly mapped to values.\n\njulia> blk = PowerDynamics.IOComponents.Constants(:a=>42, :b=>3.14; name=:const)\nIOBlock :const with 2 eqs\n  ├ inputs:  (empty)\n  ├ outputs: a(t), b(t)\n  ├ istates: (empty)\n  └ iparams: (empty)\n\njulia> equations(blk)\n2-element Vector{Equation}:\n a(t) ~ 42\n b(t) ~ 3.14\n\n\n\n\n\n","category":"method"},{"location":"custom_node_types/#Custom-Nodes-using-the-Node-Macro-1","page":"Custom Node Types","title":"Custom Nodes using the Node Macro","text":"","category":"section"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"To define your own Node Types, use the PowerDynamics.@DynamicNode macro. The new node type will be a subtype of PowerDynamics.AbstractNode.","category":"page"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"@DynamicNode","category":"page"},{"location":"custom_node_types/#PowerDynamics.@DynamicNode","page":"Custom Node Types","title":"PowerDynamics.@DynamicNode","text":"Macro for creating a new type of dynamic nodes.\n\nSyntax Description:\n\n@DynamicNode MyNewNodeName(Par1, Par2, ...) begin\n    [MassMatrix definition]\nend begin\n    [all prepratory things that need to be run just once]\nend [[x1, dx1], [x2, dx2]] begin\n    [the actual dynamics equation]\n    [important to set the output variables]\nend\n\nwhere MyNewNodeName is the name of the new type of dynamic node, Par1, Par2, ... are the names of the parameters, x1, x2, ... the internal variables of the node and dx1, dx2, ... the corresponding differentials.\n\nIn the first block a MassMatrix may be specified. Using the MassMatrix helper function here is recommended. The whole block can be omitted and the identity matrix I is then used as default.\n\nIn the second block, the preparation code that needs to be run only once is inserted. Finally, the third block contains the dynamics description, where it's important that the output variables need to be set. These are du and the differentials of the internal variables (here dx1, dx2).\n\nBelow are two examples:\n\n@DynamicNode SwingEqParameters(H, P, D, Ω) begin\n    @assert D > 0 \"damping (D) should be >0\"\n    @assert H > 0 \"inertia (H) should be >0\"\n    Ω_H = Ω * 2pi / H\nend [[ω, dω]] begin\n    p = real(u * conj(i_c))\n    dϕ = ω # dϕ is only a temp variable that Julia should optimize out\n    du = u * im * dϕ\n    dω = (P - D*ω - p)*Ω_H\nend\n\n@DynamicNode SlackAlgebraicParameters(U) begin\n    MassMatrix() # no masses\nend begin\n    # empty prep block\nend [] begin\n        du = u - U\nend\n\n\n\n\n\n","category":"macro"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"PowerDynamics.MassMatrix","category":"page"},{"location":"custom_node_types/#PowerDynamics.MassMatrix","page":"Custom Node Types","title":"PowerDynamics.MassMatrix","text":"MassMatrix(;m_u::Bool = false, m_int = no_internal_masses)\n\nCreates a massmatrix. Calling:\n\nMassMatrix()\n\ncreates a mass matrix with all masses turned off.\n\nKeyword Arguments\n\nm_u::Bool=false: Mass matrix value for the complex voltage u.\nm_int::Vector{Bool}=Vector{Bool}(): A vector representing the diagonal of the mass matrix. Specifies the masses for the remaining/internal variables.\n\n\n\n\n\n","category":"function"},{"location":"error_types/#Error-Types-1","page":"Error Types","title":"Error Types","text":"","category":"section"},{"location":"error_types/#","page":"Error Types","title":"Error Types","text":"PowerDynamicsError\nNodeDynamicsError\nStateError\nGridSolutionError\nOperationPointError","category":"page"},{"location":"error_types/#PowerDynamics.PowerDynamicsError","page":"Error Types","title":"PowerDynamics.PowerDynamicsError","text":"Abstract super type of all PowerDynamics.jl Errors.\n\n\n\n\n\n","category":"type"},{"location":"error_types/#PowerDynamics.NodeDynamicsError","page":"Error Types","title":"PowerDynamics.NodeDynamicsError","text":"Error to be thrown if something goes wrong during the node dynamics construction.\n\n\n\n\n\n","category":"type"},{"location":"error_types/#PowerDynamics.StateError","page":"Error Types","title":"PowerDynamics.StateError","text":"Error to be thrown if something goes wrong when creating or modifying states.\n\n\n\n\n\n","category":"type"},{"location":"error_types/#PowerDynamics.GridSolutionError","page":"Error Types","title":"PowerDynamics.GridSolutionError","text":"Error to be thrown if something goes wrong during power grid solving\n\n\n\n\n\n","category":"type"},{"location":"error_types/#PowerDynamics.OperationPointError","page":"Error Types","title":"PowerDynamics.OperationPointError","text":"Error to be thrown if something goes wrong during the operation point search.\n\n\n\n\n\n","category":"type"},{"location":"powergrid_model/#PowerGrid-model-1","page":"PowerGrid model","title":"PowerGrid model","text":"","category":"section"},{"location":"powergrid_model/#","page":"PowerGrid model","title":"PowerGrid model","text":"Modules = [PowerDynamics]\nPages   = [\"PowerGrid.jl\"]\nOrder   = [:function, :type]","category":"page"},{"location":"powergrid_model/#PowerDynamics.systemsize-Tuple{PowerGrid}","page":"PowerGrid model","title":"PowerDynamics.systemsize","text":"Returns the total size of dynamical variables of the whole powergrid\n\n\n\n\n\n","category":"method"},{"location":"powergrid_model/#PowerDynamics.PowerGrid","page":"PowerGrid model","title":"PowerDynamics.PowerGrid","text":"Powergrid(graph, nodes, lines)\n\nOur model describes a powergrid as an undirected graph consisting of edges that represent electrical lines and vertices that represent specific electrical nodes i.e. generators, inverters etc.\n\n\n\n\n\n","category":"type"},{"location":"powergrid_model/#PowerDynamics.PowerGrid-Tuple{Any, Any}","page":"PowerGrid model","title":"PowerDynamics.PowerGrid","text":"Powergrid(nodes, lines)\n\ncreates a PowerGrid from nodes and lines (either given as a list or as a dictionay).  The underlying graph is created automatically.\n\n\n\n\n\n","category":"method"},{"location":"node_types/#Node-Types-1","page":"Node Types","title":"Node Types","text":"","category":"section"},{"location":"node_types/#","page":"Node Types","title":"Node Types","text":"The currently implemented node types are","category":"page"},{"location":"node_types/#","page":"Node Types","title":"Node Types","text":"using InteractiveUtils, PowerDynamics, Markdown\nnodetypes = subtypes(PowerDynamics.AbstractNode)\njoin([\"* [`$n`](@ref PowerDynamics.$n)\" for n in nodetypes], \"\\n\") |> Markdown.parse","category":"page"},{"location":"node_types/#Detailed-Node-Type-Documentation-1","page":"Node Types","title":"Detailed Node Type Documentation","text":"","category":"section"},{"location":"node_types/#","page":"Node Types","title":"Node Types","text":"Modules = [PowerDynamics]\nFilter = t -> typeof(t) === DataType && t <: PowerDynamics.AbstractNode","category":"page"},{"location":"node_types/#PowerDynamics.AbstractNode","page":"Node Types","title":"PowerDynamics.AbstractNode","text":"Abstract base type for all nodes\n\n\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.CSIMinimal","page":"Node Types","title":"PowerDynamics.CSIMinimal","text":"CSIMinimal(;I_r)\n\nA node type that keeps the current fixed as a desired values I_r.\n\nCSIMinimal models an inverters as an ideal current source. This can be the most simple representation of an inverter in grid-feeding mode, according to Rocabert, Joan, et al. \"Control of power converters in AC microgrids.\" (2012). Here, additionally to u, there are no internal dynamic variables.\n\nKeyword Arguments\n\nI_r: reference/ desired current\n\nMathematical Representation\n\nUsing CSIMinimal for node a gives:\n\n0 = I_ra - lefti_aright\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.CurtailedPowerPlantWithInertia","page":"Node Types","title":"PowerDynamics.CurtailedPowerPlantWithInertia","text":"CurtailedPowerPlantWithInertia(;)\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.ExponentialRecoveryLoad","page":"Node Types","title":"PowerDynamics.ExponentialRecoveryLoad","text":"ExponentialRecoveryLoad(P0, Q0, Nps, Npt, Nqs, Nqt, Tp, Tq, V0)\n\nA node type that represents the exponential recovery load model. The exponential recovery load model aims to capture the load restoration characteristics with an exponential recovery process expressed as an input–output relationship between powers (real and reactive) and voltage.\n\nKeyword Arguments\n\nP0: Active power load demand [pu]\nQ0: Reactive power load demand [pu]\nNps: Steady-state load voltage dependence p-axis [pu]\nNpt: Transient load voltage dependence p-axis [pu]\nNqs: Steady-state load voltage dependence q-axis [pu]\nNqt: Transient load voltage dependence q-axis [ pu]\nTp: Load recovery constant p-axis [s]\nTq: Load recovery constant q-axis [s]\nV0: Reference grid voltage [pu]\n\nMathematical Representation\n\n\tdfracdx_pdt = dfrac1T_p(-x_p + P_0(dfracuV_0)^N_ps - P_0(dfracuV_0)^N_pt) \n    dfracdx_qdt = dfrac1T_q(-x_q + Q_0(dfracuV_0)^N_qs - Q_0(dfracuV_0)^N_qt) \n    P = x_p + P_0(dfracuV_0)^N_pt \n    Q = x_q - Q_0(dfracuV_0)^N_qt \n\nIEEE TRANSACTIONS ON POWER SYSTEMS, VOL. 21, NO. 3, AUGUST 2006 Measurement-Based Dynamic Load Models: Derivation, Comparison, and Validation Byoung-Kon Choi, Member, IEEE, Hsiao-Dong Chiang, Fellow, IEEE, Yinhong Li, Hua Li, Member, IEEE, Yung-Tien Chen, Der-Hua Huang, and Mark G. Lauby\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.FourthOrderEq","page":"Node Types","title":"PowerDynamics.FourthOrderEq","text":"FourthEq(H, P, D, Ω, E_f, T_d_dash ,T_q_dash ,X_q_dash ,X_d_dash,X_d, X_q)\n\nA node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics, which is implemented according to P. Sauer, \"Power System Dynamics and Stability\". For an illustration of a synchronous machine schematic see P. Sauer, Fig. 3.1 on p. 25.\n\nUsually the swing equation (SwingEq) is used for short time periods to analyze the transient behavior of generators in a power grid, the so-called first swing. The 4th-order model  also takes the back reaction of the power flow onto the voltage into account. This has the effect that the angle of the voltage as seen by the power grid, and the angle of the rotating mass are no longer the same but become dynamically coupled.\n\nAdditionally to u, it has the internal dynamic variables\n\nω representing the frequency of the rotator relative to the grid frequency Ω, i.e. the real frequency ω_r of the rotator is given as omega_r = Omega + omega and\nθ representing the relative angle of the rotor with respect to the voltage angle ϕ.\n\nKeyword Arguments\n\nH: shaft inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)\nP: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]\nD: damping coefficient (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal Dω)\nΩ: rated frequency of the power grid, often 2π50Hz\nT_d_dash: time constant of d-axis, given in [s], see P. Sauer, chapter 3.7, p. 54 for a general explanation on time constants\nT_q_dash: time constant of q-axis, given in [s]\nX_d_dash: transient reactance of d-axis, given in [pu]\nX_q_dash: transient reactance of q-axis, given in [pu]\nX_d: reactance of d-, given in [pu]\nX_d: reactance of q-axis, given in [pu]\nE_f: scaled field voltage, which, if set equal to 1.0 pu, gives 1.0 pu open-circuit terminal voltage. The physical device that provides the value of E_f is called the exciter (according to P. Sauer, p. 65)\n\nMathematical Representation\n\nUsing FourthEq for node a applies the equations\n\n    u = -je_c e^jtheta = -j(e_d + je_q)e^jtheta\n    e_c= e_d + je_q = jue^-jtheta\n    i  = -jie^jtheta = -j(i_d+ j i_q )e^jtheta = Y^L cdot u \n    i_c= i_d + ji_q = jie^-jtheta\n    p = Re (i^* u)\n\nwhere complex voltage and current are described in a co-rotating frame with axes labeled d and q.\n\nThe fourth-order equations read (according to P. Sauer, \"Power System Dynamics and Stability\", p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)\n\n    fracdthetadt = omega \n     fracdomegadt = (P-Domega - p -(X_q-X_d)i_d i_q)Ω_H\n    fracd e_qdt = frac1T_d (- e_q - (X_d - X_d) i_d+ E_f) \n    fracd e_ddt = frac1T_q (- e_d + (X_q - X_q) i_q)  \n\nThe equations for frequency and phase represent energy conservation and phase shift. The dynamic equations for the complex voltage show the relationship between the dynamicy of flux linkages and currents which must reflect a conservative coupling field.\n\nWith the PowerDynamics.jl naming conventions of i and u they read as\n\n   dot u = fracddt(-j e_c e^jtheta)=-j(dot e_d + jdot e_q)e^jtheta + ujomega\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.FourthOrderEqExciterIEEEDC1A","page":"Node Types","title":"PowerDynamics.FourthOrderEqExciterIEEEDC1A","text":"A node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics, which is implemented according to P. Sauer, \"Power System Dynamics and Stability\". For an illustration of a synchronous machine schematic see P. Sauer, Fig. 3.1 on p. 25. Usually the swing equation (SwingEq) is used for short time periods to analyze the transient behavior of generators in a power grid, the so-called first swing. The 4th-order model  also takes the back reaction of the power flow onto the voltage into account. This has the effect that the angle of the voltage as seen by the power grid, and the angle of the rotating mass are no longer the same but become dynamically coupled.\n\nIn addition to the 4th-order model the Type IEEEDC1A exciter was implemented. The type was implemented using the following resources as the guide line: \"MatDyn\" Copyright ©2009 Stijn Cole and \"IEEE Recommended Practice for Excitation System Models for Power System Stability Studies\", IEEE Power and Energy Society, 2016\n\nAdditionally to u, it has the internal dynamic variables\n\nω representing the frequency of the rotator relative to the grid frequency Ω, i.e. the real frequency ω_r of the rotator is given as omega_r = Omega + omega\nθ representing the relative angle of the rotor with respect to the voltage angle ϕ.\nE_f representing the scaled field voltage, The exciter model (here IEEEDC1A) provides the value for E_f(according to P. Sauer, p. 65)\nU_r representing the Voltage regulator output in [pu]\nU_f representing the excitation system stabilization rate feedback\n\nKeyword Arguments\n\nH: shaft inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)\nP: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]\nD: damping coefficient (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal Dω)\nΩ: rated frequency of the power grid, often 2π50Hz\nT_d_dash: time constant of d-axis, given in [s], see P. Sauer, chapter 3.7, p. 54 for a general explanation on time constants\nT_q_dash: time constant of q-axis, given in [s]\nX_d_dash: transient reactance of d-axis, given in [pu]\nX_q_dash: transient reactance of q-axis, given in [pu]\nX_d: reactance of d-, given in [pu]\nX_d: reactance of q-axis, given in [pu]\n\nIEEE DC1A Exciter Model\n\nK_e: Exciter constant related to self-excited field [pu]\nK_f: Excitation control system stabilizer gains [pu]\nK_a: Voltage Regulator gain [pu]\nU:\nU_ref: Reference value of the stator terminal voltage [pu]\nU_ref2: Reference value of the stator terminal voltage [pu]\nU_rmax: Voltage regulator maximum output [pu]\nU_rmin: Voltage regulator minimum output [pu]\nT_a: Time constant of the voltage regulator [s]\nT_f: Excitation control system stabilizer time constant [s]\nT_e: Exciter time constant, integration rate associated with exciter control [s]\n\nThe fourth-order equations read (according to P. Sauer, \"Power System Dynamics and Stability\", p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)\n\n    fracdthetadt = omega \n     fracdomegadt = (P-Domega - p -(X_q-X_d)i_d i_q)Ω_H\n    fracd e_qdt = frac1T_d (- e_q - (X_d - X_d) i_d+ E_f) \n    fracd e_ddt = frac1T_q (- e_d + (X_q - X_q) i_q)  \n\nThe IEEE DC1A Exciter Model applies the following equations:\n\n    U_x = A_x cdot e^(B_x cdot E_f) \n    dU_r = frac1T_a cdot (K_a cdot (U_ref - U + U_ref2 - U_f) - U_r)\n    dU_f = frac1T_f cdot (fracK_fT_e cdot (U_r - U_x - K_e cdot E_f) - U_f)\n    U_r2 = begincases\n                U_rmax  textif  U_r  U_rmax  \n                U_rmin  textif  U_r  U_rmin \n                U_r   textelse\n            endcases\n    dE_f = 1  T_e cdot (U_r2 - U_x - K_e cdot E_f)\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.FourthOrderEqGovernorExciterAVR","page":"Node Types","title":"PowerDynamics.FourthOrderEqGovernorExciterAVR","text":"FourthOrderEqGovernorExciterAVR(H, P, D, Ω, T_d_dash ,T_q_dash ,X_q_dash ,X_d_dash,X_d, X_q, T_e, T_a, T_f, K_e, K_a, K_f, V_ref, R_d, T_sv, T_ch)\n\nA node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics, including an Exciter, Automatic Voltage Regulator and Governor which is implemented according to P. Sauer, \"Power System Dynamics and Stability\". For an illustration of a synchronous machine schematic see P. Sauer, Fig. 3.1 on p. 25.\n\nExciter and Automatic Voltage Regulator: The equations for the systems that balance the AC synchronous machine voltage level by increasing or decreasing the exciter DC voltage. Note, within this model, the transient reactance in the d-axis of the generator needs to be included into the nodal admittance matrix. As the bus of this generator node type is constructed to be an internal generator bus.\n\nGovernor: The prime mover provides the mechanism for controlling the synchronous machine speed and, hence, terminal voltage frequency.\n\nUsually the swing equation (SwingEq) is used for short time periods to analyze the transient behavior of generators in a power grid, the so-called first swing. The 4th-order model  also takes the back reaction of the power flow onto the voltage into account. This has the effect that the angle of the voltage as seen by the power grid, and the angle of the rotating mass are no longer the same but become dynamically coupled.\n\nAdditionally to u, it has the internal dynamic variables\n\nω representing the frequency of the rotator relative to the grid frequency Ω, i.e. the real frequency ω_r of the rotator is given as omega_r = Omega + omega and\nθ representing the relative angle of the rotor with respect to the voltage angle ϕ.\n\nKeyword Arguments\n\nH: shaft inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)\nP: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]\nD: damping coefficient (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal Dω)\nΩ: rated frequency of the power grid, often 2π50Hz\nT_d_dash: time constant of d-axis, given in [s], see P. Sauer, chapter 3.7, p. 54 for a general explanation on time constants\nT_q_dash: time constant of q-axis, given in [s]\nX_d_dash: transient reactance of d-axis, given in [pu]\nX_q_dash: transient reactance of q-axis, given in [pu]\nX_d: reactance of d-, given in [pu]\nX_d: reactance of q-axis, given in [pu]\nT_e : Exciter time constant, integration rate associated with exciter control [s]\nT_a : Maximum voltage regulator output [s]\nT_f : Excitation control system stabilizer time constant [s]\nK_e : Exciter constant related to self-excited field [pu]\nK_a : Voltage Regulator gain [pu]\nK_f : Excitation control system stabilizer gains [pu]\nV_ref : Reference voltage for the AVR [pu]\nR_d : Speed regulation R_d=2π droopΩ [s]\nT_sv : Steam Valve time constant [s]\nT_ch : Steam Chest time constant [s]\n\nMathematical Representation Synchronous Machine\n\nUsing FourthEq for node a applies the equations\n\n    u = -je_c e^jtheta = -j(e_d + je_q)e^jtheta\n    e_c= e_d + je_q = jue^-jtheta\n    i  = -jie^jtheta = -j(i_d+ j i_q )e^jtheta = Y^L cdot u \n    i_c= i_d + ji_q = jie^-jtheta\n    p = Re (i^* u) \n\nwhere complex voltage and current are described in a co-rotating frame with axes labeled d and q.\n\nThe fourth-order equations read (according to P. Sauer, \"Power System Dynamics and Stability\", p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)\n\n    fracdthetadt = omega \n    fracdomegadt = (P-Domega - p -(X_q-X_d)i_d i_q)Ω_H\n    fracd e_qdt = frac1T_d (- e_q - (X_d - X_d) i_d+ E_f) \n    fracd e_ddt = frac1T_q (- e_d + (X_q - X_q) i_q) \n\nExciter and AVR equations\n\n\tu_terminal = e_c - j X_d i \n\tS_e(e_fd) = 0098e^055 e_fd text(according to P Sauer p 70) \n\tdfracdR_fdt = dfrac1T_f (-R_f + dfracK_fT_f e_f) \n\tdfracdv_rdt = dfrac1T_a (-v_r + (K_a R_f) -dfracK_a K_fT_fe_fd + K_a (V_ref - u_terminal)) \n\tdfracde_fddt = dfrac1T_e (-K_e + S_e(e_fd)e_fd + v_r) \n\nGovernor equations\n\n    dfracdP_mdt = dfrac1T_ch (-P_m + P_sv) \n    textAssumption T_m = P_m \n    dfracdP_svdt = dfrac1T_sv (-P_sv + P_c -dfrac1R_d (dfracomegaΩ - 1)) \n\nThe equations for frequency and phase represent energy conservation and phase shift. The dynamic equations for the complex voltage show the relationship between the dynamicy of flux linkages and currents which must reflect a conservative coupling field.\n\nWith the PowerDynamics.jl naming conventions of i and u they read as\n\n   dot u = fracddt(-j e_c e^jtheta)=-j(dot e_d + jdot e_q)e^jtheta + ujomega \n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.FourthOrderEqGovernorIEEEG1","page":"Node Types","title":"PowerDynamics.FourthOrderEqGovernorIEEEG1","text":"A node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics, which is implemented according to P. Sauer, \"Power System Dynamics and Stability\". For an illustration of a synchronous machine schematic see P. Sauer, Fig. 3.1 on p. 25. Usually the swing equation (SwingEq) is used for short time periods to analyze the transient behavior of generators in a power grid, the so-called first swing. The 4th-order model  also takes the back reaction of the power flow onto the voltage into account. This has the effect that the angle of the voltage as seen by the power grid, and the angle of the rotating mass are no longer the same but become dynamically coupled.\n\nIn addition to the 4th-order model the  Type IEEEG1 governor was implemented. It is used for tandem compound, double reheat steam turbine systems. The type was implemented using the following resources as the guide line: \"MatDyn\" Copyright ©2009 Stijn Cole and \"Dynamic Models for Turbine-Governors in Power System Studies\", IEEE PES, 2013, Page 2 - 2\n\nAdditionally to u, it has the internal dynamic variables\n\nω representing the frequency of the rotator relative to the grid frequency Ω, i.e. the real frequency ω_r of the rotator is given as omega_r = Omega + omega and\nθ representing the relative angle of the rotor with respect to the voltage angle ϕ.\nPm representing the active power output, also called the mechanical torque applied to the shaft, given in [pu]\nx1 representing an internal variable block input\nz representing an internal variable block output\nP representing the power of the servomotor [pu]\n\nKeyword Arguments\n\nH: shaft inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)\nD: damping coefficient (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal Dω)\nΩ: rated frequency of the power grid, often 2π50Hz\nT_d_dash: time constant of d-axis, given in [s], see P. Sauer, chapter 3.7, p. 54 for a general explanation on time constants\nT_q_dash: time constant of q-axis, given in [s]\nX_d_dash: transient reactance of d-axis, given in [pu]\nX_q_dash: transient reactance of q-axis, given in [pu]\nX_d: reactance of d-, given in [pu]\nX_d: reactance of q-axis, given in [pu]\nE_f: scaled field voltage, which, if set equal to 1.0 pu, gives 1.0 pu open-circuit terminal voltage. The physical device that provides the value of E_f is called the exciter (according to P. Sauer, p. 65)\n\nGoverner\n\nP0: Reference power\nPmax: Max power limit imposed by valve or gate control [pu]\nPmin: Min power limit imposed by valve or gate control [pu]\nPup: Max main control valve rate of change [pu/s]\nPdown: Min main control valve rate of change [pu/s]\nT1: Controller lag compensation [s]\nT2: Controller lead compensation [s]\nT3: Valve position time constant (servomotor mechanism) [s]\nK: Total effective speed-governing system gain [pu]\n\nThe fourth-order equations read (according to P. Sauer, \"Power System Dynamics and Stability\", p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)\n\n    fracdthetadt = omega \n    fracdomegadt = (P-Domega - p -(X_q-X_d)i_d i_q)Ω_H\n    fracd e_qdt = frac1T_d (- e_q - (X_d - X_d) i_d+ E_f) \n    fracd e_ddt = frac1T_q (- e_d + (X_q - X_q) i_q)  \n\nThe IEEEG1 Governor Model applies the following equations:\n\n    dx_1 = K cdot left(frac-1T_1 cdot x_1 + left(1 - fracT_2T_1right) cdot omegaright) text  Block Input \n    dP = left(frac1T_1right) cdot x_1 + left(fracT_2T_1right) cdot omega \n    y = left(frac1T_3right) cdot (P_0 - P - P_m) text   Block Output \n\nLimiting the valve rate of change:\n\n    y_temp = begincases\n            P_up  textif  y  P_up \n            P_down  textif  y  P_down \n            y  textelse\n        endcases\n    dz = y_temp\n\nLimiting the power imposed by the valve or gate control:\n\n    dP_m = begincases\n                (1 - P_max) cdot dP_m  textif  z  P_max \n                (1 - P_min) cdot dP_m  textif  z  P_min \n                y_temp  textelse\n            endcases\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.PQAlgebraic","page":"Node Types","title":"PowerDynamics.PQAlgebraic","text":"    PQAlgebraic(; P,Q)\n\nA node type that locally fixes the active (P) and reactive power (Q) output of the node.\n\nKeyword Arguments\n\nP: active power set point\nQ: reactive power set point\n\nMathematical Representation\n\nUsing PQAlgebraic for node a applies the equation\n\n0 = (P_a + jQ_a) - u_a cdot i_a^*\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.PVAlgebraic","page":"Node Types","title":"PowerDynamics.PVAlgebraic","text":"PVAlgebraic(;P,V)\n\nA node type that locally fixes the active power (P) and the voltage magnitude (V) of the node.\n\nKeyword Arguments\n\nP: the active (real) power output\nV: voltage magnitude\n\nMathematical Representation\n\nUsing PVAlgebraic for node a applies the equations\n\n0 = P_a - Releft(u_a cdot i_a^*right) \n0 = V_a - leftu_aright\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.PVInverterWithFrequencyControl","page":"Node Types","title":"PowerDynamics.PVInverterWithFrequencyControl","text":"PVInverterWithFrequencyControl(;I_n,k_PLL,f,f_s,T_m,k_P,τ_ω)\n\nThis implementation of a generic inverter model is built with standard components according to the report on \"Modelling of Inverter-Based Generation for Power System Dynamic Studies\" of the joint CIGRE working group.\n\nAdditionally to u, the global network-side voltage, it has the internal dynamic variables:\n\nθ_PLL: phase determined by the PLL\nv_xm: x-component of measured grid-side voltage\nv_ym: y-component of measured grid-side voltage\nP: power infeed of power plant\nω: frequeny deviation in rad/s.\n\nKeyword arguments are:\n\nI_n: the nominal current of the PV plant\nk_PLL: the PLL constant,\nf: the nominal frequency (50Hz usually)\nf_s: the set point at which droop control is triggered\nT_m: the time constant of the low pass filter for measuring the voltage locally at the inverter\nk_P: the droop control constant\nτ_ω time constant of the frequeny filter\n\nMathematical Representation\n\nUsing PVInverterWithFrequencyControl applies the equations\n\n    v_x = Re(u)\n    v_y = Im(u)\n\nThe network-side power is\n\np = Re(u cdot i^*)\n\nThe nominal current of the PV inverter, I_n, is completely active current (we do not consider voltage regulation so far):\n\n    I_Pmax = I_n \n    I_Qmax = 0\n\n    fracdv_xmdt = 1T_m(v_x-v_xm)\n    fracdv_ymdt = 1T_m(v_y-v_ym)\n\nSince PowerDynamics is working with phasor units, this model has two d-q-systems (for the power plant and for the grid), I_pv_d and I_qv_q are the local coordinates and i_xv_x and i_yv_y are the global (grid) coordinates.\n\n    u_dq = (v_xm+j v_ym)e^-jtheta_PLL\n    v_d = Re(u_dq)\n    v_q = Im(u_dq)\n\nThe local coordinates are chosen such that v_q=0:\n\n    dottheta_PLL = v_q(k_PLL)\n\nThe frequency deviation, dottheta_PLL,  is obtained thanks to the PLL controller of the units. Therefore, the measured frequency in Hz is given by\n\n        f_m = (1+dottheta_PLL)f\n\nAn additional filter is added to avoid a too fast PV reaction leading to unwanted oscillations of the active current during a short-term fault:\n\n    fracdomegadt = 1tau_omega(-omega + dottheta_PLLcdot2pi f)\n\nWith the active power determined by the droop control the current I_Pequals:\n\n    I_P=Pv_d\n\nImplementing the frequency dead band for overfrequnency control with:\n\n    fracdPdt =-k_P cdot domega cdot P_ext   text if  f_mf_s\n    fracdPdt  = 0   text else\n\nwhere f_s is the frequency at which the active power output starts decreasing and k_P is the droop control constant (in percentage of the rated power P_ext):\n\n    P_ext = Re(I_Pmaxcdot(v_d+jv_q))= I_N v_d\n\n    0cdot dotu =i - (I_P+ j I_Q)e^jtheta_PLL\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.RLCLoad","page":"Node Types","title":"PowerDynamics.RLCLoad","text":"RLCLoad(R,L,C)\n\nEXPERIMENTAL A node type that represents the RLC load model according to \"Power Systems Electromagnetic Transients Simulation\", Neville Watson and Jos Arrillaga, IET 2007, p.59, eq. (3.47)\n\nKeyword Arguments\n\nR: resistance\nL: inductance\nC: capacitance\n\nMathematical Representation\n\n\tdfracdu_Cdt = frac1Ci_L(t)\n    dfracdi_Ldt = -fracRL i_L(t)+frac1L u(t)\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.SlackAlgebraic","page":"Node Types","title":"PowerDynamics.SlackAlgebraic","text":"SlackAlgebraic(;U)\n\nA node type that locally fixes the complex voltage (U) of the node.\n\nAs the complex voltage can be represented as U=Ve^iphi, this is equivlant to fixing the voltage magnitude V and the angle phi.\n\nKeyword Arguments\n\nU: the complex voltage\n\nMathematical Representation\n\nUsing SlackAlgebraic for node a applies the equation\n\n0 = U_a - u_a\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.SwingEq","page":"Node Types","title":"PowerDynamics.SwingEq","text":"SwingEq(;H, P, D, Ω)\n\nA node type that applies the swing equation to the frequency/angle dynamics and keeps the voltage magnitude as is. In the following, we followed the implementation of the 2nd-order Synchronous Machine Model according to  Sauer et. al. \"Power system dynamics and stability\", 1998.\n\nAdditionally to u, it has the internal dynamic variable omega representing the frequency of the rotator relative to the grid frequency Omega, i.e. the real frequency omega_r of the rotator is given as omega_r = Omega + omega.\n\nKeyword Arguments\n\nH: inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)\nP: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]\nD: damping coefficient, (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal Dω)\nΩ: rated frequency in [1/s] of the power grid, often 2pi50Hz\n\nMathematical Representation\n\nUsing SwingEq for node a applies the equations\n\nfracdu_adt = j omega_a u_a \nfrac2HOmegafracdomega_adt = P_a - D_aomega_a - Releft(u_a cdot i_a^*right)\n\nwhich is equivalent to\n\nfracdphi_adt = omega_a \nv = v(t=0) = textconst \nfrac2HOmegafracdomega_adt = P_a - D_aomega_a - Releft(u_a cdot i_a^*right)\n\nwhere H = frac12fracJOmega^2S_b for a two-pole machine accoding to Sauer et. al. eq. (3.60) on p. 33. S_b is the rated three-phase MVA of the power system.\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.SwingEqLVS","page":"Node Types","title":"PowerDynamics.SwingEqLVS","text":"SwingEqLVS(;H, P, D, Ω, Γ, V)\n\nA node type that applies the swing equation to the frequency/angle dynamics and has a linear voltage stability (LVS) term.\n\nAdditionally to u, it has the internal dynamic variable omega representing the frequency of the rotator relative to the grid frequency Omega, i.e. the real frequency omega_r of the rotator is given as omega_r = Omega + omega.\n\nKeyword Arguments\n\nH: inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)\nP: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]\nD: damping coefficient, (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal Dω)\nΩ: rated frequency in [1/s] of the power grid, often 2pi50Hz\nΓ: voltage stability coefficient\nV: set voltage, usually 1\n\nMathematical Representation\n\nUsing SwingEq for node a applies the equations\n\nfracdu_adt = j omega_a u_a - fracuu Γ_a  (v_a - V_a) \nfrac2HOmegafracdomega_adt = P_a - D_aomega_a - Releft(u_a cdot i_a^*right)\n\nwhich is equivalent to\n\nfracdphi_adt = omega_a \nfracdv_adt = - Γ_a  (v_a - V_a) \nfrac2HOmegafracdomega_adt = P_a - D_aomega_a - Releft(u_a cdot i_a^*right)\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.VSIMinimal","page":"Node Types","title":"PowerDynamics.VSIMinimal","text":"VSIMinimal(;τ_P,τ_Q,K_P,K_Q,E_r,P,Q)\n\nA node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics. Implemented according to  Schiffer et. al., \"Conditions for stability of droop-controlled inverter-based microgrids\", Automatica, 2014.\n\nVSIMinimal models an inverters as AC voltage source which means the amplitude and frequency can defined by the designer (often called grid-forming inverter mode). The frequency and voltage regulation is assumed to be instantaneous. In addition simple proportional controllers are implemented for frequency and voltage such that the frequency ω and voltage amplitudes v of the inverters are modified depending on the deviations (with respect to a desired value) of the active and reactive powers, respectively. it is assumed that active and reactive power are measured via low pass filters with time constant τ_P and τ_Q, respectively. VSIMinimal can be derived from VSIVoltagePT1 by assuming an instantaneous voltage regulation without delay.\n\nAdditionally to u, it has the internal dynamic variable ω representing the frequency of the inverter frequency relative to the grid frequency Ω=2π50Hz, i.e. the real frequency ω_r of the inverter frequency is given as ω_r = Ω + ω.\n\nKeyword Arguments\n\nτ_p: time constant active power measurement\nτ_Q: time constant reactive power measurement\nK_P: droop constant frequency droop\nK_Q: droop constant voltage droop\nV_r: reference/ desired voltage\nP: active (real) power infeed\nQ: reactive (imag) power infeed\n\nMathematical Representation\n\nUsing VSIMinimal for node a (according to J. Schiffer et. al., eq. (7)) gives the equations\n\ndotphi_a=omega_a\n dotomega_a=frac1tau_Pa-omega_a-K_Pa (Releft(u_a cdot i_a^*right)-P_a)\ntau_Qdotv_a=-v_a+V_r-K_Qa (Imleft(u_a cdot i_a^*right)-Q_a)\n dotu_a=dotv_ae^jphi+jomega_a u_a\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.VSIVoltagePT1","page":"Node Types","title":"PowerDynamics.VSIVoltagePT1","text":"VSIVoltagePT1(;τ_v,τ_P,τ_Q,K_P,K_Q,E_r,P,Q)\n\nA node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics. Implemented according to  Schiffer et. al., \"Conditions for stability of droop-controlled inverter-based microgrids\", Automatica, 2014.\n\nVSIVoltagePT1 models an inverters as AC voltage source which means the amplitude and frequency can defined by the designer (often called grid-forming inverter mode). The frequency regulation is assumed to be instantaneous, but the voltage control happens with a delay τ_v that is represented by a first order filter. In addition simple proportional controllers are implemented for frequency and voltage such that the frequency ω and voltage amplitudes v of the inverters are modified depending on the deviations (with respect to a desired value) of the active and reactive powers, respectively. ift is assumed that active and reactive power are measured via low pass fileters with time constant τ_P and τ_Q, respectively.\n\nHence, additionally to u, it has the internal dynamic variables\n\nω representing the frequency of the inverter relative to the grid frequency Ω=2π50Hz, i.e. the real frequency ω_r of the inverter is given as ω_r = Ω + ω.\nq_m is the measured reactive power at the grid connection point.\n\nKeyword Arguments\n\nτ_v: time constant voltage control delay\nτ_P: time constant active power measurement\nτ_Q: time constant reactive power measurement\nK_P: droop constant frequency droop\nK_Q: droop constant voltage droop\nV_r: reference/ desired voltage\nP: active (real) power infeed\nQ: reactive (imag) power infeed\n\nMathematical Representation\n\nUsing VSIVoltagePT1 for node a (according to J. Schiffer et. al., eq. (6)) gives the equations\n\ndotphi_a=omega_a\n dotomega_a=frac1tau_Pa-omega_a-K_Pa (Releft(u_a cdot i_a^*right)-P_refa)\n tau_vdotv_a=-v_a+V_ref-K_Qa(q_ma-Q_refa)\n tau_Q dotq_ma=-q_ma+Imleft(u_a cdot i_a^*right)\n dotu_a=dotv_ae^jphi+jomega_a u_a\n\nIn general τ_V  τ_P, assuming τ_V = 0 would then lead to VSIMinimal.\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.VoltageDependentLoad","page":"Node Types","title":"PowerDynamics.VoltageDependentLoad","text":"    VoltageDependentLoad(;P, Q, U, A, B)\n\nA node type that locally fixes the active (P) and reactive power (Q) output of the node.\n\nKeyword Arguments\n\nP: active power demand\nQ: reactive power demand\nU : the voltage set point\nA : relative share of quadratic voltage dependence \nB : relative share of linear voltage dependence \n\nMathematical Representation\n\nUsing VoltageDependentLoad for node a applies the equation\n\n0 = S_a ( A cdot (u_aU_a)^2 + B cdot (u_aU_a) + 1 - A - B) - u_a cdot i_a^*\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.WindTurbineGenType4","page":"Node Types","title":"PowerDynamics.WindTurbineGenType4","text":"WindTurbineGenType4(;I_n,k_PLL,f,f_s,T_m,k_P,τ_ω)\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.WindTurbineGenType4_RotorControl","page":"Node Types","title":"PowerDynamics.WindTurbineGenType4_RotorControl","text":"WindTurbineGenType4_RotorControl(;T_L,ω_0,T_H,K_ω,K_PPLL,K_IPLL,Q_ref,C,J,P,ω_rref,u_dcref,K_Q,K_v,K_pv,K_iv,K_ptrq,K_itrq) begin\n\n\n\n","category":"type"},{"location":"node_types/#","page":"Node Types","title":"Node Types","text":"CompositeNode","category":"page"},{"location":"node_types/#PowerDynamics.CompositeNode","page":"Node Types","title":"PowerDynamics.CompositeNode","text":"CompositeNode(CurrentNodes)\n\nA composite node consisting of current and power sources provided, as well as up to one optional voltage controling node. This assumes that the current nodes are implemented as\n\ndu = i - I_node\n\nand the power nodes are implemented with\n\ndu = u*conj(i) - P_node\n\nImportant!! The individual nodes are given the current that is arriving from the grid into the bus, not the current they themself inject! Check the definitions of the nodes going into the CompositeType to make sure they have the right dynamics.\n\nExperimental!! This node has not been sufficiently tested for correctness yet. For example the plotting recipe does not work with this node, yet!\n\n\n\n","category":"type"},{"location":"contact/#","page":"Contact","title":"Contact","text":"(Image: Build Status) (Image: Chat on Slack.) (Image: Get your Slack invitation.) (Image: Code on Github.)","category":"page"},{"location":"contact/#Contact-1","page":"Contact","title":"Contact","text":"","category":"section"},{"location":"contact/#","page":"Contact","title":"Contact","text":"In case of questions, please submit an issue on github or ask on our slack channel (get your invitation here).","category":"page"},{"location":"language_conventions/#Language-and-Conventions-1","page":"Language & Conventions","title":"Language & Conventions","text":"","category":"section"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"Generally, variables are miniscule (e.g. u, i, ω) and parameters are capitalized (e.g. H, D, P, Ω). As it is common to use greek letters for modeling equations and Julia supports Unicode, greek letters are used within the Code, e.g. Ω and ω in PowerDynamics.SwingEq. If you don't want to use greek keyboard (which I am currently switching to) you can simply type the latex representating \\Omega and Atom can complete it with Ω using Tab.","category":"page"},{"location":"language_conventions/#List-of-symbols-and-corresponding-names-1","page":"Language & Conventions","title":"List of symbols and corresponding names","text":"","category":"section"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"Symbol (Code) Symbol (Math) Name within PowerDynamics.jl Common alternative names\n  node bus, vertex\n  grid network, power grid, power network\n y_ab = y_ba admittance between nodes a and b \nLY Y^L admittance laplacian (nodal) admittance matrix\nt t time \nim j imaginary element sqrt-1\nu = v \\cdot exp(im*φ) u = v cdot e^jφ complex voltage \nv v voltage magnitude absolute voltage\nφ phi voltage angle \ni_c = i \\cdot exp(im*δ) i_c = i cdot e^jdelta nodal complex current \ni i magnitude of the current \nδ delta angle of the current \ns = p + im*q s = p + jq complex power \np p real power active power\nq q imaginary power reactive power","category":"page"},{"location":"language_conventions/#List-of-modeling-conventions-1","page":"Language & Conventions","title":"List of modeling conventions","text":"","category":"section"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"Counting of nodes starts at 1.\nRanges of nodes are mathematical, i.e. they include the first and the last element. For example sum_k=3^6 sums over 3, 4, 5, and 6.\nFor now, no selfadmittance is allowed, i.e. y_aa = 0 for all nodes a.\nThe admittance laplacian uses the following definition (convention from wikipedia)\nY^L_ab = begincases\n  sum_c y_ac  textif  a=b \n  -y_ab  textotherwise\nendcases\nThe nodal complex current is calculated as\ni_c_a = sum_b LY_ab u_b \nThe complex power is calculated as (with ^* as complex conjugation)\ns_a = u_a cdot i_c_a^*","category":"page"},{"location":"line_types/#Line-Types-1","page":"Line Types","title":"Line Types","text":"","category":"section"},{"location":"line_types/#","page":"Line Types","title":"Line Types","text":"The currently implemented line types are","category":"page"},{"location":"line_types/#","page":"Line Types","title":"Line Types","text":"using InteractiveUtils, PowerDynamics, Markdown\nlinetypes = subtypes(PowerDynamics.AbstractLine)\njoin([\"* [`$n`](@ref PowerDynamics.$n)\" for n in linetypes], \"\\n\") |> Markdown.parse","category":"page"},{"location":"line_types/#Detailed-Line-Type-Documentation-1","page":"Line Types","title":"Detailed Line Type Documentation","text":"","category":"section"},{"location":"line_types/#","page":"Line Types","title":"Line Types","text":"Modules = [PowerDynamics]\nFilter = t -> typeof(t) === DataType && t <: PowerDynamics.AbstractLine","category":"page"},{"location":"line_types/#PowerDynamics.PiModelLine","page":"Line Types","title":"PowerDynamics.PiModelLine","text":"    PiModelLine(from, to, y, y_shunt_km, y_shunt_mk)\n\nA line modelled according to the PI-Model.\n\nSee also the Chapter 2 in   Göran Andersson, Power System Analysis, Lecture 227-0526-00, ITET ETH Zurich, 2012\n\nArguments\n\nfrom : node k\nto : node m\ny: admittance of line between k and m\ny_shunt_km: shunt admittance at the end connected to node k\ny_shunt_mk: shunt admittance at the end connected to node m\nt_km: transformer ratio at the end connected to node k\nt_mk: transformer ratio at the end connected to node m\n\nAssumptions:\n\nthe line admittance is symmetric\n\n\n\n\n\n","category":"type"},{"location":"line_types/#PowerDynamics.RLLine","page":"Line Types","title":"PowerDynamics.RLLine","text":"RLLine(; from, to, R, L, ω0)\n\ndynamic line with series resistance R and series inductance L.\n\nWhen setting initial conditions for this line type be aware that every line carries four variables. The first two for the current from source to destination and the second from destination to source. Since isrcdst = - idstsrc, the inital condtions need to be chosen as negatives of each other as well, i.e. ic[1:2] == -ic[3:4].\n\nKeyword Arguments\n\nfrom: start node of the line\nto: end node of the line\nR: series resistance R\nL: series inductance L\nω0: rated frequency in [rad/s] of the power grid, often 2π50Hz\n\nMathematical Representation\n\nUsing RLLine for the line from–to applies Eqn. (2) from Brouillon, J. S., Colombino, M., Groß, D., & Dörfler, F. (2018). The effect of transmission-line dynamics on a globally synchronizing controller for power inverters. In 2018 European Control Conference (ECC) (pp. 2242-2247). IEEE.\n\n\n\n\n\n","category":"type"},{"location":"line_types/#PowerDynamics.StaticLine","page":"Line Types","title":"PowerDynamics.StaticLine","text":"    StaticLine(from, to, Y)\n\nA static model that represents a line with an admittance Y.\n\nArguments\n\nfrom : start node\nto : end node\nY: scalar admittance of line between from and to\n\n\n\n\n\n","category":"type"},{"location":"line_types/#PowerDynamics.Transformer","page":"Line Types","title":"PowerDynamics.Transformer","text":"    Transformer(from, to, y, t_ratio)\n\nassuming an ideal transformer in series with an admittance. The representation uses the Π model.\n\nMathematical Representation\n\nThe voltage transforms as:\n\n    u_to = t_ratio u_from\n\nArguments\n\nfrom : start node\nto : end node\ny: transformer admittance\nt_ratio: transformation ration\n\nAssumptions\n\nThe admittance is here taken to be on the high-voltage side.\n\n\n\n\n\n","category":"type"},{"location":"line_types/#PowerDynamics.AbstractLine","page":"Line Types","title":"PowerDynamics.AbstractLine","text":"Abstract base type for all lines\n\n\n\n\n\n","category":"type"},{"location":"simulations/#Simulations-or-Fault-Scenarios-1","page":"Simulations or Fault Scenarios","title":"Simulations or Fault Scenarios","text":"","category":"section"},{"location":"simulations/#","page":"Simulations or Fault Scenarios","title":"Simulations or Fault Scenarios","text":"After having defined a PowerGrid a simulation can be run.","category":"page"},{"location":"simulations/#","page":"Simulations or Fault Scenarios","title":"Simulations or Fault Scenarios","text":"Currently PowerDynamics supports the following fault/simulation types:","category":"page"},{"location":"simulations/#","page":"Simulations or Fault Scenarios","title":"Simulations or Fault Scenarios","text":"using InteractiveUtils, PowerDynamics, Markdown\nperturbations = [ChangeInitialConditions; subtypes(PowerDynamics.AbstractPerturbation)]\njoin([\"* [`$n`](@ref PowerDynamics.$n)\" for n in perturbations], \"\\n\") |> Markdown.parse","category":"page"},{"location":"simulations/#","page":"Simulations or Fault Scenarios","title":"Simulations or Fault Scenarios","text":"A specific scenario can be simulated for a given powergrid using the simulate function","category":"page"},{"location":"simulations/#","page":"Simulations or Fault Scenarios","title":"Simulations or Fault Scenarios","text":"simulate","category":"page"},{"location":"simulations/#PowerDynamics.simulate","page":"Simulations or Fault Scenarios","title":"PowerDynamics.simulate","text":"simulate(p::ChangeInitialConditions, powergrid, x0; timespan)\n\nSimulates a ChangeInitialConditions\n\n\n\n\n\nsimulate(np::AbstractPerturbation, powergrid, x1, timespan)\n\nSimulates a AbstractPerturbation\n\n\n\n\n\n","category":"function"},{"location":"simulations/#Detailed-Simulation/-Fault-Type-Documentation-1","page":"Simulations or Fault Scenarios","title":"Detailed Simulation/ Fault Type Documentation","text":"","category":"section"},{"location":"simulations/#Change-Initial-Conditions-1","page":"Simulations or Fault Scenarios","title":"Change Initial Conditions","text":"","category":"section"},{"location":"simulations/#","page":"Simulations or Fault Scenarios","title":"Simulations or Fault Scenarios","text":"ChangeInitialConditions","category":"page"},{"location":"simulations/#PowerDynamics.ChangeInitialConditions","page":"Simulations or Fault Scenarios","title":"PowerDynamics.ChangeInitialConditions","text":"ChangeInitialConditions(;node,var,f)\n\nKeyword Arguments\n\nnode: number  of the node\nvar: symbol of the variable to be perturbated\nf: function for mapping the variable x to the perturbated value\n\n\n\n\n\n","category":"type"},{"location":"simulations/#AbstractPertubation-types-1","page":"Simulations or Fault Scenarios","title":"AbstractPertubation types","text":"","category":"section"},{"location":"simulations/#","page":"Simulations or Fault Scenarios","title":"Simulations or Fault Scenarios","text":"Modules = [PowerDynamics]\nFilter = t -> typeof(t) === DataType && t<:PowerDynamics.AbstractPerturbation","category":"page"},{"location":"simulations/#PowerDynamics.AbstractPerturbation","page":"Simulations or Fault Scenarios","title":"PowerDynamics.AbstractPerturbation","text":"AbstractPerturbation(;)\n\nAn AbstractPerturbation can be uses to construct almost any type of perturbation that has a time span of a fault. Perturbations that are of type of AbstractPerturbation can use the same simulate function then. For example implementations of faults as type AbstractPerturbation see e.g. PowerPerturbation.\n\nKeyword Arguments\n\ntspan_fault: number  of the node\n\n\n\n\n\n","category":"type"},{"location":"simulations/#PowerDynamics.LineFailure","page":"Simulations or Fault Scenarios","title":"PowerDynamics.LineFailure","text":"LineFailure(;line_name,tspan_fault)\n\nThe arguments line_name and tspan_fault specify the line that should be disconnected from the grid and the respective fault duration. For a list of lines the line_name is the index and for an OrderedDict it is the key of the line.\n\n\n\n\n\n","category":"type"},{"location":"simulations/#PowerDynamics.NodeParameterChange","page":"Simulations or Fault Scenarios","title":"PowerDynamics.NodeParameterChange","text":"NodeParameterChange(;node, value, tspan_fault, var)\n\nKeyword Arguments\n\nnode: number or name of the node\nvalue: value of power during fault event\ntspan_fault: PowerPerturbation timespan\nvar:  symbol of parameter that is perturbed\n\n\n\n\n\n","category":"type"},{"location":"simulations/#PowerDynamics.NodeShortCircuit","page":"Simulations or Fault Scenarios","title":"PowerDynamics.NodeShortCircuit","text":"    NodeShortCircuit(;node,Y,tspan_fault)\n\nKeyword Arguments\n\nnode: number or name of the node\nY: admittance of the short circuit\ntspan_fault: short circuit timespan\n\nOptional Keyword Arguments\n\nvar: symbol of the shunt admittance, default: :Y_n\n\n\n\n\n\n","category":"type"},{"location":"simulations/#PowerDynamics.PowerPerturbation","page":"Simulations or Fault Scenarios","title":"PowerDynamics.PowerPerturbation","text":"PowerPerturbation(;node_number,fault_power,tspan_fault,var)\n\nKeyword Arguments\n\nnode_number: number or name of the node\nfault_power: value of power during fault event\ntspan_fault: PowerPerturbation timespan\nvar: parameter symbol on the node that represents Power, default is :P\n\n\n\n\n\n","category":"type"},{"location":"simulations/#LineFault-1","page":"Simulations or Fault Scenarios","title":"LineFault","text":"","category":"section"},{"location":"simulations/#","page":"Simulations or Fault Scenarios","title":"Simulations or Fault Scenarios","text":"Deprecated! Use LineFailure instead!","category":"page"},{"location":"simulations/#","page":"Simulations or Fault Scenarios","title":"Simulations or Fault Scenarios","text":"LineFault","category":"page"},{"location":"fullindex/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"fullindex/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"states_solutions/#States,-Solutions-and-Plotting-1","page":"States, Solutions & Plotting","title":"States, Solutions & Plotting","text":"","category":"section"},{"location":"states_solutions/#","page":"States, Solutions & Plotting","title":"States, Solutions & Plotting","text":"In order to properly interact with the state space of the power grid model, we defined two data structures PowerDynamics.State and PowerDynamics.PowerGridSolution.","category":"page"},{"location":"states_solutions/#States-1","page":"States, Solutions & Plotting","title":"States","text":"","category":"section"},{"location":"states_solutions/#","page":"States, Solutions & Plotting","title":"States, Solutions & Plotting","text":"State","category":"page"},{"location":"states_solutions/#PowerDynamics.State","page":"States, Solutions & Plotting","title":"PowerDynamics.State","text":"\n    State(base; t=nothing)\n    State(grid, vec; t=nothing)\n\n\nEncode the information on the value of a state vector at a particular time point.\n\nKeyword Arguments\n\nUse a PowerGrid instance grid and a properly sized   state vector vec to instantiate a State.\n\nIndexing\n\nConcerning the indexing, a State object s basically behaves like a an array. There are plenty of convenient ways to access its contents at a node j by using a particular symbol:\n\ns[j, :u]: complex voltage\ns[j, :v]: voltage magnitude\ns[j, :φ]: voltage angle\ns[j, :i]: complex nodal current\ns[j, :iabs]: nodal current magnitude\ns[j, :δ]: nodal current angle\ns[j, :s]: apparent power\ns[j, :p]: real power\ns[j, :q]: reactive power\n\nCurrently, setting the state value is only implemented for u and v, the other quantities are derived automatically.\n\nYou can access (and set) the k-th variable by calling\n\ns[j, :var, k].\n\nThe variables can be also directly accessed with symbols, i.e.\n\ns[j, :ω]\n\nreturns the frequency ω at node j. To find out the proper symbol, the easiest way is to look into the docs of the corresponding node type, check the output of symbolsof or simply look at the output of println:\n\njulia> symbolsof(SwingEq(H=2, P=3, D=4, Ω=5))\n1-element Array{Symbol,1}:\n :ω\n\njulia> println(SwingEq(H=2, P=3, D=4, Ω=5))\nSwingEq[:ω](H=2, P=3, D=4, Ω=5)\n\n\n\n\n\n","category":"type"},{"location":"states_solutions/#Solutions-and-Plotting-1","page":"States, Solutions & Plotting","title":"Solutions & Plotting","text":"","category":"section"},{"location":"states_solutions/#","page":"States, Solutions & Plotting","title":"States, Solutions & Plotting","text":"PowerGridSolution","category":"page"},{"location":"states_solutions/#PowerDynamics.PowerGridSolution","page":"States, Solutions & Plotting","title":"PowerDynamics.PowerGridSolution","text":"struct PowerGridSolution\n    dqsol::AbstractTimeseriesSolution\n    powergrid::PowerGrid\nend\n\nThe data structure interfacing to the solution of the differential equations of a power grid. Normally, it is not created by hand but return from PowerDynSolve.solve.\n\nAccessing the solution in a similar interface as State.\n\nFor some grid solution sol, one can access the variables as\n\nsol(t, n, s)\n\nwhere t is the time (either float or array), n the node number(s) (either integer, array, range (e.g. 2:3) or colon (:, for all nodes)), and s is the symbol represnting the chosen value. s can be either: :v, :φ, :i, :iabs, :δ, :s, :p, :q, or the symbol of the internal variable of the nodes. The meaning of the symbols derives from the conventions of PowerDynamics.jl. Finally, one can access the a-th internal variable of a node by using sol(t, n, :int, a).\n\nInterfacing the Plots.jl library via plotting recipes, that follow similar instructions as the direct access to the solution.\n\nFor some grid solution sol, one plot variables of the solution asin\n\nusing Plots\nplot(sol, n, s, plots_kwargs...)\n\nwhere n and s are as in the accessing of plots, and plots_kwargs are the keyword arguments for Plots.jl.\n\n\n\n\n\n","category":"type"},{"location":"ARCHITECTURE/#Architecture-Overview-1","page":"Architecture","title":"Architecture Overview","text":"","category":"section"},{"location":"ARCHITECTURE/#","page":"Architecture","title":"Architecture","text":"In the following the architecture of PowerDynamics with its components is explained in more detail.","category":"page"},{"location":"ARCHITECTURE/#Components-of-PowerDynamics-1","page":"Architecture","title":"Components of PowerDynamics","text":"","category":"section"},{"location":"ARCHITECTURE/#","page":"Architecture","title":"Architecture","text":"The main components of PowerDynamics are","category":"page"},{"location":"ARCHITECTURE/#","page":"Architecture","title":"Architecture","text":"nodes\nlines\nPowerGrid\noperationpoint\nfaults\nPowerGridSolutions","category":"page"},{"location":"ARCHITECTURE/#","page":"Architecture","title":"Architecture","text":"For a typical simulation the data flow between some of the components is illustrated in the figure below:","category":"page"},{"location":"ARCHITECTURE/#","page":"Architecture","title":"Architecture","text":"(Image: Data flow diagram for PowerDynamics.jl)","category":"page"},{"location":"ARCHITECTURE/#nodes-1","page":"Architecture","title":"nodes","text":"","category":"section"},{"location":"ARCHITECTURE/#","page":"Architecture","title":"Architecture","text":"The node component includes a library of different standard generators, loads and inverters. The definition of new nodes is simplified with the node macro @DynamicNode.","category":"page"},{"location":"ARCHITECTURE/#lines-1","page":"Architecture","title":"lines","text":"","category":"section"},{"location":"ARCHITECTURE/#","page":"Architecture","title":"Architecture","text":"The line component includes a standard library of different line and transformer types, e.g. a simple admittance line (StaticLine), the PiModelLine and a simple transfomer model based on the Pi Model branch representation.","category":"page"},{"location":"ARCHITECTURE/#PowerGrid-1","page":"Architecture","title":"PowerGrid","text":"","category":"section"},{"location":"ARCHITECTURE/#","page":"Architecture","title":"Architecture","text":"The PowerGrid component is built from nodes and lines. It contains all information about the graph and is used to derive the right-hand-side function with the NetworkDynamics.jl-library. The powergrid can also be parsed from a json-file with read_powergrid.","category":"page"},{"location":"ARCHITECTURE/#operationpoint-1","page":"Architecture","title":"operationpoint","text":"","category":"section"},{"location":"ARCHITECTURE/#","page":"Architecture","title":"Architecture","text":"The operationpoint represents the steady-state solution of the dynamic power system. There are different methods for finding the operation point: rootfind, nlsolve and dynamic. The function find_operationpoint returns the operationpoint which is of type State.","category":"page"},{"location":"ARCHITECTURE/#faults-1","page":"Architecture","title":"faults","text":"","category":"section"},{"location":"ARCHITECTURE/#","page":"Architecture","title":"Architecture","text":"All simulation in PowerDynamics assume some kind of fault scenario. It can be either a change in initial conditions (different from the operation point of the system) at the beginning of a simulation. Or it is a perturbation of node or line paramers for a certain time span tspan_fault that alter the PowerGrid. These can be e.g. a sudden loss of load, PowerPerturbation, or a line failure, LineFailure. The latter faults are all derived from AbstractPerturbation, and all share the same simulate function.","category":"page"},{"location":"ARCHITECTURE/#PowerGridSolution-1","page":"Architecture","title":"PowerGridSolution","text":"","category":"section"},{"location":"ARCHITECTURE/#","page":"Architecture","title":"Architecture","text":"After a simulation in PowerDynamics the solution returned is of type PowerGridSolutions. It allows to access the solution output of the ODE solver in a user friendly manner.","category":"page"},{"location":"#","page":"General","title":"General","text":"(Image: Build Status) (Image: Chat on Slack.) (Image: Get your Slack invitation.) (Image: Code on Github.)","category":"page"},{"location":"#PowerDynamics.jl-Dynamic-Power-System-Analysis-in-Julia-1","page":"General","title":"PowerDynamics.jl - Dynamic Power System Analysis in Julia","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"This package provides all the tools you need to create a dynamic power grid model and analyze it.","category":"page"},{"location":"#","page":"General","title":"General","text":"The source code is licensed under GPLv3 and published on github.","category":"page"},{"location":"#","page":"General","title":"General","text":"These Docs have been built","category":"page"},{"location":"#","page":"General","title":"General","text":"using Dates\nfunction printBuiltTime()\n  println(Dates.format(now(), \"on YYYY-mm-dd at HH:MM\"))\nend","category":"page"},{"location":"#","page":"General","title":"General","text":"printBuiltTime() # hide","category":"page"},{"location":"#Installation-1","page":"General","title":"Installation","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"The installation can be done via the new package manager. Either use","category":"page"},{"location":"#","page":"General","title":"General","text":"]add PowerDynamics","category":"page"},{"location":"#","page":"General","title":"General","text":"or copy","category":"page"},{"location":"#","page":"General","title":"General","text":"using Pkg; Pkg.add(\"PowerDynamics\")","category":"page"},{"location":"#","page":"General","title":"General","text":"Please note that PowerDynamics.jl is a fast developing library whose API is not settled yet. In order to ensure that your old code will still work in the future while using the latest version of PowerDynamics.jl for your new code, we strongly recommend the usage of environments. Please check out this video from the introduction of Pkg3, where environments are introduced, too.","category":"page"},{"location":"#Compatibility-1","page":"General","title":"Compatibility","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"PowerDynamics.jl is written for Julia 1.6 and above. We will quickly switch to new Julia version as they come out, but support older versions and enable long transition periods for users. Julia versions 0.x are not supported.","category":"page"},{"location":"#Usage-1","page":"General","title":"Usage","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Generally, we distinguish three types of user for PowerDynamics.jl:","category":"page"},{"location":"#","page":"General","title":"General","text":"Grid Modeler\nGrid Component Developer\nPowerDynamics.jl Developer","category":"page"},{"location":"#Grid-Modeler-1","page":"General","title":"Grid Modeler","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Your Goal is to use PowerDynamics.jl to model your grid of preference. You don't want to implement new types of nodes.","category":"page"},{"location":"#","page":"General","title":"General","text":"We recommend you to choose your favorite example from PowerDynamicsExamples, read Node Types and try to understand it. That should give you the kickstart you need. If you have any questions, contact us.","category":"page"},{"location":"#Grid-Component-Developer-1","page":"General","title":"Grid Component Developer","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Your Goal is to use PowerDynamics.jl to develop types of nodes, e.g. new control schemes for inverters or new descriptions of synchronous machines.","category":"page"},{"location":"#","page":"General","title":"General","text":"After going through the introduction for a Grid Modeler, we recommend that you read through PowerGrid model and Custom Node Types and try to implement a new node type for an example grid. With that, you should have all the tools you need. If you have any questions, contact us.","category":"page"},{"location":"#PowerDynamics.jl-Developer-1","page":"General","title":"PowerDynamics.jl Developer","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Your Goal is to extend PowerDynamics.jl with new fundamental functionalities.","category":"page"},{"location":"#","page":"General","title":"General","text":"After going throught the introduction for a Grid Modeler and a Grid Component Developer, read through the code where hopefully all of this documentation will helpful for you. Afterwards, it's probably best to open an issue explaining the idea you want to implement and we can discuss how you can transform your idea into a pull request.","category":"page"}]
}
