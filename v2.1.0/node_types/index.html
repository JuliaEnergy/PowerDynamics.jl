<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Node Types · PowerDynamics.jl</title><link rel="canonical" href="https://juliaenergy.github.io/PowerDynamics.jl/stable/node_types/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PowerDynamics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">General</a></li><li><a class="toctext" href="../language_conventions/">Language &amp; Conventions</a></li><li><a class="toctext" href="../node_dynamics_types/">Dynamics Types</a></li><li class="current"><a class="toctext" href>Node Types</a><ul class="internal"><li><a class="toctext" href="#Detailed-Node-Type-Documentation-1">Detailed Node Type Documentation</a></li></ul></li><li><a class="toctext" href="../custom_node_types/">Custom Node Types</a></li><li><a class="toctext" href="../states_solutions/">States, Solutions &amp; Plotting</a></li><li><a class="toctext" href="../error_types/">Error Types</a></li><li><a class="toctext" href="../fullindex/">Index</a></li><li><a class="toctext" href="../contact/">Contact</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Node Types</a></li></ul><a class="edit-page" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/master/docs/src/node_types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Node Types</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Node-Types-1" href="#Node-Types-1">Node Types</a></h1><p>The currently implementes node types are</p><h2><a class="nav-anchor" id="Detailed-Node-Type-Documentation-1" href="#Detailed-Node-Type-Documentation-1">Detailed Node Type Documentation</a></h2><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>PowerDynamics.AbstractNodeParameters</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.CSIMinimal" href="#PowerDynamics.CSIMinimal"><code>PowerDynamics.CSIMinimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">CSIMinimal(;I_r)</code></pre><p>A node type that keeps the current fixed as a desired values <code>I_r</code>.</p><p><code>CSIMinimal</code> models an inverters as an ideal current source. This can be the most simple representation of an inverter in grid-feeding mode, according to Rocabert, Joan, et al. &quot;Control of power converters in AC microgrids.&quot; (2012). Here, additionally to <code>u</code>, there are no internal dynamic variables.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>I_r</code>: reference/ desired current</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>CSIMinimal</code> for node <span>$a$</span> gives:</p><div>\[0 = I_{r,a} - \left\|i_a\right\|\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.ExponentialRecoveryLoad" href="#PowerDynamics.ExponentialRecoveryLoad"><code>PowerDynamics.ExponentialRecoveryLoad</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">ExponentialRecoveryLoad(P0, Q0, Nps, Npt, Nqs, Nqt, Tp, Tq, V0)</code></pre><p>A node type that represents the exponential recovery load model. The exponential recovery load model aims to capture the load restoration characteristics with an exponential recovery process expressed as an input–output relationship between powers (real and reactive) and voltage.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>P0</code>: Active power load demand [pu]</li><li><code>Q0</code>: Reactive power load demand [pu]</li><li><code>Nps</code>: Steady-state load voltage dependence p-axis [pu]</li><li><code>Npt</code>: Transient load voltage dependence p-axis [pu]</li><li><code>Nqs</code>: Steady-state load voltage dependence q-axis [pu]</li><li><code>Nqt</code>: Transient load voltage dependence q-axis [ pu]</li><li><code>Tp</code>: Load recovery constant p-axis [s]</li><li><code>Tq</code>: Load recovery constant q-axis [s]</li><li><code>V0</code>: Reference grid voltage [pu]</li></ul><p><strong>Mathematical Representation</strong></p><div>\[	\dfrac{dx_p}{dt} = \dfrac{1}{T_p}(-x_p + P_0(\dfrac{abs(u)}{V_0})^{N_{ps}} - P_0(\dfrac{abs(u)}{V_0})^{N_{pt}}) \\
    \dfrac{dx_q}{dt} = \dfrac{1}{T_q}(-x_q + Q_0(\dfrac{abs(u)}{V_0})^{N_{qs}} - Q_0(\dfrac{abs(u)}{V_0})^{N_{qt}}) \\
    P = x_p + P_0(\dfrac{abs(u)}{V_0})^{N_{pt}} \\
    Q = x_q - Q_0(\dfrac{abs(u)}{V_0})^{N_{qt}} \\\]</div><p>IEEE TRANSACTIONS ON POWER SYSTEMS, VOL. 21, NO. 3, AUGUST 2006 Measurement-Based Dynamic Load Models: Derivation, Comparison, and Validation Byoung-Kon Choi, Member, IEEE, Hsiao-Dong Chiang, Fellow, IEEE, Yinhong Li, Hua Li, Member, IEEE, Yung-Tien Chen, Der-Hua Huang, and Mark G. Lauby</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.FourthOrderEq" href="#PowerDynamics.FourthOrderEq"><code>PowerDynamics.FourthOrderEq</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">FourthEq(H, P, D, Ω, E_f, T_d_dash ,T_q_dash ,X_q_dash ,X_d_dash,X_d, X_q)</code></pre><p>A node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics, which is implemented according to P. Sauer, &quot;Power System Dynamics and Stability&quot;. For an illustration of a synchronous machine schematic see P. Sauer, Fig. 3.1 on p. 25.</p><p>Usually the swing equation (<code>SwingEq</code>) is used for short time periods to analyze the transient behavior of generators in a power grid, the so-called first swing. The 4th-order model  also takes the back reaction of the power flow onto the voltage into account. This has the effect that the angle of the voltage as seen by the power grid, and the angle of the rotating mass are no longer the same but become dynamically coupled.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variables</p><ul><li><span>$ω$</span> representing the frequency of the rotator relative to the grid frequency <span>$Ω$</span>, i.e. the real frequency <span>$ω_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span> and</li><li><span>$θ$</span> representing the relative angle of the rotor with respect to the voltage angle <span>$ϕ$</span>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: shaft inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)</li><li><code>P</code>: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]</li><li><code>D</code>: damping coefficient (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal <code>Dω</code>)</li><li><code>Ω</code>: rated frequency of the power grid, often 50Hz</li><li><code>T_d_dash</code>: time constant of d-axis, given in [s], see P. Sauer, chapter 3.7, p. 54 for a general explanation on time constants</li><li><code>T_q_dash</code>: time constant of q-axis, given in [s]</li><li><code>X_d_dash</code>: transient reactance of d-axis, given in [pu]</li><li><code>X_q_dash</code>: transient reactance of q-axis, given in [pu]</li><li><code>X_d</code>: reactance of d-, given in [pu]</li><li><code>X_d</code>: reactance of q-axis, given in [pu]</li><li><code>E_f</code>: scaled field voltage, which, if set equal to 1.0 pu, gives 1.0 pu open-circuit terminal voltage. The physical device that provides the value of <code>E_f</code> is called the exciter (according to P. Sauer, p. 65)</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>FourthEq</code> for node <span>$a$</span> applies the equations</p><div>\[    u = -je_c e^{j\theta} = -j(e_d + je_q)e^{j\theta}\\
    e_c= e_d + je_q = jue^{-j\theta}\\
    i  = -ji&#39;e^{j\theta} = -j(i_d+ j i_q )e^{j\theta} = Y^L \cdot u \\
    i_c= i_d + ji_q = jie^{-j\theta}\\
    p = \Re (i^* u)\]</div><p>where complex voltage and current are described in a co-rotating frame with axes labeled d and q.</p><p>The fourth-order equations read (according to P. Sauer, &quot;Power System Dynamics and Stability&quot;, p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)</p><div>\[    \frac{d\theta}{dt} = \omega \\
     \frac{d\omega}{dt} = (P-D\omega - p -(X&#39;_q-X&#39;_d)i_d i_q)Ω_H\\
    \frac{d e_q}{dt} = \frac{1}{T&#39;_d} (- e_q - (X_d - X&#39;_d) i_{d}+ E_f) \\
    \frac{d e_d}{dt} = \frac{1}{T&#39;_q} (- e_d + (X_q - X&#39;_q) i_{q})  \\\]</div><p>The equations for frequency and phase represent energy conservation and phase shift. The dynamic equations for the complex voltage show the relationship between the dynamicy of flux linkages and currents which must reflect a conservative coupling field.</p><p>With the PowerDynamics.jl naming conventions of <span>$i$</span> and <span>$u$</span> they read as</p><div>\[   \dot u = \frac{d}{dt}(-j e_c e^{j\theta})=-j(\dot e_d + j\dot e_q)e^{j\theta} + uj\omega\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.FourthOrderEqGovernorExciterAVR" href="#PowerDynamics.FourthOrderEqGovernorExciterAVR"><code>PowerDynamics.FourthOrderEqGovernorExciterAVR</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">FourthOrderEqGovernorExciterAVR(H, P, D, Ω, T_d_dash ,T_q_dash ,X_q_dash ,X_d_dash,X_d, X_q, T_e, T_a, T_f, K_e, K_a, K_f, V_ref, R_d, T_sv, T_ch)</code></pre><p>A node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics, including an Exciter, Automatic Voltage Regulator and Governor which is implemented according to P. Sauer, &quot;Power System Dynamics and Stability&quot;. For an illustration of a synchronous machine schematic see P. Sauer, Fig. 3.1 on p. 25.</p><p>Exciter and Automatic Voltage Regulator: The equations for the systems that balance the AC synchronous machine voltage level by increasing or decreasing the exciter DC voltage. Note, within this model, the transient reactance in the d-axis of the generator needs to be included into the nodal admittance matrix. As the bus of this generator node type is constructed to be an internal generator bus.</p><p>Governor: The prime mover provides the mechanism for controlling the synchronous machine speed and, hence, terminal voltage frequency.</p><p>Usually the swing equation (<code>SwingEq</code>) is used for short time periods to analyze the transient behavior of generators in a power grid, the so-called first swing. The 4th-order model  also takes the back reaction of the power flow onto the voltage into account. This has the effect that the angle of the voltage as seen by the power grid, and the angle of the rotating mass are no longer the same but become dynamically coupled.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variables</p><ul><li><span>$ω$</span> representing the frequency of the rotator relative to the grid frequency <span>$Ω$</span>, i.e. the real frequency <span>$ω_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span> and</li><li><span>$θ$</span> representing the relative angle of the rotor with respect to the voltage angle <span>$ϕ$</span>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>H</code>: shaft inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)</p></li><li><p><code>P</code>: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]</p></li><li><p><code>D</code>: damping coefficient (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal <code>Dω</code>)</p></li><li><p><code>Ω</code>: rated frequency of the power grid, often 50Hz</p></li><li><p><code>T_d_dash</code>: time constant of d-axis, given in [s], see P. Sauer, chapter 3.7, p. 54 for a general explanation on time constants</p></li><li><p><code>T_q_dash</code>: time constant of q-axis, given in [s]</p></li><li><p><code>X_d_dash</code>: transient reactance of d-axis, given in [pu]</p></li><li><p><code>X_q_dash</code>: transient reactance of q-axis, given in [pu]</p></li><li><p><code>X_d</code>: reactance of d-, given in [pu]</p></li><li><p><code>X_d</code>: reactance of q-axis, given in [pu]</p></li><li><p>&#39;T_e&#39; : Exciter time constant, integration rate associated with exciter control [s]</p></li><li><p>&#39;T_a&#39; : Maximum voltage regulator output [s]</p></li><li><p>&#39;T_f&#39; : Excitation control system stabilizer time constant [s]</p></li><li><p>&#39;K_e&#39; : Exciter constant related to self-excited field [pu]</p></li><li><p>&#39;K_a&#39; : Voltage Regulator gain [pu]</p></li><li><p>&#39;K_f&#39; : Excitation control system stabilizer gains [pu]</p></li><li><p>&#39;V_ref&#39; : Reference voltage for the AVR [pu]</p></li><li><p>&#39;R<em>d&#39; : Speed regulation [2πdroop/ω</em>s]</p></li><li><p>&#39;T_sv&#39; : Steam Valve time constant [s]</p></li><li><p>&#39;T_ch&#39; : Steam Chest time constant [s]</p></li></ul><p><strong>Mathematical Representation Synchronous Machine</strong></p><p>Using <code>FourthEq</code> for node <span>$a$</span> applies the equations</p><div>\[    u = -je_c e^{j\theta} = -j(e_d + je_q)e^{j\theta}\\
    e_c= e_d + je_q = jue^{-j\theta}\\
    i  = -ji&#39;e^{j\theta} = -j(i_d+ j i_q )e^{j\theta} = Y^L \cdot u \\
    i_c= i_d + ji_q = jie^{-j\theta}\\
    p = \Re (i^* u) \\\]</div><p>where complex voltage and current are described in a co-rotating frame with axes labeled d and q.</p><p>The fourth-order equations read (according to P. Sauer, &quot;Power System Dynamics and Stability&quot;, p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)</p><div>\[    \frac{d\theta}{dt} = \omega \\
    \frac{d\omega}{dt} = (P-D\omega - p -(X&#39;_q-X&#39;_d)i_d i_q)Ω_H\\
    \frac{d e_q}{dt} = \frac{1}{T&#39;_d} (- e_q - (X_d - X&#39;_d) i_{d}+ E_f) \\
    \frac{d e_d}{dt} = \frac{1}{T&#39;_q} (- e_d + (X_q - X&#39;_q) i_{q}) \\\]</div><p><strong>Exciter and AVR equations</strong></p><div>\[	u_{terminal} = e&#39;_c - j X&#39;_d i \\
	S_{e}(e_{fd}) = 0.098e^{0.55 e_{fd}} (according to P. Sauer, p. 70) \\
	\dfrac{dR_f}{dt} = \dfrac{1}{T_f} (-R_f + \dfrac{K_f}{T_f} e_f) \\
	\dfrac{dv_r}{dt} = \dfrac{1}{T_a} (-v_r + (K_a R_f) -\dfrac{K_a K_f}{T_f}e_{fd} + K_a (V_{ref} - abs(u_{terminal}))) \\
	\dfrac{de_{fd}}{dt} = \dfrac{1}{T_e} (-K_e + S_{e}(e_{fd})e_{fd} + v_r) \\\]</div><p><strong>Governor equations</strong></p><div>\[    \dfrac{dP_m}{dt} = \dfrac{1}{T_{ch}} (-P_m + P_{sv}) \\
    Assumption: T_m = P_m \\
    \dfrac{dP_{sv}}{dt} = \dfrac{1}{T_{sv}} (-P_{sv} + P_c -\dfrac{1}{R_d} (\dfrac{\omega}{\omega_s} - 1)) \\\]</div><p>The equations for frequency and phase represent energy conservation and phase shift. The dynamic equations for the complex voltage show the relationship between the dynamicy of flux linkages and currents which must reflect a conservative coupling field.</p><p>With the PowerDynamics.jl naming conventions of <span>$i$</span> and <span>$u$</span> they read as</p><div>\[   \dot u = \frac{d}{dt}(-j e_c e^{j\theta})=-j(\dot e_d + j\dot e_q)e^{j\theta} + uj\omega \\\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.PQAlgebraic" href="#PowerDynamics.PQAlgebraic"><code>PowerDynamics.PQAlgebraic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">PQAlgebraic(;S)</code></pre><p>A node type that locally fixes the active (<span>$P$</span>) and reactive power (<span>$Q$</span>) output of the node.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>S = P + Q*im</code>: the complex power output</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>PQAlgebraic</code> for node <span>$a$</span> applies the equation</p><div>\[0 = S_a - u_a \cdot i_a^*.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.PVAlgebraic" href="#PowerDynamics.PVAlgebraic"><code>PowerDynamics.PVAlgebraic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">PVAlgebraic(;P,V)</code></pre><p>A node type that locally fixes the active power (<span>$P$</span>) and the voltage magnitude (<span>$V$</span>) of the node.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>P</code>: the active (real) power output</li><li><code>V</code>: voltage magnitude</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>PVAlgebraic</code> for node <span>$a$</span> applies the equations</p><div>\[0 = P_a - \Re\left(u_a \cdot i_a^*\right), \\
0 = V_a - \left\|u_a\right\|.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.PowerGrid" href="#PowerDynamics.PowerGrid"><code>PowerDynamics.PowerGrid</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Encapsulates nodes &amp; lines of the power grid and a graph connecting both.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/ce4c84337a369417a9e1f427637179b1e5d3a58b/src/common/PowerGrid.jl#L4-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.SlackAlgebraic" href="#PowerDynamics.SlackAlgebraic"><code>PowerDynamics.SlackAlgebraic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">SlackAlgebraic(;U)</code></pre><p>A node type that locally fixes the complex voltage (<span>$U$</span>) of the node.</p><p>As the complex voltage can be represented as <span>$U=Ve^{i\phi}$</span>, this is equivlant to fixing the voltage magnitude <span>$V$</span> and the angle <span>$\phi$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>U</code>: the complex voltage</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>SlackAlgebraic</code> for node <span>$a$</span> applies the equation</p><div>\[0 = U_a - u_a.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.SwingEq" href="#PowerDynamics.SwingEq"><code>PowerDynamics.SwingEq</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">SwingEq(;H, P, D, Ω)</code></pre><p>A node type that applies the swing equation to the frequency/angle dynamics and keeps the voltage magnitude as is.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: inertia</li><li><code>P</code>: active (real) power output</li><li><code>D</code>: damping coefficient</li><li><code>Ω</code>: rated frequency of the power grid, often 50Hz</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>SwingEq</code> for node <span>$a$</span> applies the equations</p><div>\[\frac{du_a}{dt} = i u_a  \omega_a, \\
\frac{H}{2\pi\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div><p>which is equivalent to</p><div>\[\frac{d\phi_a}{dt} = \omega, \\
v = v(t=0) = \text{const.} \\
\frac{H}{2\pi\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.SwingEqLVS" href="#PowerDynamics.SwingEqLVS"><code>PowerDynamics.SwingEqLVS</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">SwingEqLVS(;H, P, D, Ω, Γ, V)</code></pre><p>A node type that applies the swing equation to the frequency/angle dynamics and has a linear voltage stability (LVS) term.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: inertia</li><li><code>P</code>: active (real) power output</li><li><code>D</code>: damping coefficient</li><li><code>Ω</code>: rated frequency of the power grid, often 50Hz</li><li><code>Γ</code>: voltage stability coefficient</li><li><code>V</code>: set voltage, usually <code>1</code></li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>SwingEq</code> for node <span>$a$</span> applies the equations</p><div>\[\frac{du_a}{dt} = i u_a \omega - \frac{u}{\|u\|} Γ_a  (v_a - V_a), \\
\frac{H}{2\pi\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div><p>which is equivalent to</p><div>\[\frac{d\phi_a}{dt} = \omega_a, \\
\frac{dv_a}{dt} = - Γ_a  (v_a - V_a) \\
\frac{H}{2\pi\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.VSIMinimal" href="#PowerDynamics.VSIMinimal"><code>PowerDynamics.VSIMinimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">VSIMinimal(;τ_P,τ_Q,K_P,K_Q,E_r,P,Q)</code></pre><p>A node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics.</p><p><code>VSIMinimal</code> models an inverters as AC voltage source which means the amplitude and frequency can defined by the designer (often called grid-forming inverter mode). The frequency and voltage regulation is assumed to be instantaneous. In addition simple proportional controllers are implemented for frequency and voltage such that the frequency <code>ω</code> and voltage amplitudes <code>v</code> of the inverters are modified depending on the deviations (with respect to a desired value) of the active and reactive powers, respectively. ift is assumed that active and reactive power are measured via low pass fileters with time constant <code>τ_P</code> and <code>τ_Q</code>, respectively. <code>VSIMinimal</code> can be derived from <code>VSIVoltagePT1</code> by assuming an instantaneous voltage regulation without delay.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$ω$</span> representing the frequency of the rotator relative to the grid frequency <span>$Ω$</span>, i.e. the real frequency <span>$ω_r$</span> of the rotator is given as <span>$ω_r = Ω + ω$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>τ_p</code>: time constant active power measurement</li><li><code>τ_Q</code>: time constant reactive power measurement</li><li><code>K_P</code>: droop constant frequency droop</li><li><code>K_Q</code>: droop constant voltage droop</li><li><code>V_r</code>: reference/ desired voltage</li><li><code>P</code>: active (real) power infeed</li><li><code>Q</code>: reactive (imag) power infeed</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>VSIMinimal</code> for node <span>$a$</span> (according to J. Schiffer et. al., eq. (7)) gives the equations</p><div>\[\dot{\phi}_a=\omega_a\\
 \dot{\omega}_a=\frac{1}{\tau_{P,a}}[-\omega_a-K_{P,a} (\Re\left(u_a \cdot i_a^*\right)-P_{a})]\\
\tau_Q\dot{v}_a=-v_a+V_{r}-K_{Q,a} (\Im\left(u_a \cdot i_a^*\right)-Q_{a})\\
 \dot{u}_a=\dot{v_a}e^{j\phi}+j\omega_a u_a\]</div><p>```</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.VSIVoltagePT1" href="#PowerDynamics.VSIVoltagePT1"><code>PowerDynamics.VSIVoltagePT1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">VSIVoltagePT1(;τ_v,τ_P,τ_Q,K_P,K_Q,E_r,P,Q)</code></pre><p>A node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics.</p><p><code>VSIVoltagePT1</code> models an inverters as AC voltage source which means the amplitude and frequency can defined by the designer (often called grid-forming inverter mode). The frequency regulation is assumed to be instantaneous, but the voltage control happens with a delay <code>τ_v</code> that is represented by a first order filter. In addition simple proportional controllers are implemented for frequency and voltage such that the frequency <code>ω</code> and voltage amplitudes <code>v</code> of the inverters are modified depending on the deviations (with respect to a desired value) of the active and reactive powers, respectively. ift is assumed that active and reactive power are measured via low pass fileters with time constant <code>τ_P</code> and <code>τ_Q</code>, respectively.</p><p>Hence, additionally to <code>u</code>, it has the internal dynamic variables</p><ul><li><code>ω</code> representing the frequency of the rotator relative to the grid frequency <span>$Ω$</span>, i.e. the real frequency <span>$ω_r$</span> of the rotator is given as <span>$ω_r = Ω + ω$</span>.</li><li><code>q_m</code> is the measured reactive power at the grid connection point.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>τ_v</code>: time constant voltage control delay</li><li><code>τ_P</code>: time constant active power measurement</li><li><code>τ_Q</code>: time constant reactive power measurement</li><li><code>K_P</code>: droop constant frequency droop</li><li><code>K_Q</code>: droop constant voltage droop</li><li><code>V_r</code>: reference/ desired voltage</li><li><code>P</code>: active (real) power infeed</li><li><code>Q</code>: reactive (imag) power infeed</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>VSIVoltagePT1</code> for node <span>$a$</span> (according to J. Schiffer et. al., eq. (6)) gives the equations</p><div>\[\dot{\phi}_a=\omega_a\\
 \dot{\omega}_a=\frac{1}{\tau_{P,a}}[-\omega_a-K_{P,a} (\Re\left(u_a \cdot i_a^*\right)-P_{ref,a})]\\
 \tau_v\dot{v}_{a}=-v_a+V_{ref}-K_{Q,a}(q_{m,a}-Q_{ref,a})\\
 \tau_Q \dot{q}_{m,a}=-q_{m,a}+\Im\left(u_a \cdot i_a^*\right)\\
 \dot{u}_a=\dot{v_a}e^{j\phi}+j\omega_a u_a\\\]</div><p>In general <span>$τ_V ≪ τ_P$</span>, assuming <span>$τ_V = 0$</span> would then lead to <code>VSIMinimal</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.OperationPointError" href="#PowerDynamics.OperationPointError"><code>PowerDynamics.OperationPointError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Error to be thrown if something goes wrong during the operation point search.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/ce4c84337a369417a9e1f427637179b1e5d3a58b/src/common/Errors.jl#L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.PowerGridSolution" href="#PowerDynamics.PowerGridSolution"><code>PowerDynamics.PowerGridSolution</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct PowerGridSolution
    dqsol::AbstractTimeseriesSolution
    powergrid::PowerGrid
end</code></pre><p>The data structure interfacing to the solution of the differntial equations of a power grid. Normally, it is not created by hand but return from <code>PowerDynSolve.solve</code>.</p><p><strong>Accessing the solution in a similar interface as <a href="../states_solutions/#PowerDynamics.State"><code>State</code></a>.</strong></p><p>For some grid solution <code>sol</code>, one can access the variables as</p><pre><code class="language-julia">sol(t, n, s)</code></pre><p>where <code>t</code> is the time (either float or array), <code>n</code> the node number(s) (either integer, array, range (e.g. 2:3) or colon (:, for all nodes)), and <code>s</code> is the symbol represnting the chosen value. <code>s</code> can be either: <code>:v</code>, <code>:φ</code>, <code>:i</code>, <code>:iabs</code>, <code>:δ</code>, <code>:s</code>, <code>:p</code>, <code>:q</code>, or the symbol of the internal variable of the nodes. The meaning of the symbols derives from the conventions of PowerDynamics.jl. Finally, one can access the <code>a</code>-th internal variable of a node by using <code>sol(t, n, :int, a)</code>.</p><p><strong>Interfacing the Plots.jl library via plotting recipes, that follow similar instructions as the direct access to the solution.</strong></p><p>For some grid solution <code>sol</code>, one plot variables of the solution asin</p><pre><code class="language-julia">using Plots
plot(sol, n, s, plots_kwargs...)</code></pre><p>where <code>n</code> and <code>s</code> are as in the accessing of plots, and <code>plots_kwargs</code> are the keyword arguments for Plots.jl.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/ce4c84337a369417a9e1f427637179b1e5d3a58b/src/simulations/PowerGridSolutions.jl#L7-L32">source</a></section><footer><hr/><a class="previous" href="../node_dynamics_types/"><span class="direction">Previous</span><span class="title">Dynamics Types</span></a><a class="next" href="../custom_node_types/"><span class="direction">Next</span><span class="title">Custom Node Types</span></a></footer></article></body></html>
