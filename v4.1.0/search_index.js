var documenterSearchIndex = {"docs":
[{"location":"networkdynamics_forward/","page":"🔗 NetworkDynamics.jl Docs","title":"🔗 NetworkDynamics.jl Docs","text":"    <meta http-equiv=\"refresh\" content=\"0; url=https://juliadynamics.github.io/NetworkDynamics.jl/stable/\">\n    <script type=\"text/javascript\">\n        window.location.href = \"https://juliadynamics.github.io/NetworkDynamics.jl/stable/\"\n    </script>\n    If you are not redirected automatically, follow this <a href='https://juliadynamics.github.io/NetworkDynamics.jl/stable/'>link to the documentation of NetworkDynamics.jl</a>.","category":"page"},{"location":"generated/custom_line/#custom-line","page":"Custom Transmission Line","title":"Tutorial on custom Transmission Line Models","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"In this tutorial we'll implement a custom transmission line model:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"we start by defining a PI-branch component with optional fault admittance,\nwe combine two PI-branch components into one MTKLine, to essentially model a dual-branch transmission line.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"To make it more interesting, we add protection logic to the branches:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"each branch continuously checks the current magnitude against a limit,\nif the current exceeds the limit, the branch is switched off after a delay time.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"This script can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"using PowerDynamics\nusing ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\nusing NetworkDynamics\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\nusing Graphs","category":"page"},{"location":"generated/custom_line/#Basic-PI-Branch-Model","page":"Custom Transmission Line","title":"Basic PI-Branch Model","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We start by defining a basic PI-branch model, which is similar to the one in PiLine_fault.jl as an MTKModel. This model should fulfill the Branch Interface, i.e. it needs to have two Terminal, one called :src the other called :dst:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"      ┌───────────┐\n(src) │           │ (dst)\n  o←──┤  Branch   ├──→o\n      │           │\n      └───────────┘","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The PI-branch we want to describe looks like this. We have:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"two terminals :src and :dst with their\nvoltages V_mathrmsrc and V_mathrmdst,\ncurrents i_mathrmsrc and i_mathrmdst,\ntwo shunt admittances Y_mathrmsrc and Y_mathrmdst,\nan impedance Z, which is split into two parts Z_a and Z_b by the fault position mathrmpos.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"              i_src  V₁   i_a   Vₘ   i_b   V₂  i_dst\n     V_src o────←────o───Z_a─→──o───Z_b─→──o────→────o V_dst\n              r_src  │          │          │   r_dst\n                     ↓ i₁       ↓ i_f   i₂ ↓\n                     ┴          ┴          ┴\nY_src = G_src+jB_src ┬          ┬ Y_f      ┬  Y_dst = G_dst+jB_dst\n                     │          │          │\n                     ⏚          ⏚          ⏚\n                   (fault enabled by breaker)","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The fault admittance Y_f = G_f + jB_f can represent any fault impedance.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"To model this, we introduce the internal voltages V_1, V_2 and V_mathrmm. We consider the equations of the PI-branch in quasi-static-state. Therefore, we can use complex variables to describe the voltages and the currents. What we need in the end are equations for the currents at the terminals, i.e. i_mathrmsrc and i_mathrmdst as a function of all the parameters and the given node voltages. Lets start writing down the equations:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"First, we \"split\" the impedance Z into two parts Z_a and Z_b:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"beginaligned\nZ_mathrma = Z  mathrmpos\nZ_mathrmb = Z  (1-mathrmpos)\nendaligned","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Next, we can define the internal voltages V_1 and V_2 in terms of the terminal voltages and the transformation ratios:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"beginaligned\nV_1 = r_mathrmsrc  V_mathrmsrc\nV_2 = r_mathrmdst  V_mathrmdst\nendaligned","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Once we have the shunt voltages, we can directly calculate the shunt currents","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"beginaligned\ni_1 = Y_mathrmsrc  V_1\ni_2 = Y_mathrmdst  V_2\nendaligned","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"To calculate the middle voltage V_mathrmm, we need to consider the fault admittance Y_f. The fault admittance is defined as:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Y_f = G_f + jB_f","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The effective fault admittance is controlled by the shortcircuit parameter:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Y_ftexteff = mathrmshortcircuit cdot Y_f","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"When the fault is active, we apply Kirchhoff's current law at the middle node: i_mathrma = i_mathrmb + i_f, which leads to the middle voltage:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"V_mathrmm = fracV_1  (1-mathrmpos) + V_2  mathrmpos1 + Y_ftexteff  Z  mathrmpos  (1-mathrmpos)","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Once we have the middle voltage defined, we can calculate the currents i_mathrma, i_mathrmb, and i_f:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"beginaligned\ni_mathrma = fracV_1 - V_mathrmmZ_a\ni_mathrmb = fracV_mathrmm - V_2Z_b\ni_f = Y_ftexteff  V_mathrmm\nendaligned","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Finally, we can calculate the terminal currents using Kirchhoff law and the transformation ratios:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"beginaligned\ni_mathrmsrc = (-i_mathrma - i_1)  r_mathrmsrc\ni_mathrmdst = (i_mathrmb - i_2)  r_mathrmdst\nendaligned","category":"page"},{"location":"generated/custom_line/#Implement-the-CustomPiBranch-MTKModel","page":"Custom Transmission Line","title":"Implement the CustomPiBranch MTKModel","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"<details class=\"admonition is-details\">\n<summary class=\"admonition-header\">Excursion: Complex Variables in MTK Models</summary>\n<div class=\"admonition-body\">","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"warning: Complex variables are not supported in MTK Models (at least not in PowerDynamics.jl)\nIn the end, all parameters and variables of NetworkDynamic models are real-valued, therefore, we cannot use complex parameters or states in our MTK Models.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"However, there is a \"hack\" to prevent this issue. Lets say we want to model the complex equation","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"U = Z cdot I","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We could expand everything in real and imaginary parts and rewrite the equations. However, we can also use ModelingToolkits capability to have complex terms even without having complex variables.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"@variables u_r u_i i_r i_i\n@parameters R, X\nIc = i_r + im * i_i","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Z = R + im * X","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Here, Ic and Z are not a symbolic variables, they are julia variables which points to a complex term/expression.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Using Symboics/ModelingToolkit, we can also multiply complex terms:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Uc = Z * Ic","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"By applying real and imag to the complex term, we can extract the real and imaginary parts to form separate equations for real and imaginary part:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"eqs = [\n    u_r ~ real(Uc),\n    u_i ~ imag(Uc)\n]","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"This trick can be used inside @mtkmodel as well, by just defining those complex terms in a begin...end block.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"</div>\n</details>","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"With the equations and the knowledge on how to use complex terms within MTK Models the definition is relatively straight forward:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"@mtkmodel CustomPiBranch begin\n    @parameters begin\n        R, [description=\"Resistance of branch in pu\"]\n        X, [description=\"Reactance of branch in pu\"]\n        G_src, [description=\"Conductance of src shunt\"]\n        B_src, [description=\"Susceptance of src shunt\"]\n        G_dst, [description=\"Conductance of dst shunt\"]\n        B_dst, [description=\"Susceptance of dst shunt\"]\n        r_src=1, [description=\"src end transformation ratio\"]\n        r_dst=1, [description=\"dst end transformation ratio\"]\n        # fault parameters\n        pos=0.5, [description=\"Fault Position (from src, percent of the line)\"]\n        G_f=1, [description=\"Fault conductance in pu\"]\n        B_f=0, [description=\"Fault susceptance in pu\"]\n        shortcircuit=0, [description=\"shortcircuit on line\"]\n        # parameter to \"switch off\" the line\n        active=1, [description=\"Line active or switched off\"]\n    end\n    @components begin\n        src = Terminal()\n        dst = Terminal()\n    end\n    begin\n        # define complex variables\n        Z = R + im*X\n        Ysrc = G_src + im*B_src\n        Ydst = G_dst + im*B_dst\n        Yf = G_f + im*B_f\n        Vsrc = src.u_r + im*src.u_i\n        Vdst = dst.u_r + im*dst.u_i\n        # define Z_a and Z_b in terms of Z\n        Z_a = Z * pos\n        Z_b = Z * (1-pos)\n        # define internal voltages using the\n        V₁ = r_src * Vsrc\n        V₂ = r_dst * Vdst\n        # currents through the shunt admittances\n        i₁ = Ysrc * V₁\n        i₂ = Ydst * V₂\n        # effective fault admittance (controlled by shortcircuit)\n        Yf_eff = shortcircuit * Yf\n        # middle voltage with fault admittance effect\n        V_m = (V₁*(1-pos) + V₂*pos) / (1 + Yf_eff * Z * pos * (1-pos))\n        # fault current to ground\n        i_f = Yf_eff * V_m\n        # current through the two Z parts\n        i_a = (V₁ - V_m) / Z_a\n        i_b = (V_m - V₂) / Z_b\n        # terminal currents\n        isrc = (-i_a - i₁)*r_src\n        idst = (i_b - i₂)*r_dst\n    end\n    @equations begin\n        src.i_r ~ active * real(isrc)\n        src.i_i ~ active * imag(isrc)\n        dst.i_r ~ active * real(idst)\n        dst.i_i ~ active * imag(idst)\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Additionally to the equations defined above, we multiply the currents by active. This is equivalent of opening two ideal breakers on both ends of the branch when active=false.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Lastly lets ensure that our model satisfies the Branch Interface:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"@named pibranch = CustomPiBranch()\nisbranchmodel(pibranch)","category":"page"},{"location":"generated/custom_line/#Extending-the-model-for-dynamic-over-current-Protection","page":"Custom Transmission Line","title":"Extending the model for dynamic over-current Protection","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Now that we have a working basic PI-branch model, let's extend it with dynamic protection capabilities.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"In order to implement the overcurrent protection, we need to make a plan in terms of callbacks. Callbacks are a neat feature of DifferentialEquations.jl, which allow you to stop the solver under certain conditions and trigger a user-defined affect function to change the state of the system. Their general capability is extended in NetworkDynamics.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We want to implement the following behavior:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Continuously monitor the current magnitude and compare to the maximal current threshold.\nIf the maximum current is reached at time t, mark the line as to be switched off at time t_mathrmcutoff = t + Delta t.\nContinuously monitor time of the simulation and switch off the line at t_mathrmcutoff.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The way to implement this is by introducing 3 new parameters:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"I_max, the maximum current magnitude,\nt_cutoff=Inf, the time when the line should be switched off, which defaults to infinity and\nt_delay, the delay time after which the line should be switched off.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"For robust overcurrent protection, we need to implement multiple complementary callbacks:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"A continuous callback that detects smooth threshold crossings using root-finding\nA discrete callback that catches instantaneous jumps above the threshold\nA cutoff callback that switches off the line at the scheduled time","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"This dual detection approach is necessary because discrete events (like short circuits) can cause the current to jump above the threshold without crossing it smoothly, which continuous callbacks might miss. Both overcurrent callbacks share the same affect function that schedules the line cutoff, while the cutoff callback actually switches off the line.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"note: Note\nNetworkDynamics currently does not support Events defined in MTK models. So we need to split the implementation: The new parameters need to be introduced to the MTKModel (extending CustomPiBranch), the callbacks need to be defined for the compiled VertexModel.","category":"page"},{"location":"generated/custom_line/#Extension-of-the-CustomPiBranch-MTKModel","page":"Custom Transmission Line","title":"Extension of the CustomPiBranch MTKModel","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Let's add the new parameters to the CustomPiBranch model by extending the model. Extend means that we essentially copy-paste the whole model definitions and are able to add new parameters, equations, variables and so on.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We add an additional \"observed\" state I_mag, which always contains the current magnitude at the src or dst terminal (whatever is higher).","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"@mtkmodel ProtectedPiBranch begin\n    @extend CustomPiBranch()\n    @parameters begin\n        I_max=Inf, [description=\"Maximum current magnitude\"]\n        t_cutoff=Inf, [description=\"Time when the line should be switched off\"]\n        t_delay=0.1, [description=\"Delay time after which the line should be switched off\"]\n    end\n    @variables begin\n        I_mag(t), [description=\"Current magnitude at src or dst terminal\"]\n    end\n    @equations begin\n        I_mag ~ max(sqrt(src.i_r^2 + src.i_i^2), sqrt(dst.i_r^2 + dst.i_i^2))\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Once the model is defined, we can go through the building hierarchy outlined in Modeling Concepts. First, we need to form something satisfying the MTKLine Interface.","category":"page"},{"location":"generated/custom_line/#Creating-the-Dual-Branch-MTKLine","page":"Custom Transmission Line","title":"Creating the Dual-Branch MTKLine","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Here we implement our dual-branch architecture by creating two separate ProtectedPiBranch instances and combining them into a single MTKLine. This creates a transmission line model with two parallel branches:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":" ┌───────────────────────────────────────────┐\n │MTKLine   ┌─────────────────────┐          │\n │         ┌┤ ProtectedPiBranch A ├┐         │\n │┌───────┐│└─────────────────────┘│┌───────┐│\n ││LineEnd├o                       o┤LineEnd││\n │└───────┘│┌─────────────────────┐│└───────┘│\n │  :src   └┤ ProtectedPiBranch B ├┘  :dst   │\n │          └─────────────────────┘          │\n └───────────────────────────────────────────┘","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The end terminals of both branches are connected to the same physical line end. However, the branches operate independently:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Each branch monitors its own current magnitude (pibranchA₊I_mag, pibranchB₊I_mag)\nEach has independent protection parameters (I_max, t_delay, t_cutoff)\nEach can be individually switched off (pibranchA₊active, pibranchB₊active)\nElectrical parameters are adjusted so that parallel combination matches the original single-branch behavior","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"branchA = ProtectedPiBranch(; name=:pibranchA)\nbranchB = ProtectedPiBranch(; name=:pibranchB)\nmtkline = MTKLine(branchA, branchB)\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Then, we take the mtkline and put it into a compiled EdgeModel by calling the Line constructor","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"\n       ╔═══════════════════════════════════════════════╗\n       ║ EdgeModel (compiled)                          ║\n       ║ ┌───────────────────────────────────────────┐ ║\n   src ║ │MTKLine   ┌─────────────────────┐          │ ║ dst\nvertex ║ │         ┌┤ ProtectedPiBranch A ├┐         │ ║ vertex\n   u ───→│┌───────┐│└─────────────────────┘│┌───────┐│←─── u\n       ║ ││LineEnd├o                       o┤LineEnd││ ║\n   i ←───│└───────┘│┌─────────────────────┐│└───────┘│───→ i\n       ║ │  :src   └┤ ProtectedPiBranch B ├┘  :dst   │ ║\n       ║ │          └─────────────────────┘          │ ║\n       ║ └───────────────────────────────────────────┘ ║\n       ╚═══════════════════════════════════════════════╝","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"protected_template = Line(mtkline; name=:protected_piline)","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"tip: Reduced complexity of compiled Model\nNote, that the compiled model still has no states, i.e. it directly calculates the terminal currents from the terminal voltages and the parameters. This is a perfect showcase of why equation based modeling matters: we still can access all of the internal variables, like the currents per branch. However those are all just \"observed\" and don't add to the numeric dimensionality of our model. (Even though the complexity of calculating the output currents is slightly higher than that of the simple PI-Line model).","category":"page"},{"location":"generated/custom_line/#Definition-of-the-Callbacks","page":"Custom Transmission Line","title":"Definition of the Callbacks","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We implement the callbacks as outlined in the NetworkDynamic docs on Callbacks.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"For robust overcurrent protection, we need two complementary callbacks:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"A continuous callback that detects smooth threshold crossings using root-finding\nA discrete callback that catches instantaneous jumps above the threshold","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"This dual approach is necessary because discrete events (like short circuits) can cause the current to jump above the threshold without crossing it smoothly, which continuous callbacks might miss.","category":"page"},{"location":"generated/custom_line/#Overcurrent-Detection-Callbacks","page":"Custom Transmission Line","title":"Overcurrent Detection Callbacks","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"For ComponentCondition, we need to specify which symbols to monitor. We've explicitly added I_mag as an observed state to our ProtectedPiBranch model, which contains the maximum current magnitude between the src and dst terminals for each branch.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Since our dual-branch transmission line has two independent branches (:pibranchA and :pibranchB), we define callback functions that take the branch name as a parameter. This allows us to automatically create identical callbacks for both branches without code duplication.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Condition Definitions:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The continuous condition uses root-finding, returning the difference between limit and current magnitude (zero when the limit is reached):","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"function continuous_overcurrent_condition(branchname)\n    I_mag = Symbol(branchname, \"₊\", :I_mag) # pilineX₊I_mag\n    I_max = Symbol(branchname, \"₊\", :I_max) # pilineX₊I_max\n    t_cutoff = Symbol(branchname, \"₊\", :t_cutoff) # pilineX₊t_cutoff\n\n    ComponentCondition([I_mag], [I_max, t_cutoff]) do u, p, t\n        p[t_cutoff] != Inf && return Inf # return Inf if cutoff already scheduled\n        p[I_max] - u[I_mag]\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The discrete condition uses a boolean check that triggers whenever the current exceeds the threshold:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"function discrete_overcurrent_condition(branchname)\n    I_mag = Symbol(branchname, \"₊\", :I_mag) # pilineX₊I_mag\n    I_max = Symbol(branchname, \"₊\", :I_max) # pilineX₊I_max\n    t_cutoff = Symbol(branchname, \"₊\", :t_cutoff) # pilineX₊t_cutoff\n\n    ComponentCondition([I_mag], [I_max, t_cutoff]) do u, p, t\n        p[t_cutoff] != Inf && return false # return false if cutoff already scheduled\n        u[I_mag] ≥ p[I_max]\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Shared Affect Function:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Both callbacks use the same affect function. When triggered, it schedules the line cutoff by setting t_cutoff and tells the integrator to step to that time:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"function overcurrent_affect(branchname)\n    t_cutoff = Symbol(branchname, \"₊\", :t_cutoff) # pilineX₊t_cutoff\n    t_delay = Symbol(branchname, \"₊\", :t_delay)   # pilineX₊t_delay\n\n    ComponentAffect([], [t_cutoff, t_delay]) do u, p, ctx\n        p[t_cutoff] != Inf && return # return early if already scheduled for cutoff\n        tcutoff = ctx.t + p[t_delay]\n        println(\"$branchname of line $(ctx.src)→$(ctx.dst) overcurrent at t=$(ctx.t), scheduling cutoff at t=$tcutoff\")\n        # update the parameter of the edge to store the cutoff time\n        p[t_cutoff] = tcutoff\n        # tell the integrator to explicitly step to the cutoff time\n        add_tstop!(ctx.integrator, tcutoff)\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/#Line-Cutoff-Callback","page":"Custom Transmission Line","title":"Line Cutoff Callback","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The cutoff callback switches off the line when the scheduled cutoff time is reached. Since we expect the solver to explicitly hit the cutoff time (via add_tstop!), we only need a discrete callback:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"function cutoff_condition(branchname)\n    t_cutoff = Symbol(branchname, \"₊\", :t_cutoff) # pilineX₊t_cutoff\n    ComponentCondition([], [t_cutoff]) do u, p, t\n        t == p[t_cutoff]\n    end\nend\nfunction cutoff_affect(branchname)\n    active = Symbol(branchname, \"₊\", :active) # pilineX₊active\n    ComponentAffect([], [active]) do u, p, ctx\n        println(\"$branchname of line $(ctx.src)→$(ctx.dst) cutoff at t=$(ctx.t)\")\n        p[active] = 0 # switch off the line\n    end\nend\nfunction cutoff_callback(branchname)\n    DiscreteComponentCallback(cutoff_condition(branchname), cutoff_affect(branchname))\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/#Adding-Callbacks-to-Template","page":"Custom Transmission Line","title":"Adding Callbacks to Template","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We build both callbacks by combining their respective conditions and affects. Finally, we add all three callbacks to the protected template:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"function branch_callbacks(branchname)\n    oc_affect = overcurrent_affect(branchname)\n    oc1 = ContinuousComponentCallback(\n        continuous_overcurrent_condition(branchname),\n        oc_affect\n    )\n    oc2 = DiscreteComponentCallback(\n        discrete_overcurrent_condition(branchname),\n        oc_affect\n    )\n    cut = DiscreteComponentCallback(\n        cutoff_condition(branchname),\n        cutoff_affect(branchname)\n    )\n    (oc1, oc2, cut)\nend\nset_callback!(protected_template, branch_callbacks(:pibranchA))\nadd_callback!(protected_template, branch_callbacks(:pibranchB))\nprotected_template #hide","category":"page"},{"location":"generated/custom_line/#Simulate-the-IEEE39-Grid-with-the-ProtectedLine","page":"Custom Transmission Line","title":"Simulate the IEEE39 Grid with the ProtectedLine","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"In the last part of this tutorial, we want to see our protected transmission line in action. The third part of the IEEE39 Grid Tutorial simulates a short circuit on a line. To do so, it uses two callbacks: one to enable the short circuit and one to disable the line. We can do this much more elegantly now by just using the ProtectedPiBranch model.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Lets load the first part of that tutorial to get the IEEE39 Grid model. Also, we initialize the model (the quintessence of part II).","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"EXAMPLEDIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\")\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part1.jl\"))\nformula = @initformula :ZIPLoad₊Vset = sqrt(:busbar₊u_r^2 + :busbar₊u_i^2)\nset_initformula!(nw[VIndex(31)], formula)\nset_initformula!(nw[VIndex(39)], formula)\ns0 = initialize_from_pf!(nw; verbose=false)\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Now, we should have a fully initialized network available as nw:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"nw","category":"page"},{"location":"generated/custom_line/#Derive-Network-with-Protected-Line-Models","page":"Custom Transmission Line","title":"Derive Network with Protected Line Models","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Now we'll demonstrate the protected line model in action by applying it to the IEEE39 test system.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We need to build our own network model by replacing the transmission line models with our ProtectedPiBranch. For that, we create a helper function that takes an edge model from the old network and creates a protected transmission line model with equivalent electrical parameters.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Our protected transmission line model uses two parallel branches (A and B), so we need to adjust the parameters. For two parallel branches to behave like the original single branch:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Impedances (R, X): 2× original (parallel combination gives original)\nShunt admittances (G, B): 0.5× original (parallel combination gives original)\nTransformation ratios (r): same as original","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"function protected_line_from_line(e::EdgeModel)\n    new = copy(protected_template)\n    # copy src and destination information\n    src_dst = get_graphelement(e)\n    set_graphelement!(new, src_dst)\n    for branch in [:pibranchA, :pibranchB]\n        # Impedances: double them (2× original)\n        set_default!(new, Symbol(branch, \"₊\", :R), 2 * get_default(e, :piline₊R))\n        set_default!(new, Symbol(branch, \"₊\", :X), 2 * get_default(e, :piline₊X))\n        # Shunt admittances: halve them (0.5× original)\n        set_default!(new, Symbol(branch, \"₊\", :G_src), 0.5 * get_default(e, :piline₊G_src))\n        set_default!(new, Symbol(branch, \"₊\", :B_src), 0.5 * get_default(e, :piline₊B_src))\n        set_default!(new, Symbol(branch, \"₊\", :G_dst), 0.5 * get_default(e, :piline₊G_dst))\n        set_default!(new, Symbol(branch, \"₊\", :B_dst), 0.5 * get_default(e, :piline₊B_dst))\n        # Transformation ratios: keep same\n        set_default!(new, Symbol(branch, \"₊\", :r_src), get_default(e, :piline₊r_src))\n        set_default!(new, Symbol(branch, \"₊\", :r_dst), get_default(e, :piline₊r_dst))\n    end\n    new\nend\nold_edgemodels = [nw[EIndex(i)] for i in 1:ne(nw)];\nvertexmodels = [nw[VIndex(i)] for i in 1:nv(nw)];\nnew_edgemodels = protected_line_from_line.(old_edgemodels);\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We can then build a new Network with those modified edgemodels:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"nw_protected = Network(vertexmodels, new_edgemodels)","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"... and initialize it!","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"s0_protected = initialize_from_pf!(nw_protected; verbose=false)","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"As a short sanity check, lets compare the initialized values of both networks: we do so by extracting the interface_values for both solutions (a dictionary of all currents and voltages (inputs and outputs of the models))) Then we compare their values.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"@assert collect(values(interface_values(s0))) ≈ collect(values(interface_values(s0_protected))) #hide\ncollect(values(interface_values(s0))) ≈ collect(values(interface_values(s0_protected)))","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"They are identical! If we would have made an error in our transmission line model, the steady state would be most certainly different.","category":"page"},{"location":"generated/custom_line/#Simulate-with-the-Protected-Line-Models","page":"Custom Transmission Line","title":"Simulate with the Protected Line Models","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Now that we have our protected transmission line models ready, we need to configure them for the simulation. First, we set the current threshold I_max for overcurrent protection.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We set the threshold to 130% of the power flow solution:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"AFFECTED_LINE = 24\n\nfor i in 1:46\n    i_at_steadys = s0_protected[EIndex(i, :pibranchA₊I_mag)]\n    s0_protected[EIndex(i, :pibranchA₊I_max)] = 1.3*i_at_steadys\n    i_at_steadys = s0_protected[EIndex(i, :pibranchB₊I_mag)]\n    s0_protected[EIndex(i, :pibranchB₊I_max)] = 1.3*i_at_steadys\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Next, we need to introduce a perturbation to test our protection system. We'll introduce a shortcircuit with Y_mathrmfault=1mathrmpu on branch A of line 24. Notably, we only need to start the short circuit, as the protection is now \"baked into\" the transmission line model.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"_enable_short = ComponentAffect([], [:pibranchA₊shortcircuit]) do u, p, ctx\n    @info \"Short circuit activated on branch A of line $(ctx.src)→$(ctx.dst) at t = $(ctx.t)s\"\n    p[:pibranchA₊shortcircuit] = 1\nend\nshortcircuit_cb = PresetTimeComponentCallback(0.1, _enable_short)\nknown_cbs = filter(cb -> !(cb isa PresetTimeComponentCallback), get_callbacks(nw_protected[EIndex(AFFECTED_LINE)]))\nset_callback!(nw_protected, EIndex(AFFECTED_LINE), (shortcircuit_cb, known_cbs...))\nnw_protected[EIndex(AFFECTED_LINE)] #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"With all those callbacks set, we can go ahead simulating the system.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"prob = ODEProblem(\n    nw_protected,\n    uflat(s0_protected),\n    (0.0, 15),\n    copy(pflat(s0_protected));\n    callback=get_callbacks(nw_protected),\n    dtmax=0.01,\n)\nsol = solve(prob, Rodas5P());\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"When we run this simulation, the console output will show that the short circuit on Branch A activates at t=0.1s and leads to a line shutdown at t=0.2s (after the 0.1s delay), which clears the fault. However, due to the introduced dynamics in the system, branch B of the affected line also experiences a current magnitude exceeding the threshold, which leads to a shutdown of the line at around 1.5 seconds.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Let's look at the current magnitude evolution during the simulation:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"fig = let fig = Figure()\n    ax = Axis(fig[1, 1];\n        title=\"Current Magnitude Across All Lines\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Current Magnitude (reltive to steady state)\")\n\n    # Full simulation time range\n    ts = range(sol.t[begin], sol.t[end], length=3000)\n\n    # Plot current magnitude for but the failing line\n    for i in 1:46\n        i == AFFECTED_LINE && continue\n        # Factor of 2: total transmission line current is double the branch current\n        # since we have two identical parallel branches (A and B)\n        current = 2*sol(ts, idxs=EIndex(i, :pibranchA₊I_mag)).u\n        current = current ./ current[begin]\n        lines!(ax, ts, current)\n    end\n\n    A_current = sol(ts, idxs=EIndex(AFFECTED_LINE, :pibranchA₊I_mag)).u\n    B_current = sol(ts, idxs=EIndex(AFFECTED_LINE, :pibranchB₊I_mag)).u\n    A_current = A_current ./ A_current[begin]\n    B_current = B_current ./ B_current[begin]\n\n    lines!(ax, ts, A_current; linewidth=2, color=:blue, label=\"Branch A\")\n    lines!(ax, ts, B_current; linewidth=2, color=:red, label=\"Branch B\")\n\n    hlines!(ax, [1.3]; color=:black, linestyle=:dot)\n    xlims!(ax, ts[begin], ts[end])\n    axislegend(ax; pos=:tr)\n    fig\nend","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We can also zoom into the time range around the short circuit to see how the current of branch B crosses the threshold and the branch is disabled shortly after.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"xlims!(0, 2)\nylims!(0.8, 1.5)\nfig","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/ieee39_part2/#ieee39-part2","page":"IEEE39 Part II: Initialization","title":"IEEE39 Bus Tutorial - Part II: Initialization","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"This is the second part of a four-part tutorial series for the IEEE 39-bus test system:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Part I: Model Creation - Build the network structure with buses, lines, and components\nPart II: Initialization (this tutorial) - Perform power flow calculations and dynamic initialization\nPart III: Dynamic Simulation - Run time-domain simulations and analyze system behavior\nPart IV: Advanced Modeling & Parameter Optimization - Create custom components and optimize system parameters","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The goal of this tutorial is to get an understanding of the initialization process in PowerDynamics.jl.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"For comprehensive documentation on initialization, see:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"NetworkDynamics.jl initialization docs\nPowerDynamics.jl initialization docs","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"tip: Quick Start\nIf you're looking for the practical initialization approach without diving into implementation details, jump directly to the Initialize all Components section at the end.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"This tutorial goes deep into the initialization internals for educational purposes. In practice, you'll typically use the high-level functions shown at the end rather than the detailed step-by-step process demonstrated here.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"As a prerequisite, we load part I of the tutorial, which contains the network model:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"using PowerDynamics\nEXAMPLEDIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\")\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part1.jl\"))\nnw # nw object now available","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The initialization process in PowerDynamics.jl is a two-step process: first we solve the power flow, then we use the power flow results to initialize the individual network components.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"There are shortcut functions to do this (as shown later), but we will go through the steps in detail for educational purposes.","category":"page"},{"location":"generated/ieee39_part2/#Power-Flow","page":"IEEE39 Part II: Initialization","title":"Power Flow","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"To solve the power flow, we first need to get the power flow model. We can use the function powerflow_model.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"pfnw = powerflow_model(nw)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The power flow model is a Network object like the original network. It is built from the original network, by calling powerflow_model on the individual components. For example, we have this rather complex dynamic model at bus 30:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"nw[VIndex(30)]","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"From the printout, we can see that a power flow model :pvbus is attached to the generator model.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"We can extract the attached PV power flow model by calling powerflow_model","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"powerflow_model(nw[VIndex(30)])","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The function powerflow_model checks if there is a power flow model attached (it checks the :pfmodel metadata).","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Per component, the powerflow_model function will do the following:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"If the model has the :pfmodel metadata set (see Metadata), it will return the VertexModel stored in the metadata. In Part I we set the :pfmodel metadata using the pf keyword to the [Bus].\nIf the model does not have the :pfmodel metadata set, PowerDynamics will check if the model itself is a valid power flow model. If so, it'll just use the dynamic model as the power flow model.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"What is a valid power flow model?: A valid power flow model is a model that has no internal dynamics, i.e. it either has dim(model) == 0 OR it has a zero mass matrix (i.e. only constraints).","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"For example, the PiLine models are completely static:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"nw[EIndex(1)]","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"This model has no internal states and no :pfmodel metadata.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"@assert ispfmodel(nw[EIndex(1)]) # is pf model itself\npowerflow_model(nw[EIndex(1)]) === nw[EIndex(1)]","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"As a result, when we call powerflow_model(nw), we get a completely static network, i.e. only constraints, no dynamics.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"all(iszero, pfnw.mass_matrix)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The fully static network has the form","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"dotx = 0 = f_mathrmnw(x p t)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Where x are the network states (mainly voltages u_r and u_i at the buses) and p are all the parameters such as P, V and Q values for bus models and line parameters for branch models.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"To solve this root-finding problem, we first need to find an initial guess. The initial guess is prefilled with all the default values from the components. In our case, all parameters and states have default values attached, so the initial state is fully determined.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"pfs0 = NWState(pfnw)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"With the default state, we can call find_fixpoint, which keeps p constant and tries to find an x such that the root-finding problem stated above is fulfilled:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"pfs = find_fixpoint(pfnw, pfs0)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"As a result, we get a NWState object which contains the full state for the power flow model.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Since power flow model and dynamic model share the same topology and the same network interface (i.e. nodes create voltages, edges create currents), we can extract the interface values from the power flow model state and apply them to the dynamic model:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"interf = interface_values(pfs)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The interface values give us the inputs and outputs for every component in the network, i.e. for all buses we get values for","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"busbar₊i_r and busbar₊i_i: current input\nbusbar₊u_r and busbar₊u_i: voltage output","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"For all branches we get:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"src₊u_r and src₊u_i: source side voltage input\ndst₊u_r and dst₊u_i: destination side voltage input\nsrc₊i_r and src₊i_i: source side current output\ndst₊i_r and dst₊i_i: destination side current output","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"With those interface values fixed, we can go over to the second step of the initialization process: the initialization of the dynamic component.","category":"page"},{"location":"generated/ieee39_part2/#Initialization-of-Dynamic-Components","page":"IEEE39 Part II: Initialization","title":"Initialization of Dynamic Components","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Initialization of a bus model means, we want to find a steady state of the dynamics given the interface values from the power flow model.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Therefore, the equations for the bus models (recall from Modeling Concepts) become","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"beginaligned\nM_mathrm vfracmathrmdmathrmdtx_mathrm v = colorred0 = f^mathrm vleft(x^mathrm v colorredsum_kbeginbmatrixi^k_r i^k_iendbmatrix p_mathrm v tright)\ncolorredbeginbmatrixu_r u_iendbmatrix = g^mathrm v(x^mathrmvp_mathrm v t)\nendaligned","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"where red symbols are fixed by either the power flow solution or our steady state condition (i.e. dotx=0). This leaves us with a system of N=mathrmdim(x) + mathrmdim(u) equations – we can solve for N unknowns.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"details: Edge Initialization Equations\nbeginaligned\nM_mathrm efracmathrmdmathrmdtx_mathrm e = colorred0 = f_mathrm eleft(x_mathrm e colorredbeginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix colorredbeginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrixp_mathrme tright)\ncolorredbeginbmatrixi_r^mathrmsrci_i^mathrmsrcendbmatrix = g^mathrmsrc_mathrm eleft(x_mathrm ecolorred beginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix colorredbeginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrix p_mathrme tright)\ncolorredbeginbmatrixi_r^mathrmdsti_i^mathrmdstendbmatrix = g^mathrmdst_mathrm eleft(x_mathrm e colorredbeginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix colorredbeginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrix p_mathrme tright)\nendaligned","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Notably, the unknowns can come from either the set of states or the set of parameters. We divide the set of symbols into two sets:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"fixed symbols have a default metadata set. They are considered fixed in the solution of the nonlinear system.\nfree symbols only have a guess metadata set. They are considered free in the solution of the nonlinear system.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Let's take a look at the bus model at bus 30:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"gen = nw[VIndex(30)]","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"We have a system with 15 States and 42 parameters. Of those, most are fixed, i.e. have a default metadata set. In the VertexModel printout, defaults are shown with = while guesses are shown with ≈. We can use dump_initial_state to get an overview of the free and set states:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"dump_initial_state(gen; obs=false)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Right now, we have 2 free parameters, 2 free inputs, 2 free outputs and 15 free states. We can use initialize_component to find values for the free symbols:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"try #hide\ninitialize_component(gen)\ncatch e #hide\n    @error e.msg #hide\nend #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Wait! The initialization failed! Why? Well, we need to apply additional defaults, so called default_overwrites for the inputs/outputs to make the system solvable.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"interf_v30 = Dict( # manually define interface values for demonstration\n    :busbar₊u_r => 1.04573,\n    :busbar₊u_i => -0.0609188,\n    :busbar₊i_i => 1.53174,\n    :busbar₊i_r => -2.30145,\n)\ninitialize_component(gen; default_overrides=interf_v30)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"note: Mutating vs non-mutating Initialization\nThe non mutating initialize_component returns a dictionary containing a full initialized component state. That can be useful for certain purposes, often it is easier to work with the mutating version of initialization function, which will write the initialized values back to the component metadata (i.e setting the :init property for the symbols).","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Let's call the mutating initialize_component! function to write the initialized values back to the component and inspect the initial state using dump_initial_state:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"initialize_component!(gen; default_overrides=interf_v30)\ndump_initial_state(gen; obs=false)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"In the state dump we see how the initialization successfully set all the previously unknown values, including the control parameters avr₊vref and gov₊p_ref. We have our first initialized component!","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"However, in practice it's not always so easy.","category":"page"},{"location":"generated/ieee39_part2/#Handling-Structurally-Underconstrained-Components","page":"IEEE39 Part II: Initialization","title":"Handling Structurally Underconstrained Components","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Recalling from Part 1, we have an uncontrolled machine together with a load on bus 39.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"            ╔════════════════════════════════╗\n            ║ Unctr. Ma. Load Bus (compiled) ║\n            ║  ┌────────────────────────┐    ║\n  Network   ║  │MTKBus      ┌─────────┐ │    ║\n interface  ║  │          ┌─┤ Machine │ │    ║\n  current ────→│ ┌──────┐ │ └─────────┘ │    ║\n            ║  │ │BusBar├─o             │    ║\n  voltage ←────│ └──────┘ │ ┌──────┐    │    ║\n            ║  │          └─┤ Load │    │    ║\n            ║  │            └──────┘    │    ║\n            ║  └────────────────────────┘    ║\n            ╚════════════════════════════════╝","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"If we try to initialize this component as before, we run into a problem:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"interf_v39 = Dict(\n  :busbar₊u_r => 1.01419,\n  :busbar₊u_i => -0.179795,\n  :busbar₊i_i => -1.72223,\n  :busbar₊i_r => 0.720135,\n)\ntry #hide\ninitialize_component!(nw[VIndex(39)]; default_overrides=interf_v39)\ncatch e #hide\n    @error e.msg #hide\nend #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Even though we set the interface values, the problem is still underconstrained! Let's check the free symbols:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"println(\"free u: \", free_u(nw[VIndex(39)]))\nprintln(\"free p: \", free_p(nw[VIndex(39)]))\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"We see 8 free states and 3 free parameters, however we only have 8 state + 2 output equations:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"nw[VIndex(39)] #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Even though we have enough set parameters to initialize machine and load on its own, we cannot do it simultaneously. Intuitively speaking, it's just not clear for the solver which of the two components provides how much power.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"To solve this, we have essentially 3 methods:","category":"page"},{"location":"generated/ieee39_part2/#Method-1:-Manual-setting-of-defaults","page":"IEEE39 Part II: Initialization","title":"Method 1: Manual setting of defaults","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The simplest solution is to manually set more defaults. For example, we know that we want to initialize the ZIP load around the initialization point, i.e. V_mathrmset should be the same as the bus voltage magnitude.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"vm_manual = copy(nw[VIndex(39)])\nu_r = get_initial_state(vm_manual, :busbar₊u_r)\nu_i = get_initial_state(vm_manual, :busbar₊u_i)\nset_default!(vm_manual, :ZIPLoad₊Vset, sqrt(u_r^2 + u_i^2))\ninitialize_component!(vm_manual)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The initialization succeeded now!","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"note: No more default_overrides\nNote how we can skip the default_overrides keyword argument, since the first (failing) call of initialize_component! already \"burned in\" the default overrides! Mutating state is a powerful tool, but it needs care!","category":"page"},{"location":"generated/ieee39_part2/#Method-2:-Adding-an-init_formula","page":"IEEE39 Part II: Initialization","title":"Method 2: Adding an init_formula","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The problem with the previous method is that it is quite manual. In reality, we would never go through this very manual initialization process. The fact that the model is structurally underconstrained is a property of the model and should therefore be handled by the model. To do so, NetworkDynamics.jl provides the InitFormula mechanism.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"An InitFormula is a symbolic formula that is evaluated during the initialization process. It is attached to the VertexModel so it can be evaluated automatically during the initialization process. The \"formula\" we want to apply is simply the equation","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"V_mathrmset = sqrtu_r^2 + u_i^2","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"vm_formula = copy(nw[VIndex(39)])\nformula = @initformula :ZIPLoad₊Vset = sqrt(:busbar₊u_r^2 + :busbar₊u_i^2)\nset_initformula!(vm_formula, formula)\nvm_formula #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The printout shows 1 additional initialization equation was attached to the model.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The initialization works now:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"initialize_component!(vm_formula)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The init formula is applied early in the initialization process, essentially writing a new default for ZIPLoad₊Vset based on the other defaults.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"This reduced the number of free variables to 10, thus the system was solvable.","category":"page"},{"location":"generated/ieee39_part2/#Method-3:-Using-an-InitConstraint","page":"IEEE39 Part II: Initialization","title":"Method 3: Using an InitConstraint","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Sometimes, your additional initialization needs are more complicated. Similar to defining a formula, which is evaluated before the actual initialization, NetworkDynamics provides a mechanism for injecting additional constraints into the initialization process.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"In contrast to the formula, the constraint does not need to be explicitly solvable, as it defines a residual equation","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"0 = c(x) = V_mathrmset - sqrtu_r^2 + u_i^2","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"vm_constraint = copy(nw[VIndex(39)])\nconstraint = @initconstraint begin\n  :ZIPLoad₊Vset - sqrt(:busbar₊u_r^2 + :busbar₊u_i^2)\nend\nset_initconstraint!(vm_constraint, constraint)\nvm_constraint #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"With this added constraint, the initialization process is solvable again, since we now have 11 equations for the 11 free variables.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"initialize_component!(vm_constraint)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"For this particular case, method (2) is the way to go. However there are cases where the constraint is more complex and cannot be expressed as a formula.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"See NetworkDynamics docs on Advanced Component Initialization: Formulas and Constraints and the PowerDynamics specific extension Advanced Component Initialization for more information on method 2 and 3.","category":"page"},{"location":"generated/ieee39_part2/#initialize-all-components","page":"IEEE39 Part II: Initialization","title":"Automatic Initialization of Full Network","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Let's return from our excursion into individual component initialization and focus on the whole network again. As we've just seen, we have structurally underconstrained components in the network. Let's define the init formulas for the two buses which have loads and machines:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"formula = @initformula :ZIPLoad₊Vset = sqrt(:busbar₊u_r^2 + :busbar₊u_i^2)\nset_initformula!(nw[VIndex(31)], formula)\nset_initformula!(nw[VIndex(39)], formula)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"With that, the componentwise initialization of the whole network is possible:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"initialize_componentwise!(nw; default_overrides=interf)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Even shorter, we can just use initialize_from_pf! to do everything from exporting the power flow model, finding the fixpoint and initializing all components:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"s0 = initialize_from_pf!(nw)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/ieee9bus/#ieee9bus","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"In this example, we're going to model the IEEE 9 bus system.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The parameters are mainly adopted from the RTDS data.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"using PowerDynamics\nusing PowerDynamics.Library\nusing ModelingToolkit\nusing NetworkDynamics\nusing Graphs\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie","category":"page"},{"location":"generated/ieee9bus/#Generator-Busses","page":"IEEE 9Bus Example","title":"Generator Busses","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The 3 generator buses are modeld using a SauerPai 6th order machine model with variable field voltage and mechanical torque input. The field voltage is provided by an AVRTypeI, the torque is provide by a TGOV1 model.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"function GeneratorBus(; machine_p=(;), avr_p=(;), gov_p=(;))\n    @named machine = SauerPaiMachine(;\n        vf_input=true,\n        τ_m_input=true,\n        S_b=100,\n        V_b=1,\n        ω_b=2π*60,\n        R_s=0.000125,\n        T″_d0=0.01,\n        T″_q0=0.01,\n        machine_p... # unpack machine parameters\n    )\n    @named avr = AVRTypeI(; vr_min=-5, vr_max=5,\n        Ka=20, Ta=0.2,\n        Kf=0.063, Tf=0.35,\n        Ke=1, Te=0.314,\n        E1=3.3, Se1=0.6602, E2=4.5, Se2=4.2662,\n        tmeas_lag=false,\n        avr_p... # unpack AVR parameters\n    )\n    @named gov = TGOV1(; R=0.05, T1=0.05, T2=2.1, T3=7.0, DT=0, V_max=5, V_min=-5,\n        gov_p... # unpack governor parameters\n    )\n    # generate the \"injector\" as combination of multiple components\n    injector = CompositeInjector([machine, avr, gov]; name=:generator)\n\n    # generate the MTKBus (i.e. the MTK model containg the busbar and the injector)\n    mtkbus = MTKBus(injector)\nend\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Load-Busses","page":"IEEE 9Bus Example","title":"Load Busses","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The dynamic loads are modeld as static Y-loads. Those have 3 parameters: Pset, Qset and Vset. For now, those parameters will be left free. We'll initialize them later on from the powerflow results.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The Vset parameter is left free for now. Later on it is automaticially determined to match the behavior of the static power flow load model.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"function ConstantYLoadBus()\n    @named load = ConstantYLoad()\n    MTKBus(load; name=:loadbus)\nend\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Generate-Dynamical-models","page":"IEEE 9Bus Example","title":"Generate Dynamical models","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The parameters of the machines are obtaind from the data table from the RTDS datasheet.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"gen1p = (;X_ls=0.01460, X_d=0.1460, X′_d=0.0608, X″_d=0.06, X_q=0.1000, X′_q=0.0969, X″_q=0.06, T′_d0=8.96, T′_q0=0.310, H=23.64)\ngen2p = (;X_ls=0.08958, X_d=0.8958, X′_d=0.1198, X″_d=0.11, X_q=0.8645, X′_q=0.1969, X″_q=0.11, T′_d0=6.00, T′_q0=0.535, H= 6.40)\ngen3p = (;X_ls=0.13125, X_d=1.3125, X′_d=0.1813, X″_d=0.18, X_q=1.2578, X′_q=0.2500, X″_q=0.18, T′_d0=5.89, T′_q0=0.600, H= 3.01)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"We instantiate all models as modeling toolkit models.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"mtkbus1 = GeneratorBus(; machine_p=gen1p)\nmtkbus2 = GeneratorBus(; machine_p=gen2p)\nmtkbus3 = GeneratorBus(; machine_p=gen3p)\nmtkbus4 = MTKBus() # <- bus with no injectors, essentially\nmtkbus5 = ConstantYLoadBus()\nmtkbus6 = ConstantYLoadBus()\nmtkbus7 = MTKBus()\nmtkbus8 = ConstantYLoadBus()\nmtkbus9 = MTKBus()\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"After this, we can build the NetworkDynamics components using the Bus-constructor.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The Bus constructor is essentially a thin wrapper around the VertexModel constructor which, per default, adds some metadata. For example the vidx property which later on allows for \"graph free\" network dynamics instantiation.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"We use the pf keyword to specify the models which should be used in the powerflow calculation. Here, generator 1 is modeld as a slack bus while the other two generators are modeled as a PV bus. The loads are modeled as PQ buses.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"@named bus1 = Bus(mtkbus1; vidx=1, pf=pfSlack(V=1.04))\n@named bus2 = Bus(mtkbus2; vidx=2, pf=pfPV(V=1.025, P=1.63))\n@named bus3 = Bus(mtkbus3; vidx=3, pf=pfPV(V=1.025, P=0.85))\n@named bus4 = Bus(mtkbus4; vidx=4)\n@named bus5 = Bus(mtkbus5; vidx=5, pf=pfPQ(P=-1.25, Q=-0.5))\n@named bus6 = Bus(mtkbus6; vidx=6, pf=pfPQ(P=-0.9, Q=-0.3))\n@named bus7 = Bus(mtkbus7; vidx=7)\n@named bus8 = Bus(mtkbus8; vidx=8, pf=pfPQ(P=-1.0, Q=-0.35))\n@named bus9 = Bus(mtkbus9; vidx=9)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Later on in initialization, we want to ensure that the internal parameters of the loads are initialized to match the powerflow results. We have 3 free parameters: Vset, Pset and Qset. To help the initialization, we can provide a InitFormula to set the Vset parameter to the voltage magnitude of the bus.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"vset_formula = @initformula :load₊Vset = sqrt(:busbar₊u_r^2 + :busbar₊u_i^2)\nadd_initformula!(bus5, vset_formula)\nadd_initformula!(bus6, vset_formula)\nadd_initformula!(bus8, vset_formula)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Branches","page":"IEEE 9Bus Example","title":"Branches","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Branches and Transformers are build from the same PILine model with optional transformer on both ends. However, the data is provided in a way that the actual transformer values are 1.0. Apparently, the transforming action has been absorbed into the line parameters according to the base voltage on both ends.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"For the lines we again make use of the src and dst metadata of the EdgeModel objects for automatic graph construction.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"function piline(; R, X, B)\n    @named pibranch = PiLine(;R, X, B_src=B/2, B_dst=B/2, G_src=0, G_dst=0)\n    MTKLine(pibranch)\nend\nfunction transformer(; R, X)\n    @named transformer = PiLine(;R, X, B_src=0, B_dst=0, G_src=0, G_dst=0)\n    MTKLine(transformer)\nend\n\n@named l45 = Line(piline(; R=0.0100, X=0.0850, B=0.1760), src=4, dst=5)\n@named l46 = Line(piline(; R=0.0170, X=0.0920, B=0.1580), src=4, dst=6)\n@named l57 = Line(piline(; R=0.0320, X=0.1610, B=0.3060), src=5, dst=7)\n@named l69 = Line(piline(; R=0.0390, X=0.1700, B=0.3580), src=6, dst=9)\n@named l78 = Line(piline(; R=0.0085, X=0.0720, B=0.1490), src=7, dst=8)\n@named l89 = Line(piline(; R=0.0119, X=0.1008, B=0.2090), src=8, dst=9)\n@named t14 = Line(transformer(; R=0, X=0.0576), src=1, dst=4)\n@named t27 = Line(transformer(; R=0, X=0.0625), src=2, dst=7)\n@named t39 = Line(transformer(; R=0, X=0.0586), src=3, dst=9)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Build-Network","page":"IEEE 9Bus Example","title":"Build Network","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Finally, we can build the network by providing the vertices and edges.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"vertexfs = [bus1, bus2, bus3, bus4, bus5, bus6, bus7, bus8, bus9];\nedgefs = [l45, l46, l57, l69, l78, l89, t14, t27, t39];\nnw = Network(vertexfs, edgefs; warn_order=false)","category":"page"},{"location":"generated/ieee9bus/#System-Initialization","page":"IEEE 9Bus Example","title":"System Initialization","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"To initialize the system for dynamic simulation, we use initialize_from_pf! which performs a unified powerflow solving and component initialization process.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Internally, this function:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Builds an equivalent static powerflow network from the dynamic models\nSolves the static powerflow equations using the specified powerflow models (pfSlack, pfPV, pfPQ)\nUses the powerflow solution to initialize all dynamic component states and parameters","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"This ensures that the dynamic model starts from a steady-state condition that matches the powerflow solution. Specifically, it determines:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Bus voltages and currents from the powerflow solution\nUnknown Vset parameters for load buses\nInternal machine states (flux linkages, rotor angles, etc.)\nController states and references for AVRs and governors","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"u0 = initialize_from_pf(nw);\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"We could check the initial state of some of the variables, we expect the model to be initialized in a way, that the setpoint of the constant Y-loads matches the powerfow constraints.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"u0[VIndex(5, :load₊Pset)] ≈ -1.25 && u0[VIndex(5, :load₊Qset)] ≈ -0.5","category":"page"},{"location":"generated/ieee9bus/#Disturbance","page":"IEEE 9Bus Example","title":"Disturbance","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"To see some dynamics, we need to introduce some disturbance. For that we use a PresetTimeComponentCallback to deactivate a line at a certain time.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"deactivate_line = ComponentAffect([], [:pibranch₊active]) do u, p, ctx\n    @info \"Deactivate line $(ctx.src)=>$(ctx.dst) at t=$(ctx.t)\"\n    p[:pibranch₊active] = 0\nend\ncb = PresetTimeComponentCallback([1.0], deactivate_line)\nset_callback!(l46, cb)\nl46 # printout shows that the callback is set","category":"page"},{"location":"generated/ieee9bus/#Dynamic-Simulation","page":"IEEE 9Bus Example","title":"Dynamic Simulation","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"With the system properly initialized, we can now set up and run the dynamic simulation. We create an ODE problem using the initialized state and simulate the system response to the line outage disturbance.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"prob = ODEProblem(nw, uflat(u0), (0,15), pflat(u0); callback=get_callbacks(nw))\nsol = solve(prob, Rodas5P())\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Plotting-the-Solution","page":"IEEE 9Bus Example","title":"Plotting the Solution","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Finally, we visualize the simulation results showing the system response to the line outage at t=1.0 seconds. The plots show active power, voltage magnitudes, and generator frequencies across the simulation time.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"fig = Figure(size=(600,800));\n\n# Active power at selected buses\nax = Axis(fig[1, 1]; title=\"Active Power\", xlabel=\"Time [s]\", ylabel=\"Power [pu]\")\nfor i in [1,2,3,5,6,8]\n    lines!(ax, sol; idxs=VIndex(i,:busbar₊P), label=\"Bus $i\", color=Cycled(i))\nend\naxislegend(ax)\n\n# Voltage magnitude at all buses\nax = Axis(fig[2, 1]; title=\"Voltage Magnitude\", xlabel=\"Time [s]\", ylabel=\"Voltage [pu]\")\nfor i in 1:9\n    lines!(ax, sol; idxs=VIndex(i,:busbar₊u_mag), label=\"Bus $i\", color=Cycled(i))\nend\n\n# Generator frequencies\nax = Axis(fig[3, 1]; title=\"Generator Frequency\", xlabel=\"Time [s]\", ylabel=\"Frequency [pu]\")\nfor i in 1:3\n    lines!(ax, sol; idxs=VIndex(i,:generator₊machine₊ω), label=\"Gen $i\", color=Cycled(i))\nend\naxislegend(ax)\n\nfig #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/ieee39_part1/#ieee39-part1","page":"IEEE39 Part I: Modeling","title":"IEEE39 Bus Tutorial - Part I: Model Creation","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"This is the first part of a four-part tutorial series for the IEEE 39-bus test system:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Part I: Model Creation (this tutorial) - Build the network structure with buses, lines, and components\nPart II: Initialization - Perform power flow calculations and dynamic initialization\nPart III: Dynamic Simulation - Run time-domain simulations and analyze system behavior\nPart IV: Advanced Modeling & Parameter Optimization - Create custom components and optimize system parameters","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"In this first part, we'll construct the complete IEEE 39-bus network model using PowerDynamics.jl, including generators, loads, transmission lines, and control systems.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"This script can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/ieee39_part1/#System-Structure","page":"IEEE39 Part I: Modeling","title":"System Structure","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The system consists of 39 buses (with 10 generators and 19 loads) and 46 branches (12 of which are transformers).","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The buses fall into the following categories:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Junction: pure transient buses without dynamic components\nLoad: buses with loads only\nControlled Machine: buses with controlled machines (generators with AVR and GOV)\nControlled Machine + Load: buses with controlled machines and loads\nUncontrolled Machine + Load: buses with uncontrolled machines and loads","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"For the power flow solution, we have a slack bus, PV buses and PQ buses.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"For the dynamic simulation, we will use the following models:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"ZIP Load for loads,\n6th Order Sauer-Pai Machine and\nAVR Type I and TGOV1 for controlled machines.","category":"page"},{"location":"generated/ieee39_part1/#Setup-and-Data-Loading","page":"IEEE39 Part I: Modeling","title":"Setup and Data Loading","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"warning: No Standardized Data Import\nAs of now, PowerDynamics.jl does not support any advanced import mechanisms for power grids. Therefore, this tutorial loads the data from some custom CSV files.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"First, we'll load the required packages and read the system data from CSV files. The IEEE 39-bus system data is organized into separate files for different components.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"using PowerDynamics\nusing PowerDynamics.Library\nusing ModelingToolkit\nusing NetworkDynamics\nusing DataFrames\nusing CSV\n\nDATA_DIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\", \"ieee39data\")\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The system data is stored in CSV files containing:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"details: bus.csv - Bus Configuration Data\nParameter Description\nbus Bus number (unique identifier)\nbus_type Power flow bus type: \"PQ\" (load), \"PV\" (generator), \"Slack\" (reference)\ncategory Component category: \"junction\", \"load\", \"ctrld_machine\", \"ctrld_machine_load\", \"unctrld_machine_load\"\nP Active power injection [pu] (positive = generation, negative = load)\nQ Reactive power injection [pu] (positive = generation, negative = load)\nV Voltage magnitude [pu] (for PV and Slack buses)\nbase_kv Base voltage level [kV]\nhas_load Boolean flag indicating presence of load component\nhas_gen Boolean flag indicating presence of generator component\nhas_avr Boolean flag indicating presence of automatic voltage regulator\nhas_gov Boolean flag indicating presence of turbine governor","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"details: branch.csv - Transmission Line and Transformer Data\nParameter Description\nsrc_bus Source bus number\ndst_bus Destination bus number\ntransformer Transformer flag (0 = line, 1 = transformer)\nr_src Source end transformation ratio [pu]\nR Series resistance [pu]\nX Series reactance [pu]\nG_src Source end shunt conductance [pu]\nG_dst Destination end shunt conductance [pu]\nB_src Source end shunt susceptance [pu]\nB_dst Destination end shunt susceptance [pu]","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"details: load.csv - ZIP Load Model Parameters\nParameter Description\nbus Bus number where load is connected\nPset Active power at operation point [pu]\nQset Reactive power at operation point [pu]\nKpZ Active power constant impedance fraction\nKqZ Reactive power constant impedance fraction\nKpI Active power constant current fraction\nKqI Reactive power constant current fraction\nKpC Active power constant power fraction (1-KpZ-KpI)\nKqC Reactive power constant power fraction (1-KqZ-KqI)Note: ZIP loads combine constant impedance (Z), constant current (I), and constant power (P) components.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"details: machine.csv - Generator (Sauer-Pai Machine) Parameters\nParameter Description\nbus Bus number where generator is connected\nSn Machine power rating [MVA]\nV_b System voltage basis [kV]\nVn Machine voltage rating [kV]\nR_s Stator resistance [pu]\nX_ls Stator leakage reactance [pu]\nX_d d-axis synchronous reactance [pu]\nX_q q-axis synchronous reactance [pu]\nX′_d d-axis transient reactance [pu]\nX′_q q-axis transient reactance [pu]\nX″_d d-axis subtransient reactance [pu]\nX″_q q-axis subtransient reactance [pu]\nT′_d0 d-axis transient time constant [s]\nT′_q0 q-axis transient time constant [s]\nT″_d0 d-axis subtransient time constant [s]\nT″_q0 q-axis subtransient time constant [s]\nH Inertia constant [s]\nD Direct shaft damping coefficient","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"details: avr.csv - Automatic Voltage Regulator (AVR Type I) Parameters\nParameter Description\nbus Bus number where AVR-controlled generator is located\nKa Amplifier gain\nKe Field circuit integral deviation\nKf Stabilizer gain\nTa Amplifier time constant [s]\nTf Stabilizer time constant [s]\nTe Field circuit time constant [s]\nTr Measurement time constant [s]\nvr_min Minimum regulator voltage [pu]\nvr_max Maximum regulator voltage [pu]\nE1 First ceiling voltage [pu]\nSe1 First ceiling saturation factor\nE2 Second ceiling voltage [pu]\nSe2 Second ceiling saturation factor","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"details: gov.csv - Turbine Governor (TGOV1) Parameters\nParameter Description\nbus Bus number where governor-controlled generator is located\nV_min Minimum valve position [pu]\nV_max Maximum valve position [pu]\nR Governor droop [Machine PU]\nT1 First transient time constant [s]\nT2 Second transient time constant [s]\nT3 Third transient time constant [s]\nDT Turbine damping coefficient\nω_ref Reference frequency [pu]","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"branch_df = CSV.read(joinpath(DATA_DIR, \"branch.csv\"), DataFrame)\nbus_df = CSV.read(joinpath(DATA_DIR, \"bus.csv\"), DataFrame)\nload_df = CSV.read(joinpath(DATA_DIR, \"load.csv\"), DataFrame)\nmachine_df = CSV.read(joinpath(DATA_DIR, \"machine.csv\"), DataFrame)\navr_df = CSV.read(joinpath(DATA_DIR, \"avr.csv\"), DataFrame)\ngov_df = CSV.read(joinpath(DATA_DIR, \"gov.csv\"), DataFrame)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"System base values follow the IEEE 39-bus standard:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"BASE_MVA = 100.0\nBASE_FREQ = 60.0\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/#Subcomponent-Definition","page":"IEEE39 Part I: Modeling","title":"Subcomponent Definition","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"As stated above, our buses fall into 5 different categories. We will define a \"template\" for each of those categories and then create the individual buses from those templates. By doing so, we can reach substantial performance improvements, as we do not have to repeatedly compile the same models (the symbolic simplification is quite costly). Instead, we copy the templates and adjust parameters.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"However, before we can define the bus templates, we need to define the individual subcomponents. Those subcomponents are MTK models and not yet compiled node models. See Modeling Concepts and the custom bus tutorial.","category":"page"},{"location":"generated/ieee39_part1/#Load-Model","page":"IEEE39 Part I: Modeling","title":"Load Model","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"We use the ZIP load model to represent loads. This model satisfies the Injector Interface.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"(t) ┌──────────┐\n o──┤ ZIP Load │\n    └──────────┘","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"load = ZIPLoad(;name=:ZIPLoad)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/#Generator-Models","page":"IEEE39 Part I: Modeling","title":"Generator Models","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"For generators, we use the Sauer-Pai machine model, which is a 6th-order synchronous machine model. We create two variants:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Uncontrolled Machine: No external control inputs for mechanical torque or field voltage. This model satisfies the Injector Interface directly.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"(t) ┌─────────┐\n o──┤ Machine │\n    └─────────┘","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"uncontrolled_machine = SauerPaiMachine(;\n    τ_m_input=false,  ## No external mechanical torque input\n    vf_input=false,   ## No external field voltage input\n    name=:machine,\n)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Controlled Machine: Includes automatic voltage regulator (AVR) and turbine governor controls.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The controlled machine is modeled as a composite injector. It consists of 3 subcomponents: the machine, the AVR and the governor. The AVR receives the voltage magnitude measurement from the terminal of the machine and sets the field voltage. The governor receives the frequency measurement and sets the mechanical torque. Together, they satisfy the Injector Interface.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"      ┌───────────────────────────────┐\n      │ CtrldMachine  u_mag_meas      │\n      │              ╭─────→────╮     │\n      │    ┌─────────┴─┐      ┌─┴───┐ │\n  (t) │    │           ├───←──┤ AVR │ │\n   o──┼────┤ Sauer-Pai │ vf   └─────┘ │\n      │    │ Machine   │ τ_m  ┌─────┐ │\n      │    │           ├───←──┤ Gov │ │\n      │    └─────────┬─┘      └─┬───┘ │\n      │              ╰─────→────╯     │\n      │                 ω_meas        │\n      └───────────────────────────────┘","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"_machine = SauerPaiMachine(;\n    name=:machine,\n)\n_avr = AVRTypeI(;\n    name=:avr,\n    ceiling_function=:quadratic,\n)\n_gov = TGOV1(; name=:gov,)\n\ncontrolled_machine = CompositeInjector(\n    [_machine, _avr, _gov],\n    name=:ctrld_gen\n)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/#Bus-Template-Creation","page":"IEEE39 Part I: Modeling","title":"Bus Template Creation","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Now we have all the components (i.e., the MTK models) so we can combine them into full bus models and compile the methods.","category":"page"},{"location":"generated/ieee39_part1/#Junction-Bus","page":"IEEE39 Part I: Modeling","title":"Junction Bus","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Pure transmission buses with no generation or load","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"           ╔══════════════════════╗\n           ║ Junction (compiled)  ║\n Network   ║  ┌─────────────────┐ ║\ninterface  ║  │MTKBus           │ ║\n current ────→│┌──────┐         │ ║\n           ║  ││BusBar│(nothing)│ ║\n voltage ←────│└──────┘         │ ║\n           ║  └─────────────────┘ ║\n           ╚══════════════════════╝","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"@named junction_bus_template = Bus(MTKBus())\nstrip_defaults!(junction_bus_template)  ## Clear default parameters for manual setting\njunction_bus_template #hide","category":"page"},{"location":"generated/ieee39_part1/#Load-Bus","page":"IEEE39 Part I: Modeling","title":"Load Bus","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Buses with only load components","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"           ╔═════════════════════╗\n           ║ Load (compiled)     ║\n Network   ║  ┌────────────────┐ ║\ninterface  ║  │MTKBus          │ ║\n current ────→│┌──────┐ ┌────┐ │ ║\n           ║  ││BusBar├o┤Load│ │ ║\n voltage ←────│└──────┘ └────┘ │ ║\n           ║  └────────────────┘ ║\n           ╚═════════════════════╝","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"@named load_bus_template = Bus(MTKBus(load))\nstrip_defaults!(load_bus_template)\nload_bus_template #hide","category":"page"},{"location":"generated/ieee39_part1/#Generator-Bus-(Controlled)","page":"IEEE39 Part I: Modeling","title":"Generator Bus (Controlled)","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Buses with controlled generators (machine + AVR + governor)","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"            ╔════════════════════════════════════════════════╗\n            ║ Ctrld Machine Bus (compiled)                   ║\n            ║  ┌───────────────────────────────────────────┐ ║\n            ║  │MTKBus                                     │ ║\n            ║  │         ┌───────────────────────────────┐ │ ║\n  Network   ║  │         │CtrldMachine  ╭─────→────╮     │ │ ║\n interface  ║  │         │    ┌─────────┴─┐      ┌─┴───┐ │ │ ║\n  current ────→│┌──────┐ │    │           ├───←──┤ AVR │ │ │ ║\n            ║  ││BusBar├o┼────┤ Sauer-Pai │      └─────┘ │ │ ║\n  voltage ←────│└──────┘ │    │ Machine   │      ┌─────┐ │ │ ║\n            ║  │         │    │           ├───←──┤ Gov │ │ │ ║\n            ║  │         │    └─────────┬─┘      └─┬───┘ │ │ ║\n            ║  │         │              ╰─────→────╯     │ │ ║\n            ║  │         └───────────────────────────────┘ │ ║\n            ║  └───────────────────────────────────────────┘ ║\n            ╚════════════════════════════════════════════════╝","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"@named ctrld_machine_bus_template = Bus(\n    MTKBus(controlled_machine);\n)\nstrip_defaults!(ctrld_machine_bus_template)\n# Set system-wide base values for all generators\nset_default!(ctrld_machine_bus_template, r\"S_b$\", BASE_MVA)\nset_default!(ctrld_machine_bus_template, r\"ω_b$\", 2π*BASE_FREQ)\nctrld_machine_bus_template #hide","category":"page"},{"location":"generated/ieee39_part1/#Generator-Load-Bus-(Controlled)","page":"IEEE39 Part I: Modeling","title":"Generator + Load Bus (Controlled)","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Buses with both controlled generators and loads","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"            ╔═════════════════════════════════════════════════╗\n            ║ Ctrld Machine Load Bus (compiled)               ║\n            ║  ┌────────────────────────────────────────────┐ ║\n            ║  │MTKBus    ┌───────────────────────────────┐ │ ║\n            ║  │          │CtrldMachine  ╭─────→────╮     │ │ ║\n            ║  │          │    ┌─────────┴─┐      ┌─┴───┐ │ │ ║\n            ║  │          │    │           ├───←──┤ AVR │ │ │ ║\n  Network   ║  │        ┌─┼────┤ Sauer-Pai │      └─────┘ │ │ ║\n interface  ║  │        │ │    │ Machine   │      ┌─────┐ │ │ ║\n  current ────→│┌──────┐│ │    │           ├───←──┤ Gov │ │ │ ║\n            ║  ││BusBar├o │    └─────────┬─┘      └─┬───┘ │ │ ║\n  voltage ←────│└──────┘│ │              ╰─────→────╯     │ │ ║\n            ║  │        │ └───────────────────────────────┘ │ ║\n            ║  │        │ ┌──────┐                          │ ║\n            ║  │        └─┤ Load │                          │ ║\n            ║  │          └──────┘                          │ ║\n            ║  └────────────────────────────────────────────┘ ║\n            ╚═════════════════════════════════════════════════╝","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"@named ctrld_machine_load_bus_template = Bus(\n    MTKBus(controlled_machine, load);\n)\nstrip_defaults!(ctrld_machine_load_bus_template)\nset_default!(ctrld_machine_load_bus_template, r\"S_b$\", BASE_MVA)\nset_default!(ctrld_machine_load_bus_template, r\"ω_b$\", 2π*BASE_FREQ)\nctrld_machine_load_bus_template #hide","category":"page"},{"location":"generated/ieee39_part1/#Generator-Load-Bus-(Uncontrolled)","page":"IEEE39 Part I: Modeling","title":"Generator + Load Bus (Uncontrolled)","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Buses with uncontrolled generators and loads","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"            ╔════════════════════════════════╗\n            ║ Unctr. Ma. Load Bus (compiled) ║\n            ║  ┌────────────────────────┐    ║\n  Network   ║  │MTKBus      ┌─────────┐ │    ║\n interface  ║  │          ┌─┤ Machine │ │    ║\n  current ────→│ ┌──────┐ │ └─────────┘ │    ║\n            ║  │ │BusBar├─o             │    ║\n  voltage ←────│ └──────┘ │ ┌──────┐    │    ║\n            ║  │          └─┤ Load │    │    ║\n            ║  │            └──────┘    │    ║\n            ║  └────────────────────────┘    ║\n            ╚════════════════════════════════╝","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"@named unctrld_machine_load_bus_template = Bus(\n    MTKBus(uncontrolled_machine, load);\n)\nstrip_defaults!(unctrld_machine_load_bus_template)\nset_default!(unctrld_machine_load_bus_template, r\"S_b$\", BASE_MVA)\nset_default!(unctrld_machine_load_bus_template, r\"ω_b$\", 2π*BASE_FREQ)\nunctrld_machine_load_bus_template #hide","category":"page"},{"location":"generated/ieee39_part1/#Bus-Instantiation-and-Parameter-Setting","page":"IEEE39 Part I: Modeling","title":"Bus Instantiation and Parameter Setting","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Now we create the actual bus instances by copying templates and applying specific parameters from the CSV data files.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"# Helper function to apply CSV parameters to bus components\nfunction apply_csv_params!(bus, table, bus_index)\n    row_idx = findfirst(table.bus .== bus_index)\n\n    # Apply all parameters except \"bus\" column\n    row = table[row_idx, :]\n    for col_name in names(table)\n        if col_name != \"bus\"\n            set_default!(bus, Regex(col_name*\"\\$\"), row[col_name])\n        end\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"For each bus in the system, we:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Select the appropriate template based on its category\nCreate a bus instance with the correct vertex index and name\nApply component-specific parameters from CSV files\nSet the power flow model (PQ, PV, or Slack)","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"busses = []\nfor row in eachrow(bus_df)\n    i = row.bus\n\n    # Select template based on bus category\n    bus = if row.category == \"junction\"\n        Bus(junction_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    elseif row.category == \"load\"\n        Bus(load_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    elseif row.category == \"ctrld_machine\"\n        Bus(ctrld_machine_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    elseif row.category == \"ctrld_machine_load\"\n        Bus(ctrld_machine_load_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    elseif row.category == \"unctrld_machine_load\"\n        Bus(unctrld_machine_load_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    end\n\n    # Apply component parameters from CSV files\n    row.has_load && apply_csv_params!(bus, load_df, i)\n    row.has_gen && apply_csv_params!(bus, machine_df, i)\n    row.has_avr && apply_csv_params!(bus, avr_df, i)\n    row.has_gov && apply_csv_params!(bus, gov_df, i)\n\n    # Set power flow model based on bus type\n    pf_model = if row.bus_type == \"PQ\"\n        pfPQ(P=row.P, Q=row.Q)  ## Load bus: fixed P and Q\n    elseif row.bus_type == \"PV\"\n        pfPV(P=row.P, V=row.V)  ## Generator bus: fixed P and V\n    elseif row.bus_type == \"Slack\"\n        pfSlack(V=row.V, δ=0)   ## Slack bus: fixed V and angle\n    end\n    set_pfmodel!(bus, pf_model)\n\n    push!(busses, bus)\nend","category":"page"},{"location":"generated/ieee39_part1/#Transmission-Line-Creation","page":"IEEE39 Part I: Modeling","title":"Transmission Line Creation","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The IEEE 39-bus system includes both transmission lines and transformers, all modeled using the π-line equivalent circuit model.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The model consists of several layers:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The PiModel, which satisfies the Branch Interface as it has two terminals\nThe MTKLine constructor, which creates a MTK model fulfilling the MTKLine Interface\nThe compiled EdgeModel created by calling the Line constructor","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"       ╔══════════════════════════════════╗\n       ║ EdgeModel (compiled)             ║\n   src ║ ┌──────────────────────────────┐ ║ dst\nvertex ║ │MTKLine                       │ ║ vertex\n   u ───→│┌───────┐ ┌────────┐ ┌───────┐│←─── u\n       ║ ││LineEnd├o┤ PiLine ├o┤LineEnd││ ║\n   i ←───│└───────┘ └────────┘ └───────┘│───→ i\n       ║ └──────────────────────────────┘ ║\n       ╚══════════════════════════════════╝","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"(We used the PiLine_fault model since we plan on simulating short circuits later.)","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"@named piline_template = Line(MTKLine(PiLine_fault(;name=:piline)))","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Each transmission element is created by:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Instantiating a line from the template with source and destination buses\nSetting electrical parameters (resistance, reactance, susceptance) from CSV data","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"branches = []\nfor row in eachrow(branch_df)\n    # Create line instance with topology\n    line = Line(piline_template; src=row.src_bus, dst=row.dst_bus)\n\n    # Apply electrical parameters from CSV data\n    for col_name in names(branch_df)\n        if col_name ∉ [\"src_bus\", \"dst_bus\", \"transformer\"]\n            set_default!(line, Regex(col_name*\"\\$\"), row[col_name])\n        end\n    end\n\n    push!(branches, line)\nend","category":"page"},{"location":"generated/ieee39_part1/#Network-Assembly","page":"IEEE39 Part I: Modeling","title":"Network Assembly","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Finally, we combine all buses and transmission lines into a complete network model. This creates the IEEE 39-bus test system ready for initialization and simulation.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"nw = Network(busses, branches)","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The network nw now contains the complete IEEE 39-bus model structure. In Part 2 of this tutorial series, we'll initialize this network by solving the power flow and setting up the dynamic initial conditions.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Library/#Component-Library","page":"Component Library","title":"Component Library","text":"","category":"section"},{"location":"Library/","page":"Component Library","title":"Component Library","text":"This page documents all the pre-built components available in the PowerDynamics.jl library.","category":"page"},{"location":"Library/","page":"Component Library","title":"Component Library","text":"warning: PowerDynamics.Library Under Active Development\nThe PowerDynamics.Library component library is currently excluded from semantic versioning and is under heavy development.While PowerDynamics itself follows semantic versioning, the Library submodule's API is highly unstable and variable names, function signatures, and model interfaces may change frequently without notice. If you are using specific models from PowerDynamics.Library in their current state, we strongly recommend copying them to your own source code to avoid breaking changes in future updates.","category":"page"},{"location":"Library/#Slack-Models","page":"Component Library","title":"Slack Models","text":"","category":"section"},{"location":"Library/#Algebraic-and-Differential-Slack","page":"Component Library","title":"Algebraic and Differential Slack","text":"","category":"section"},{"location":"Library/#Machine-Models","page":"Component Library","title":"Machine Models","text":"","category":"section"},{"location":"Library/#Synchronous-Machine-Models","page":"Component Library","title":"Synchronous Machine Models","text":"","category":"section"},{"location":"Library/#Control-Systems","page":"Component Library","title":"Control Systems","text":"","category":"section"},{"location":"Library/#Automatic-Voltage-Regulators-(AVRs)","page":"Component Library","title":"Automatic Voltage Regulators (AVRs)","text":"","category":"section"},{"location":"Library/#Governors-and-Turbines","page":"Component Library","title":"Governors and Turbines","text":"","category":"section"},{"location":"Library/#Load-Models","page":"Component Library","title":"Load Models","text":"","category":"section"},{"location":"Library/#Static-Load-Models","page":"Component Library","title":"Static Load Models","text":"","category":"section"},{"location":"Library/#Line-Models","page":"Component Library","title":"Line Models","text":"","category":"section"},{"location":"Library/#Transmission-Line-Models","page":"Component Library","title":"Transmission Line Models","text":"","category":"section"},{"location":"Library/#Fault-Models","page":"Component Library","title":"Fault Models","text":"","category":"section"},{"location":"Library/#Ground-Fault-Models","page":"Component Library","title":"Ground Fault Models","text":"","category":"section"},{"location":"generated/ieee39_part3/#ieee39-part3","page":"IEEE39 Part III: Simulation","title":"IEEE39 Bus Tutorial - Part III: Dynamic Simulation","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"This is the third part of the IEEE 39-bus tutorial series:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Part I: Model Creation - Build the network structure with buses, lines, and components\nPart II: Initialization - Perform power flow calculations and dynamic initialization\nPart III: Dynamic Simulation (this tutorial) - Run time-domain simulations and analyze system behavior\nPart IV: Advanced Modeling & Parameter Optimization - Create custom components and optimize system parameters","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"In this tutorial, we'll demonstrate how to perform dynamic simulations of power system disturbances using PowerDynamics.jl. We'll simulate a short circuit fault followed by line disconnection and analyze the system's dynamic response.","category":"page"},{"location":"generated/ieee39_part3/#Short-Circuit-Disturbance-Scenario","page":"IEEE39 Part III: Simulation","title":"Short Circuit Disturbance Scenario","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"We will simulate a three-phase short circuit fault on a transmission line, which is a common and severe disturbance in power systems. The disturbance scenario consists of:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"t = 0.1s: A short circuit occurs on line 11, drastically reducing its impedance\nt = 0.2s: The protective relay trips the line, completely disconnecting it from the system\nt = 0.2s onwards: The system operates with the line permanently out of service","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"This scenario tests the system's ability to:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Survive the initial fault (maintain synchronism)\nStabilize after the line disconnection\nOperate reliably with reduced transmission capacity","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"This script can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"# Loading required packages and setup\nusing PowerDynamics\nusing PowerDynamics.Library\nusing ModelingToolkit\nusing NetworkDynamics\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\n\n# Load the network model from Part I\nEXAMPLEDIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\")\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part1.jl\"))","category":"page"},{"location":"generated/ieee39_part3/#Network-Initialization","page":"IEEE39 Part III: Simulation","title":"Network Initialization","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Before we can run dynamic simulations, we need to initialize the network as described in Part II. This involves solving the power flow and initializing all dynamic components.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"For buses with both generators and loads (buses 31 and 39), we need to add initialization formulas to resolve structural underconstraints by setting the load voltage setpoint equal to the bus voltage magnitude.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"# Add initialization formulas as described in Part II\nformula = @initformula :ZIPLoad₊Vset = sqrt(:busbar₊u_r^2 + :busbar₊u_i^2)\nset_initformula!(nw[VIndex(31)], formula)\nset_initformula!(nw[VIndex(39)], formula)\n\n# Initialize the complete network from power flow solution\ns0 = initialize_from_pf!(nw; verbose=false)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part3/#Short-Circuit-Disturbance-Definition","page":"IEEE39 Part III: Simulation","title":"Short Circuit Disturbance Definition","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"To simulate realistic power system dynamics, we need to introduce a disturbance that will excite the system's dynamic behavior. We'll simulate a short circuit fault on transmission line 11, which connects buses 5 and 8.","category":"page"},{"location":"generated/ieee39_part3/#Understanding-Line-Models-with-Fault-Capability","page":"IEEE39 Part III: Simulation","title":"Understanding Line Models with Fault Capability","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The transmission line models in our network include built-in parameters for fault simulation:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"pibranch₊shortcircuit: When set to 1, this simulates a three-phase to ground short circuit along the line. The position in percentage can be given as a parameter too.\npibranch₊active: When set to 0, this completely disconnects the line from the network (no current flowing into line or out of line, i.e., the line is disconnected at both ends)","category":"page"},{"location":"generated/ieee39_part3/#Callback-Functions-for-Disturbance-Events","page":"IEEE39 Part III: Simulation","title":"Callback Functions for Disturbance Events","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"In order to simulate discrete perturbations, such as enabling a short circuit or disabling a line, we need to use callbacks. Callbacks are a neat feature of DifferentialEquations.jl, which allow you to stop the solver under certain conditions and trigger a user-defined affect function to change the state of the system.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"NetworkDynamics inherits this functionality as well. In addition, ND.jl provides a new type of callback: component callbacks. Those are callbacks which are attached to a single component rather than the full network, bringing the effect handling to the component level.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Here we'll define two component callbacks: one to enable a short circuit at a given time and one to disable the line at a given time.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"# Select the line to be affected by the short circuit\nAFFECTED_LINE = 11\nnothing #hide","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Let's examine the transmission line that will experience the short circuit. This line connects two important buses in the network and its outage will test the system's stability.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Now we define callback functions to model the disturbance sequence:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"# Define callback to enable short circuit at t=0.1s\nVERBOSE_CALLBACK = true #hide\n_enable_short = ComponentAffect([], [:piline₊shortcircuit]) do u, p, ctx\n    if VERBOSE_CALLBACK #hide\n    @info \"Short circuit activated on line $(ctx.src)→$(ctx.dst) at t = $(ctx.t)s\"\n    end #hide\n    p[:piline₊shortcircuit] = 1\nend\nshortcircuit_cb = PresetTimeComponentCallback(0.1, _enable_short)\n\n# Define callback to disconnect line at t=0.2s (fault clearing)\n_disable_line = ComponentAffect([], [:piline₊active]) do u, p, ctx\n    if VERBOSE_CALLBACK #hide\n    @info \"Line $(ctx.src)→$(ctx.dst) disconnected at t = $(ctx.t)s\"\n    end #hide\n    p[:piline₊active] = 0\nend\ndeactivate_cb = PresetTimeComponentCallback(0.2, _disable_line)\n\n# Attach both callbacks to the selected line\nset_callback!(nw, EIndex(AFFECTED_LINE), (shortcircuit_cb, deactivate_cb))\nnothing #hide","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The callbacks are now attached to line 11. During simulation:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"At t=0.1s, the short circuit callback activates, simulating the fault\nAt t=0.2s, the line disconnection callback activates, simulating relay action","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Let's verify the callbacks are properly attached:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"nw[EIndex(AFFECTED_LINE)]","category":"page"},{"location":"generated/ieee39_part3/#Dynamic-Simulation","page":"IEEE39 Part III: Simulation","title":"Dynamic Simulation","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Now we're ready to perform the dynamic simulation. We'll set up and solve an ordinary differential equation (ODE) problem that represents the network's dynamic behavior.","category":"page"},{"location":"generated/ieee39_part3/#Simulation-Setup","page":"IEEE39 Part III: Simulation","title":"Simulation Setup","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The simulation process involves:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Creating the initial state vector from our initialized network\nSetting up the ODE problem with appropriate time span and callbacks\nSolving the ODE using a suitable numerical method\nAnalyzing the results","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Note that we use get_callbacks to collect the component callbacks, transform them into a CallbackSet compatible with the DifferentialEquations.jl ecosystem and pass them to the ODEProblem.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"u0 = NWState(nw) # state is stored in metadata because of mutating init function!\nprob = ODEProblem(nw, uflat(u0), (0.0, 15.0), copy(pflat(u0)); callback=get_callbacks(nw))\n# Solve the ODE using Rodas5P (suitable for stiff differential-algebraic systems)\nsol = solve(prob, Rodas5P());\n@assert SciMLBase.successful_retcode(sol) # ensure the simulation was successful","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The simulation is complete! The sol object contains the time-domain solution of all network variables. We can now analyze how the system responded to the short circuit disturbance.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"tip: Tip\nThe ODEProblem contains a reference to exactly one copy of the flat parameter array. If you use callbacks to change those parameters (as we do), it is advised to copy the parameter array before passing it to the ODEProblem! Otherwise the callback will change our u0 object. Also, this means you need to be careful when using the same prob for multiple subsequent solve calls, as the initial state of the prob object might have changed!","category":"page"},{"location":"generated/ieee39_part3/#Simulation-Results-Overview","page":"IEEE39 Part III: Simulation","title":"Simulation Results Overview","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The solution object contains:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Time-domain trajectories of all state variables (generator angles, voltages, etc.)\nNetwork interface variables (bus voltages, line currents and power flows)\nFull system response from t=0 to t=15 seconds","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Let's examine some key aspects of the system response through various plots.","category":"page"},{"location":"generated/ieee39_part3/#Results-Analysis","page":"IEEE39 Part III: Simulation","title":"Results Analysis","text":"","category":"section"},{"location":"generated/ieee39_part3/#Power-Flow-in-the-Affected-Line","page":"IEEE39 Part III: Simulation","title":"Power Flow in the Affected Line","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"First, let's examine how the power flow through the faulted line changes during the disturbance. This plot shows the most direct impact of our short circuit and line disconnection events.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"let fig = Figure(; size=(800, 400))\n    ax = Axis(fig[1, 1];\n        title=\"Active Power Flow in Line $AFFECTED_LINE During Short Circuit\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Active Power [pu]\")\n\n    # Focus on the disturbance period to see the fault clearly\n    ts = range(0, 0.35, length=1000)\n\n    # Plot power flow at the destination end of the line\n    lines!(ax, ts, sol(ts; idxs=EIndex(AFFECTED_LINE, :src₊P)).u;\n           label=\"Active Power towards src\", linewidth=2)\n    lines!(ax, ts, sol(ts; idxs=EIndex(AFFECTED_LINE, :dst₊P)).u;\n           label=\"Active Power towards dst\", linewidth=2)\n\n    axislegend(ax; position=:rt)\n\n    fig\nend","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Observations:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Normal operation (t < 0.1s): Steady power flow through the line. Power towards destination is positive while power towards source is negative. This means we have net transmission from bus 5 to bus 8.\nShort circuit (0.1s < t < 0.2s): Dramatic power flow change due to the short circuit. Both source and destination show negative power, which means we have active power flowing from both sides towards the short circuit.\nLine disconnection (t > 0.2s): Zero power flow as the line is permanently out of service","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The power absorption during the fault demonstrates the severe electrical stress that short circuits place on the system. The protective relay action at t=0.2s successfully isolates the fault.","category":"page"},{"location":"generated/ieee39_part3/#Voltage-Response-at-Adjacent-Buses","page":"IEEE39 Part III: Simulation","title":"Voltage Response at Adjacent Buses","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Next, let's examine how the buses directly connected to the faulted line respond to the disturbance. These buses experience the most severe voltage impacts during the fault.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"let fig = Figure(; size=(800, 500))\n    ax = Axis(fig[1, 1];\n        title=\"Voltage Magnitudes at Buses Adjacent to Faulted Line\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Voltage Magnitude [pu]\")\n\n    # Full simulation time to see both disturbance and recovery\n    ts = range(0, 15, length=1000)\n\n    # Get the source and destination buses of the affected line\n    src_bus, dst_bus = get_graphelement(nw[EIndex(AFFECTED_LINE)])\n\n    # Plot voltage magnitudes at both ends of the faulted line\n    lines!(ax, ts, sol(ts; idxs=VIndex(src_bus, :busbar₊u_mag)).u;\n           label=\"Bus $src_bus (source)\", linewidth=2)\n    lines!(ax, ts, sol(ts; idxs=VIndex(dst_bus, :busbar₊u_mag)).u;\n           label=\"Bus $dst_bus (destination)\", linewidth=2)\n\n    axislegend(ax; position=:rb)\n    ylims!(ax, 0.85, 1.15)\n\n    fig\nend","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Observations: Both buses experience voltage depression during the short circuit but are able to recover after the short circuit is cleared by disconnection of the line.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The voltage recovery demonstrates the system's ability to adapt to the new network topology after the line outage. The generators' automatic voltage regulators help maintain voltage stability.","category":"page"},{"location":"generated/ieee39_part3/#System-Wide-Voltage-Response","page":"IEEE39 Part III: Simulation","title":"System-Wide Voltage Response","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"To get a complete picture of the system's response, let's examine the voltage profiles across all 39 buses. This \"spaghetti plot\" shows how the disturbance propagates through the entire network.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"let fig = Figure(; size=(800, 600))\n    ax = Axis(fig[1, 1];\n        title=\"Voltage Magnitudes Across All 39 Buses\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Voltage Magnitude [pu]\")\n\n    # Full simulation time range\n    ts = range(0, 15, length=1000)\n\n    # Plot voltage magnitude for all buses\n    for i in 1:39\n        voltage_data = sol(ts; idxs=VIndex(i, :busbar₊u_mag)).u\n        lines!(ax, ts, voltage_data; linewidth=2)\n    end\n    ylims!(ax, 0.85, 1.15)\n    fig\nend","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Once again, we see how all bus voltages are affected by the short circuit and the overall voltage drops. However, after the fault is cleared, the system achieves a synchronous steady-state again.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"initialization/#Powergrid-Initialization","page":"Initialization","title":"Powergrid Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Initialization of power grid simulations follows a multi-step approach that combines steady-state power flow analysis with dynamic component initialization. PowerDynamics.jl provides a structured framework for this process, building on the initialization capabilities of NetworkDynamics.jl.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"For general background on NetworkDynamics initialization concepts, see the NetworkDynamics Initialization Guide.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This document is a technical description of the process, for a hands-on example which goes through the initialization process of a full network check out the Part II of the  the IEEE39 Bus Example.","category":"page"},{"location":"initialization/#Overview","page":"Initialization","title":"Overview","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Power grid initialization involves finding valid initial conditions that satisfy both:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Power flow constraints: Electrical power balance equations (steady-state)\nDynamic constraints: Initial conditions for dynamic components (generators, controllers, etc.)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This is typically achieved through a two-step process:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Solve the power flow problem to determine steady-state electrical conditions\nInitialize dynamic components using the power flow solution as boundary conditions, i.e. find the initial states/parameters of the dynamical models in a way, that they are in a steady state at the powerflow solution.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This follows the Two-Step Initialization Pattern described in NetworkDynamics.jl, specialized for power grid applications.","category":"page"},{"location":"initialization/#Multi-Step-Initialization-Process","page":"Initialization","title":"Multi-Step Initialization Process","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"nw = get_dynamic_network(...)\n\n# extract powerflow model       # ⎫                 ⎫\npfnw = powerflow_model(nw)      # │                 │\n# initial guess for powerflow   # ⎬ solve_powerflow │\npfs0 = NWState(pfnw)            # │                 │\n# find fixpoint for pf model    # │                 │\npfs = find_fixpoint(pfnw, pfs0) # ⎭                 ⎬ initialize_from_pf[!]\n# extract interface (u/i values)#                   │\ninterf = interface_values(pfs)  #                   │\n# initialize around powerflow   #                   │\ninitialize_componentwise[!](    #                   │\n    nw;                         #                   │\n    default_overrides = interf  #                   │\n)                               #                   ⎭","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This low-level step-wise interface allows users full control and complete management of the initialization process. However, PowerDynamics.jl also provides higher-level wrapper functions solve_powerflow and initialize_from_pf that combine these steps for common use cases.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Note: This workflow above is slightly simplified, see Integration with Initialization Process below for the full set of commands.","category":"page"},{"location":"initialization/#Step-1:-Power-Flow-Model-Extraction","page":"Initialization","title":"Step 1: Power Flow Model Extraction","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The first step creates a simplified, algebraic representation of the power grid that captures the essential power flow relationships:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"pfnw = powerflow_model(nw)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This function extracts the power flow network from the full dynamic network model, creating a steady-state representation. The power flow network itself is also a Network in the NetworkDynamics.jl sense.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The powerflow_model function determines the appropriate power flow representation for each dynamic Node and LineModel by: checking if :pfmodel metadata is set, which points to a different component model specifically designed for power flow analysis","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"If the :pfmodel is not set, it assumes that the same model is used for both power flow and dynamic simulation. This is the case for purely static models such as PiLines or PQ-Loads.","category":"page"},{"location":"initialization/#Step-2:-Power-Flow-Solution","page":"Initialization","title":"Step 2: Power Flow Solution","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The power flow problem is solved using NetworkDynamics.jl's find_fixpoint function, which internally uses NonlinearSolve.jl:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"pfs0 = NWState(pfnw)            # Initial guess for power flow state\npfs = find_fixpoint(pfnw, pfs0) # Solve power flow equations","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This step finds the steady-state solution where:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Active and reactive power are balanced at each bus\nGeneration and load are in equilibrium","category":"page"},{"location":"initialization/#Step-3:-Interface-Value-Extraction","page":"Initialization","title":"Step 3: Interface Value Extraction","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The power flow solution provides boundary conditions for dynamic component initialization:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"interf = interface_values(pfs)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This extracts voltage magnitudes, voltage angles, and current flows at each network node, which serve as interface constraints for the dynamic components.","category":"page"},{"location":"initialization/#Step-4:-Component-wise-Dynamic-Initialization","page":"Initialization","title":"Step 4: Component-wise Dynamic Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Finally, each dynamic component is initialized individually using the power flow solution as boundary conditions:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"initialize_componentwise!(nw; default_overrides = interf)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This step leverages NetworkDynamics.jl's component-wise initialization to determine free internal states and parameters (such as rotor angles or controller setpoints), such that the steady state of the overall network matches the flows from the power flow solution (i.e. all currents and voltages match).","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"For details on how component initialization works, see the Single Component Initialization section in NetworkDynamics.jl.","category":"page"},{"location":"initialization/#Advanced-Component-Initialization","page":"Initialization","title":"Advanced Component Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"In some cases, the standard initialization process may not be sufficient. For example, when component initialization constraints cannot be expressed solely in terms of interface variables (voltages and currents), but need access to other variables from the complete power flow solution.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"NetworkDynamics.jl provides general InitFormulas and InitConstraints for advanced component initialization. PowerDynamics.jl extends these concepts with power flow-aware variants that can access the complete power flow solution.","category":"page"},{"location":"initialization/#PFInitConstraints-vs-PFInitFormulas","page":"Initialization","title":"PFInitConstraints vs PFInitFormulas","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Method Purpose Usage\nPFInitConstraint Add constraint equations that must be satisfied When you need to enforce specific relationships between variables\nPFInitFormula Set default initial values directly When you need to initialize variables based on power flow results","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Both methods can access any variable from the solved power flow state, not just interface variables. You get access to states, parameters and observables from the power flow model of the same component.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Key difference: Constraints increase the number of equations that must be satisfied during initialization, while formulas reduce the number of free variables by setting additional default values.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"These are power flow-aware extensions of NetworkDynamics.jl's standard InitConstraint and InitFormula mechanisms.","category":"page"},{"location":"initialization/#Power-Flow-Dependent-Initialization-Constraints","page":"Initialization","title":"Power Flow Dependent Initialization Constraints","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"PFInitConstraint adds constraint equations to the initialization problem. Unlike regular InitConstraints from NetworkDynamics.jl, PFInitConstraints can access power flow variables.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The @pfinitconstraint macro provides convenient syntax for defining these constraints:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"# Single constraint accessing both component and power flow variables\nconstraint = @pfinitconstraint :dynamicload₊P - @pf(:PQ₊Pset)\n\n# Multiple constraints in a single block\nconstraints = @pfinitconstraint begin\n    :pibranch₊X - @pf(:pibranch₊X) # \"copy\" parameters from pf\n    :P_gen - @pf(:P_load)          # Power balance constraint\n    :AVR₊Vset - :busbar₊u_mag      # init controller setpoints\nend\n\n# Attach to a component\nset_pfinitconstraint!(my_generator, constraints)","category":"page"},{"location":"initialization/#Power-Flow-Dependent-Initialization-Formulas","page":"Initialization","title":"Power Flow Dependent Initialization Formulas","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"PFInitFormula sets default initial values for variables using both component and power flow variables. Unlike constraints, formulas directly assign values without adding equations to solve.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The @pfinitformula macro provides convenient syntax:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"# Single formula - set variable from component variables\n@pfinitformula :Vset = sqrt(:u_r^2 + :u_i^2)\n\n# Formula using power flow variables\n@pfinitformula :Pset = @pf(:generator_power)\n\n# Multiple formulas in a block\n@pfinitformula begin\n    :Vset = sqrt(:u_r^2 + :u_i^2)\n    :Pset = @pf(:generator_power)\nend\n\n# Attach to a component\nset_pfinitformula!(my_generator, formulas)","category":"page"},{"location":"initialization/#Integration-with-Initialization-Process","page":"Initialization","title":"Integration with Initialization Process","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Both PFInitConstraints and PFInitFormulas are automatically handled during initialize_from_pf[!]:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Power flow solution: The power flow equations are solved first\nSpecialization: All PFInitConstraints and PFInitFormulas are converted to regular InitConstraints and InitFormulas by \"specializing\" them with the power flow solution (i.e. the @pf(:x) blocks are replaced by the actual values)\nComponent initialization: The specialized constraints and formulas are passed to NetworkDynamics.jl's component initialization","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This process is transparent to the user - simply define your power flow dependent initialization methods and use initialize_from_pf[!] as usual.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The underlying mechanism follows NetworkDynamics.jl's component initialization pipeline, with the power flow solution providing additional context for constraint and formula evaluation.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The extended initialization workflow (automatically done in initialize_from_pf[!]) looks like this:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"nw = get_dynamic_network(...)\npfnw = powerflow_model(nw)\npfs0 = NWState(pfnw)\npfs = find_fixpoint(pfnw, pfs0)\ninterf = interface_values(pfs)\n\n# specialize the constraints and formulas and pass them down\npfconstraints = specialize_pfinitconstraints(nw, pfs)\npfformulas    = specialize_pfinitformulas(nw, pfs)\ninitialize_componentwise[!](\n    nw;\n    default_overrides = interf,\n    additional_initconstraints = pfconstraints,\n    additional_initformulas = pfformulas,\n)","category":"page"},{"location":"generated/ieee39_part4/#ieee39-part4","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Bus Tutorial - Part IV: Advanced Modeling & Parameter Optimization","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"This is the fourth and final part of the IEEE 39-bus tutorial series:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Part I: Model Creation - Build the network structure with buses, lines, and components\nPart II: Initialization - Perform power flow calculations and dynamic initialization\nPart III: Dynamic Simulation - Run time-domain simulations and analyze system behavior\nPart IV: Advanced Modeling & Parameter Optimization (this tutorial) - Create custom components and optimize system parameters","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"In this tutorial, we'll demonstrate advanced PowerDynamics.jl capabilities by:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Creating a custom droop-controlled inverter component\nIntegrating it into the IEEE 39-bus system\nOptimizing its parameters to improve system performance","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"This tutorial showcases custom component creation and the integration with Julia's optimization ecosystem for parameter tuning.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"This script can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"note: Note\nThis tutorial is designed as a pedagogical example. It does not necessarily represent a realistic power system model and analysis, but rather serves to demonstrate the available tools while remaining relatively simple and concise.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"# Loading required packages and setup\nusing PowerDynamics\nusing PowerDynamics.Library\nusing ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\nusing NetworkDynamics\nusing NetworkDynamics: SII\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing SciMLSensitivity\nusing Optimization\nusing OptimizationOptimisers\nusing CairoMakie\nusing LinearAlgebra\nusing Graphs\nusing SparseConnectivityTracer\nusing Sparspak\n\n# Load the network models from previous parts\nEXAMPLEDIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\")\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part1.jl\"))  # Creates the basic network model\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part3.jl\"))  # Provides initialized network and reference solution\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/#Integration-of-a-Droop-Controlled-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Integration of a Droop-Controlled Inverter","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"In this section, we'll modify our network by adding a droop-controlled inverter.","category":"page"},{"location":"generated/ieee39_part4/#Mathematical-Background","page":"IEEE39 Part IV: Parameter Tuning","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"The droop-controlled inverter implements a decentralized control strategy commonly used in microgrids and renewable energy integration. It establishes the following relationships:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Power Measurement:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"beginaligned\nP_meas = u_r cdot i_r + u_i cdot i_i\nQ_meas = u_i cdot i_r - u_r cdot i_i\nendaligned","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Power Filtering (Low-pass filtering for measurement noise reduction):","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"beginaligned\ntau cdot fracdP_filtdt = P_meas - P_filt \ntau cdot fracdQ_filtdt = Q_meas - Q_filt\nendaligned","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Droop Control:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"beginaligned\nomega = omega_0 - K_p cdot (P_filt - P_set) \nV = V_set - K_q cdot (Q_filt - Q_set)\nendaligned","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Voltage Angle Dynamics:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"fracddeltadt = omega - omega_0","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Output Voltage:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"beginaligned\nu_r = V cdot cos(delta) \nu_i = V cdot sin(delta)\nendaligned","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"These equations implement:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Frequency-Active Power Coupling (f-P): Frequency decreases when active power exceeds setpoint\nVoltage-Reactive Power Coupling (V-Q): Voltage decreases when reactive power exceeds setpoint","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"This mimics the natural behavior of synchronous generators and enables stable power sharing in islanded operation.","category":"page"},{"location":"generated/ieee39_part4/#Definition-of-the-Droop-Inverter-Component","page":"IEEE39 Part IV: Parameter Tuning","title":"Definition of the Droop Inverter Component","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Network components in PowerDynamics must follow the Injector Interface - they connect to the network through a single Terminal:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"      ┌──────────────────────────┐\n(t)   │                          │\n o←───┤ Droop Inverter Equations │\n      │                          │\n      └──────────────────────────┘","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We can define the following MTKModel to represent the droop inverter:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"@mtkmodel DroopInverter begin\n    @components begin\n        terminal = Terminal()\n    end\n\n    @parameters begin\n        Pset, [description=\"Active power setpoint\", guess=1]\n        Qset, [description=\"Reactive power setpoint\", guess=0]\n        Vset, [description=\"Voltage magnitude setpoint\", guess=1]\n        ω₀=1, [description=\"Nominal frequency\"]\n        Kp=1, [description=\"Active power droop coefficient\"]\n        Kq=0.1, [description=\"Reactive power droop coefficient\"]\n        τ_p = 1, [description=\"Active Power filter time constant\"]\n        τ_q = 1, [description=\"Reactive Power filter time constant\"]\n    end\n\n    @variables begin\n        Pmeas(t), [description=\"Measured active power\", guess=1]\n        Qmeas(t), [description=\"Measured reactive power\", guess=0]\n        Pfilt(t), [description=\"Filtered active power\", guess=1]\n        Qfilt(t), [description=\"Filtered reactive power\", guess=1]\n        ω(t), [description=\"Frequency\"]\n        δ(t), [description=\"Voltage angle\", guess=0]\n        V(t), [description=\"Voltage magnitude\"]\n    end\n\n    @equations begin\n        # Power measurement from terminal quantities\n        Pmeas ~ terminal.u_r*terminal.i_r + terminal.u_i*terminal.i_i\n        Qmeas ~ terminal.u_i*terminal.i_r - terminal.u_r*terminal.i_i\n\n        # First-order low-pass filtering\n        τ_p * Dt(Pfilt) ~ Pmeas - Pfilt\n        τ_q * Dt(Qfilt) ~ Qmeas - Qfilt\n\n        # Droop control equations\n        ω ~ ω₀ - Kp * (Pfilt - Pset)  # Frequency decreases with excess power\n        V ~ Vset - Kq * (Qfilt - Qset)  # Voltage decreases with excess reactive power\n\n        # Voltage angle dynamics\n        Dt(δ) ~ ω - ω₀\n\n        # Output voltage components\n        terminal.u_r ~ V*cos(δ)\n        terminal.u_i ~ V*sin(δ)\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/#Creating-a-Bus-with-the-Droop-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Creating a Bus with the Droop Inverter","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Following the descriptions in Modeling Concepts, we build an MTKBus using the droop as the single injector and then compile the bus model, similar to how we define the templates in part I:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"           ╔═════════════════════════╗\n           ║ Droop (compiled)        ║\n Network   ║  ┌────────────────────┐ ║\ninterface  ║  │ MTKBus             │ ║\n current ────→│┌──────┐ ┌────────┐ │ ║\n           ║  ││BusBar├o┤Inverter│ │ ║\n voltage ←────│└──────┘ └────────┘ │ ║\n           ║  └────────────────────┘ ║\n           ╚═════════════════════════╝","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"@named inverter = DroopInverter()\nmtkbus = MTKBus(inverter)\ndroop_bus_template = Bus(mtkbus; name=:DroopInverter)","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We see that the droop inverter has 3 free parameters (you can check free_p(droop_bus_template) or dump_initial_state(droop_bus_template)). Therefore, similar to what we did in Part II, we need to help the initialization by attaching an additional initialization formula to the bus:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"set_initformula!(\n    droop_bus_template,\n    @initformula(:inverter₊Vset = sqrt(:busbar₊u_r^2 + :busbar₊u_i^2))\n)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/#Network-Modification-with-Droop-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Network Modification with Droop Inverter","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We'll replace bus 32 (originally a controlled generator bus) with our new droop inverter bus.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"DROOP_BUS_IDX = 32\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"To do so, we first collect all the \"old\" vertex and edge models.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"tip: Tip\nWe copy the components, to create individual instances for the new network. Since all the metadata (like the default values, initialize values and so on) are stored in the component models, we would otherwise share metadata between the old and the new network, which can lead to unexpected results.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"vertex_models = [copy(nw[VIndex(i)]) for i in 1:nv(nw)];\nedge_models = [copy(nw[EIndex(i)]) for i in 1:ne(nw)];\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Now we need to replace the original bus model at index DROOP_BUS_IDX with our new droop inverter bus. However, we don't want to lose the original power flow model associated with this bus, so we need to attach it to the droop bus model:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"original_pfmodel = get_pfmodel(vertex_models[DROOP_BUS_IDX])\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We can then use the Bus constructor to essentially copy the droopbustemplate and adjust some properties, like the powerflow model and the vertex index.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"droop_bus = Bus(droop_bus_template; pf=original_pfmodel, vidx=DROOP_BUS_IDX)","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We then replace the original bus model in the array with our droop bus and build a network again:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"vertex_models[DROOP_BUS_IDX] = droop_bus\nnw_droop = Network(vertex_models, edge_models)\nset_jac_prototype!(nw_droop; remove_conditions=true)","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Additionally, we've set the jacobian prototype for performance gains during simulation and optimization, see NetworkDynamics docs on Sparsity Detection.","category":"page"},{"location":"generated/ieee39_part4/#Network-Initialization-with-Droop-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Network Initialization with Droop Inverter","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"The modified network requires the same initialization steps as the original:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Power flow solution\nDynamic component initialization","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"This all happens within initialize_from_pf!:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"s0_droop = initialize_from_pf!(nw_droop; verbose=false)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Let's examine the initialized state of our droop inverter:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"dump_initial_state(nw_droop[VIndex(DROOP_BUS_IDX)]; obs=false)","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We see that the filtered powers match the setpoints (steady state), and both P and V_mathrmset are initialized according to the parameters of the PV powerflow model.","category":"page"},{"location":"generated/ieee39_part4/#Simulation-with-Droop-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Simulation with Droop Inverter","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Now we'll simulate the modified network and compare it with the original system response:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"prob_droop = ODEProblem(nw_droop, uflat(s0_droop), (0.0, 15.0), copy(pflat(s0_droop));\n                       callback=get_callbacks(nw_droop))\nsol_droop = solve(prob_droop, Rodas5P())\n@assert SciMLBase.successful_retcode(sol_droop)","category":"page"},{"location":"generated/ieee39_part4/#Comparison-of-System-Responses","page":"IEEE39 Part IV: Parameter Tuning","title":"Comparison of System Responses","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Let's compare how the droop inverter affects the system's response to the short circuit disturbance:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"let fig = Figure(; size=(1000, 600))\n    selected_buses = [3, 4, 25, DROOP_BUS_IDX]  # Representative buses including the droop bus\n    ts = range(0, 10, length=1000)\n\n    for (i, bus) in enumerate(selected_buses)\n        row, col = divrem(i-1, 2) .+ (1, 1)\n        ax = Axis(fig[row, col];\n                  title=\"Voltage Magnitude at Bus $bus\" * (bus==DROOP_BUS_IDX ? \" (droop bus)\" : \"\"),\n                  xlabel=\"Time [s]\",\n                  ylabel=\"Voltage [pu]\")\n\n        # Original system response\n        lines!(ax, ts, sol(ts; idxs=VIndex(bus, :busbar₊u_mag)).u;\n               label=\"Original System\", color=:blue, linewidth=2)\n\n        # Droop inverter system response\n        lines!(ax, ts, sol_droop(ts; idxs=VIndex(bus, :busbar₊u_mag)).u;\n               label=\"With Droop Inverter\", color=:red, linewidth=2)\n\n        ylims!(ax, 0.85, 1.15)\n        i == 1 && axislegend(ax; position=:rb)\n    end\n\n    fig\nend","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We see that the overall system reacts similarly but distinctly differently to the identical disturbance.","category":"page"},{"location":"generated/ieee39_part4/#Parameter-Optimization","page":"IEEE39 Part IV: Parameter Tuning","title":"Parameter Optimization","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"To showcase advanced capabilities of the SciML-ecosystem and the integration with PowerDynamics.jl, we now want to try to tune the droop inverter parameters so that the overall system behavior more closely resembles the original behavior, i.e., to reduce the difference between the system with generator and the system with droop inverter.","category":"page"},{"location":"generated/ieee39_part4/#Optimization-Problem-Formulation","page":"IEEE39 Part IV: Parameter Tuning","title":"Optimization Problem Formulation","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We define a loss function that measures the deviation between the original system response and the modified system response:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"L(p) = sum_it x_ref(t)_i - x(tp)_i^2","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Where we have","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Parameters p = K_p K_q tau to be optimized\nthe reference solution x_ref(t) (original system)\nthe solution of the modified system x(tp) with updated parameters p","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Goal: Find parameters p that minimize this loss function, making the droop inverter system behave as closely as possible to the original system.","category":"page"},{"location":"generated/ieee39_part4/#Setting-Up-the-Optimization","page":"IEEE39 Part IV: Parameter Tuning","title":"Setting Up the Optimization","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"First, we define the reference solution and identify the tunable parameters.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We probe the original solution at fixed timepoints, exporting u_r and u_i for every bus:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"opt_ref = sol(0.3:0.1:10, idxs=[VIndex(1:39, :busbar₊u_r), VIndex(1:39, :busbar₊u_i)])\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Next, we need to identify the \"tunable\" parameters. This is a bit tricky, because the overall nw_droop has 1271 parameters, so we need to find the indices of the parameters we want to tune in the flat parameter array. We can do so, by leveraging NetworkDynamics implementation of the SymbolicIndexingInterface: tunable_parameters = [:inverter₊Kp, :inverter₊Kq, :inverter₊τ]","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"tunable_parameters = [:inverter₊Kp, :inverter₊Kq, :inverter₊τ_p, :inverter₊τ_q]\ntp_idx = SII.parameter_index(sol_droop, VIndex(DROOP_BUS_IDX, tunable_parameters))","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We also get their initial values, which we use as the starting point for the optimization.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"p0 = sol_droop(sol_droop.t[begin], idxs=collect(VIndex(DROOP_BUS_IDX, tunable_parameters)))","category":"page"},{"location":"generated/ieee39_part4/#Loss-Function-Implementation","page":"IEEE39 Part IV: Parameter Tuning","title":"Loss Function Implementation","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"The loss function simulates the system with given parameters and compares the result to the reference:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"function loss(p)\n    # Create parameter vector for the full system\n    # allp = similar(p, pdim(nw_droop)) # create a vector of the full length\n    allp = similar(p, length(s0_droop.p)) # create a vector of the full length\n    allp .= pflat(s0_droop.p) # copy all \"initial\" parameters to that vector\n    allp[tp_idx] .= p  # Update only the tunable parameters with the parameters for the given optimization iteration\n\n    # Solve the system with new parameters\n    _sol = solve(prob_droop, Rodas5P(autodiff=true);\n        p = allp,\n        saveat = opt_ref.t,\n        tspan=(0.0, opt_ref.t[end]),\n        initializealg = SciMLBase.NoInit(),\n        abstol=0.01,\n        reltol=0.01\n    )\n\n    # Return infinite loss if simulation failed\n    if !SciMLBase.successful_retcode(_sol)\n        @warn \"Retcode $(_sol.retcode) indicates a failed simulation, returning Inf loss\"\n        return Inf\n    end\n\n    # Extract solution at reference time points\n    x = _sol(opt_ref.t; idxs=[VIndex(1:39, :busbar₊u_r), VIndex(1:39, :busbar₊u_i)])\n\n    # Compute L2 norm of the difference\n    res = opt_ref.u - x.u\n    l2loss = sum(abs2, reduce(vcat, res))\nend\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/#Optimization-Execution","page":"IEEE39 Part IV: Parameter Tuning","title":"Optimization Execution","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We use the Optimization.jl ecosystem with the Adam optimizer:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"# Create optimization function with automatic differentiation\noptf = Optimization.OptimizationFunction((x, p) -> loss(x), Optimization.AutoForwardDiff())\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"To better monitor the optimization progress, we want to store the optimized parameters at every iteration of the optimizer. We can do so by defining a callback function for the optimizer:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"optimization_states = Any[] # global variable to store the optimization parameters at each step\ncallback = function (state, l)\n    push!(optimization_states, state)\n    println(\"Iteration $(state.iter): loss = $l\\t p = $(state.u)\")\n    return false  # Continue optimization\nend\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"That callback will snapshot the current parameter values at every step of the gradient descent.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"With that, we can run the optimization:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"optprob = Optimization.OptimizationProblem(optf, p0; callback)\nVERBOSE_CALLBACK = false #hide\n\n@time optsol = Optimization.solve(optprob, Optimisers.Adam(0.06), maxiters = 50)\n\nprintln(\"\\nOptimization completed!\")\nprintln(\"Initial parameters: \", p0)\nprintln(\"Optimized parameters: \", optsol.u)\nprintln(\"Initial loss: \", loss(p0))\nprintln(\"Final loss: \", loss(optsol.u))\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/#Optimization-Results-Analysis","page":"IEEE39 Part IV: Parameter Tuning","title":"Optimization Results Analysis","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Let's visualize how the optimization improved the system behavior:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"function plot_optimization_comparison(p_initial, p_current)\n    fig = Figure(; size=(1200, 800))\n    selected_buses = [3, 4, 25, DROOP_BUS_IDX]\n    ts = range(0, 10, length=1000)\n\n    # Simulate with optimized parameters\n    allp_opt = @lift let\n        _p = copy(pflat(s0_droop))\n        _p[tp_idx] .= $p_current\n        _p\n    end\n    sol_opt = @lift solve(prob_droop, Rodas5P(); p=$allp_opt)\n\n\n    for (i, bus) in enumerate(selected_buses)\n        row, col = divrem(i-1, 2) .+ (1, 1)\n        ax = Axis(fig[row, col];\n                  title=\"Voltage Magnitude at Bus $bus\" * (bus==DROOP_BUS_IDX ? \" (droop bus)\" : \"\"),\n                  xlabel=\"Time [s]\",\n                  ylabel=\"Voltage [pu]\")\n\n        # Reference (original system)\n        lines!(ax, ts, sol(ts; idxs=VIndex(bus, :busbar₊u_mag)).u;\n               label=\"Reference\", linestyle=:solid, color=:blue, linewidth=2)\n\n        # Initial droop parameters\n        lines!(ax, ts, sol_droop(ts; idxs=VIndex(bus, :busbar₊u_mag)).u;\n               label=\"Initial Droop\", linestyle=:dash, color=:red, linewidth=2)\n\n        # Optimized droop parameters\n        dat = @lift $(sol_opt)(ts; idxs=VIndex(bus, :busbar₊u_mag)).u\n        lines!(ax, ts, dat; label=\"Optimized Droop\", color=:green, linewidth=2)\n\n        ylims!(ax, 0.85, 1.15)\n        i == 1 && axislegend(ax; position=:rb)\n    end\n\n    fig\nend\n\npobs = Observable(p0)\ncomparison_fig = plot_optimization_comparison(p0, pobs)\nrecord(comparison_fig, \"parameter_evolution.mp4\", optimization_states; framerate=10) do s\n    pobs[] = s.u\nend\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"(Image: timeseries evolution animation)","category":"page"},{"location":"generated/ieee39_part4/#Parameter-Evolution-During-Optimization","page":"IEEE39 Part IV: Parameter Tuning","title":"Parameter Evolution During Optimization","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Let's see how each parameter changed during the optimization process:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"let fig = Figure(; size=(1000, 800))\n    param_names = [\"Kp\", \"Kq\", \"τ_p\", \"τ_q\"]\n    for (i, param_name) in enumerate(param_names)\n        row = (i-1) ÷ 2 + 1\n        col = (i-1) % 2 + 1\n        ax = Axis(fig[row, col];\n                  title=\"Parameter Evolution: $param_name\",\n                  xlabel=\"Iteration\",\n                  ylabel=\"Parameter Value\")\n\n        # Extract parameter values over iterations\n        param_values = [state.u[i] for state in optimization_states[1:end-1]]\n        iterations = [state.iter for state in optimization_states[1:end-1]]\n\n        scatterlines!(ax, iterations, param_values; linewidth=3, markersize=6, color=:blue)\n\n        # Mark initial and final values\n        hlines!(ax, [p0[i]]; linestyle=:dash, color=:gray, alpha=0.7)\n        text!(ax, 1, p0[i]; text=\"Initial: $(round(p0[i], digits=3))\",\n              fontsize=10, color=:gray)\n\n        lossax = Axis(fig[row, col],\n            yticklabelcolor=:black,\n            yaxisposition = :right,\n            ylabel=\"loss\", yscale=log10,\n            xgridvisible=false, ygridvisible=false\n        )\n        scatterlines!(\n            lossax,\n            iterations,\n            [loss(s.u) for s in optimization_states[1:end-1]],\n            color=:black, linewidth=1, markersize=3,\n        )\n    end\n    fig\nend","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ModelingConcepts/#Modeling-Concepts","page":"Modeling Concepts","title":"Modeling Concepts","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"In general, PowerDynamics models power grids as a set of dynamical systems for both nodes and edges on a graph. Check out the Mathematical Model documentation of NetworkDynamics for the underlying concepts.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The simulation happens entirely in a synchronous dq-frame. Due to their conceptual similarity to complex phasors, variables in this global dq-frame are referenced by subscripts _r and _i (for real and imaginary). This helps distinguish the variables from local dq frames, e.g. a generator model might transform u_r and u_i into u_d and u_q.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Both edge and node models are so-called input-output-systems: the edges receive the voltage of adjacent nodes as an input, the nodes receive the currents on adjacent edges as an input. In general, this leads to the following structure of a bus/node model:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"beginaligned\nM_mathrm vfracmathrmdmathrmdtx_mathrm v = f^mathrm vleft(x^mathrm v sum_kbeginbmatrixi^k_r i^k_iendbmatrix p_mathrm v tright)\nbeginbmatrixu_r u_iendbmatrix = g^mathrm v(x^mathrmvp_mathrm v t)\nendaligned","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"where M_mathrm v is the (possibly singular) mass-matrix, x_mathrm v are the internal states and p_mathrm v are parameters. Function f_mathrm v describes the time evolution of the internal states while output equation g_mathrm v defines the output voltage. The input for the system is the sum of all inflowing currents from adjacent lines k. Note how vertices are modeled as one-port systems, i.e. they receive the accumulated current from all connected lines, they can't distinguish which line provides which current. For special cases, this limitation might be mitigated using External Inputs.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"note: Nodal dynamics include injectors\nAn important distinction between our modeling and the modeling in many other libraries is that we include the injector dynamics inside the node dynamics. I.e. if you have a bus with a load and a generator, the overall node dynamics will include both machine and load dynamics within their equations. The modularity and model reuse on the bus level is provided by ModelingToolkit.jl integration.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The edge model on the other hand looks like this:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"beginaligned\nM_mathrm efracmathrmdmathrmdtx_mathrm e = f_mathrm eleft(x_mathrm e beginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix beginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrixp_mathrme tright)\nbeginbmatrixi_r^mathrmsrci_i^mathrmsrcendbmatrix = g^mathrmsrc_mathrm eleft(x_mathrm e beginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix beginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrix p_mathrme tright)\nbeginbmatrixi_r^mathrmdsti_i^mathrmdstendbmatrix = g^mathrmdst_mathrm eleft(x_mathrm e beginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix beginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrix p_mathrme tright)\nendaligned","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"There are a few notable differences: Edges are two port systems, they have two distinct inputs and two distinct outputs. Namely, they receive the dq voltage from both source and destination end and define the current for both ends separately. In very simple systems without losses, those output currents might be just antisymmetric, in general cases however the current on both ends can differ drastically.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"note: Note\nSource and destination end of a line are purely conventional. It has nothing to do with the actual flow direction. Per convention from Graphs.jl, edges in undirected graphs always go from vertex with lower index to vertex with higher index, i.e. 15 to 23 never 23 to 15.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The above descriptions are important to understand what's happening inside the package. However, since we use ModelingToolkit to define the individual models a lot of this complexity is hidden from the user. In the following, we'll go through the most important concepts when designing models using ModelingToolkit.","category":"page"},{"location":"ModelingConcepts/#Relationship-between-ModelingToolkit-and-NetworkDynamics","page":"Modeling Concepts","title":"Relationship between ModelingToolkit and NetworkDynamics","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A crucial part of using this Library is understanding the relationship between ModelingToolkit models and NetworkDynamics.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"In a nutshell, ModelingToolkit models are symbolic models, i.e. they consist of symbolic equations which are not yet \"compiled\" for use as a numeric model. The modeling in MTK is very flexible and similar to the Modelica language. What we need in the end is models in the structure defined in the equations above. For that, we need the MTK Models to have a specific structure. Then we can use the Bus and Line function to compile the MTK models and create EdgeModel and VertexModel objects from them. Those objects are not symbolic anymore but compiled numeric versions of the symbolically created systems.","category":"page"},{"location":"ModelingConcepts/#ModelingToolkit-Models","page":"Modeling Concepts","title":"ModelingToolkit Models","text":"","category":"section"},{"location":"ModelingConcepts/#Terminal","page":"Modeling Concepts","title":"Terminal","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The Terminal─Connector is an important building block for every model. It represents a connection point with constant voltage in dq─coordinates u_r and u_i and enforces the Kirchhoff constraints sum(i_r)=0 and sum(i_i)=0.","category":"page"},{"location":"ModelingConcepts/#Modeling-of-Buses","page":"Modeling Concepts","title":"Modeling of Buses","text":"","category":"section"},{"location":"ModelingConcepts/#Injector-Interface","page":"Modeling Concepts","title":"Model class Injector","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"An injector is a class of components with a single Terminal() (called :terminal). Examples for injectors might be Generators, Shunts, Loads.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"      ┌───────────┐\n(t)   │           │\n o←───┤  Injector │\n      │           │\n      └───────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The current for injectors is always in injector convention, i.e. positive currents flow out of the injector towards the terminal.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"note: Model classes\nModel \"classes\" are nothing formalized. In this document, a model class is just a description for some System from ModelingToolkit.jl, which satisfies certain requirements. For example, any System is considered an \"Injector\" if it contains a connector Terminal() called :terminal.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: definition of PQ load as injector\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\n@mtkmodel MyPQLoad begin\n    @components begin\n        terminal = Terminal()\n    end\n    @parameters begin\n        Pset, [description=\"Active Power demand\"]\n        Qset, [description=\"Reactive Power demand\"]\n    end\n    @variables begin\n        P(t), [description=\"Active Power\"]\n        Q(t), [description=\"Reactive Power\"]\n    end\n    @equations begin\n        P ~ terminal.u_r*terminal.i_r + terminal.u_i*terminal.i_i\n        Q ~ terminal.u_i*terminal.i_r - terminal.u_r*terminal.i_i\n        # if possible, it's better for the solver to explicitly provide algebraic equations for the current\n        terminal.i_r ~ (Pset*terminal.u_r + Qset*terminal.u_i)/(terminal.u_r^2 + terminal.u_i^2)\n        terminal.i_i ~ (Pset*terminal.u_i - Qset*terminal.u_r)/(terminal.u_r^2 + terminal.u_i^2)\n    end\nend\nMyPQLoad(name=:pqload) #hide\nnothing #hide","category":"page"},{"location":"ModelingConcepts/#MTKBus-Interface","page":"Modeling Concepts","title":"Model class MTKBus","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A MTKBus is a class of models, which are used to describe the dynamic behavior of a full bus in a power grid. Each MTKBus must contain a predefined model of type BusBar() (named :busbar). This busbar represents the connection point to the grid. Optionally, it may contain various injectors. If there are no injectors, the model just describes a junction bus, i.e. a Bus that just satisfies the Kirchhoff constraint for the flows of connected lines.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":" ┌───────────────────────────────────┐\n │ MTKBus             ┌───────────┐  │\n │  ┌──────────┐   ┌──┤ Generator │  │\n │  │          │   │  └───────────┘  │\n │  │  BusBar  ├───o                 │\n │  │          │   │  ┌───────────┐  │\n │  └──────────┘   └──┤ Load      │  │\n │                    └───────────┘  │\n └───────────────────────────────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Sometimes it is not possible to connect all injectors directly but instead one needs or wants Branches between the busbar and injector terminal. As long as the :busbar is present at the toplevel, there are few limitations on the overall model complexity.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"For simple models (direct connections of a few injectors) it is possible to use the convenience method MTKBus(injectors...) to create the composite model based on provided injector models.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: definition of a Bus containing a swing equation and a load\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\n@mtkmodel MyMTKBus begin\n    @components begin\n        busbar = BusBar()\n        swing = Swing()\n        load = PQLoad()\n    end\n    @equations begin\n        connect(busbar.terminal, swing.terminal)\n        connect(busbar.terminal, load.terminal)\n    end\nend\nMyMTKBus(name=:bus) #hide\nnothing #hideAlternatively, for that system you could have just calledmybus = MTKBus(Swing(;name=:swing), PQLoad(;name=:load))\nnothing #hideto get an instance of a model which is structurally equivalent to MyMTKBus.","category":"page"},{"location":"ModelingConcepts/#Line-Modeling","page":"Modeling Concepts","title":"Line Modeling","text":"","category":"section"},{"location":"ModelingConcepts/#Branch-Interface","page":"Modeling Concepts","title":"Model class Branch","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A branch is the two-port equivalent to an injector. It needs to have two Terminal()s, one is called :src, the other :dst.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Examples for branches are: PI─Model branches, dynamic RL branches or transformers.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"      ┌───────────┐\n(src) │           │ (dst)\n  o←──┤  Branch   ├──→o\n      │           │\n      └───────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Both ends follow the injector interface, i.e. current leaving the device towards the terminals is always positive.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: algebraic R-line\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\n@mtkmodel MyRLine begin\n    @components begin\n        src = Terminal()\n        dst = Terminal()\n    end\n    @parameters begin\n        R=0, [description=\"Resistance\"]\n    end\n    @equations begin\n        dst.i_r ~ (dst.u_r - src.u_r)/R\n        dst.i_i ~ (dst.u_i - src.u_i)/R\n        src.i_r ~ -dst.i_r\n        src.i_i ~ -dst.i_i\n    end\nend\nMyRLine(name=:rline) #hide\nnothing #hide","category":"page"},{"location":"ModelingConcepts/#MTKLine-Interface","page":"Modeling Concepts","title":"Model class: MTKLine","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Similar to the MTKBus, a MTKLine is a model class which represents a transmission line in the network.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"It must contain two LineEnd() instances, one called :src, one called :dst.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":" ┌────────────────────────────────────────────────┐\n │ MTKLine          ┌──────────┐                  │\n │  ┌─────────┐  ┌──┤ Branch A ├──┐  ┌─────────┐  │\n │  │ LineEnd │  │  └──────────┘  │  │ LineEnd │  │\n │  │  :src   ├──o                o──┤  :dst   │  │\n │  │         │  │  ┌──────────┐  │  │         │  │\n │  └─────────┘  └──┤ Branch B ├──┘  └─────────┘  │\n │                  └──────────┘                  │\n └────────────────────────────────────────────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Simple line models, which consist only of valid Branch models can be instantiated using the MTKLine(branches...) constructor.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"More complex models can be created manually. For example if you want to chain multiple branches between the LineEnds, for example something like","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"LineEnd(:src) ──o── Transformer ──o── Pi─Line ──o── LineEnd(:dst)","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: Transmission line with two pi-branches\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\n@mtkmodel MyMTKLine begin\n    @components begin\n        src = LineEnd()\n        dst = LineEnd()\n        branch1 = PiLine()\n        branch2 = PiLine()\n    end\n    @equations begin\n        connect(src.terminal, branch1.src)\n        connect(src.terminal, branch2.src)\n        connect(dst.terminal, branch1.dst)\n        connect(dst.terminal, branch2.dst)\n    end\nend\nMyMTKLine(name=:mtkline) #hide\nnothing #hideAlternatively, an equivalent model with multiple valid branch models in parallel could be created and instantiated with the convenience constructorline = MTKLine(PiLine(;name=:branch1), PiLine(;name=:branch2))\nnothing #hide","category":"page"},{"location":"ModelingConcepts/#From-MTK-Models-to-NetworkDynamics","page":"Modeling Concepts","title":"From MTK Models to NetworkDynamics","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Both MTKLine and MTKBus are still purely symbolic ModelingToolkit models. However they have an important property: they possess the correct input-output-structure and variable names to be compiled into VertexModel and EdgeModel models. To do so, PowerDynamics.jl provides the Line and Bus constructors.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Putting the knowledge from this document together, we can start a short simulation of an example network:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"using PowerDynamics, PowerDynamics.Library, ModelingToolkit\nusing Graphs, NetworkDynamics\nusing OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\nnothing #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"First, we define an MTKBus consisting of two predefined injector models from the Library: a Swing generator model and a PQLoad. To do so, we use the MTKBus(injectors...) constructor.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"@named swing = Swing(; Pm=1, V=1, D=0.1)\n@named load = PQLoad(; Pset=-.5, Qset=0)\nbus1mtk = MTKBus(swing, load; name=:swingbus)\nshow(stdout, MIME\"text/plain\"(), bus1mtk) #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"This results in an MTK model, which fulfills the MTKBus interface and thus can be compiled into an actual VertexModel for simulation:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"vertex1f = Bus(bus1mtk) # extract component function","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"As a second bus in this example, we use a SlackDifferential from the Library. This model is not an Injector but an MTKBus directly, as it does not make sense to connect anything else to a slack bus.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"bus2mtk = SlackDifferential(; name=:slackbus)\nvertex2f = Bus(bus2mtk) # extract component function","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"For the connecting line, we instantiate two PiLine from the library. Each PiLine fulfills the Branch interface. Therefore we can define a MTKLine model by putting both Branches in parallel:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"@named branch1 = PiLine()\n@named branch2 = PiLine()\nlinemtk = MTKLine(branch1, branch2; name=:powerline)\nshow(stdout, MIME\"text/plain\"(), bus1mtk) #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Similar to before, we need to compile the MTKModel by calling Line.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"edgef = Line(linemtk) # extract component function","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"To simulate the system, we place both components on a graph and connect them. We define both graph topology as well as the models for the individual components.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"g = complete_graph(2)\nnw = Network(g, [vertex1f, vertex2f], edgef)\nu0 = NWState(nw) # extract parameters and state from models\nu0.v[1, :swing₊θ] = 0 # set missing initial conditions\nu0.v[1, :swing₊ω] = 1\nnothing #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Then we can solve the problem","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"prob = ODEProblem(nw, uflat(u0), (0,1), pflat(u0))\nsol = solve(prob, Rodas5P())\n@assert OrdinaryDiffEqRosenbrock.SciMLBase.successful_retcode(sol) #hide\nnothing #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"And finally we can plot the solution:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"fig = Figure();\nax = Axis(fig[1,1])\nlines!(ax, sol; idxs=VIndex(1,:busbar₊P), label=\"Power injection Bus\", color=Cycled(1))\nlines!(ax, sol; idxs=VIndex(1,:swing₊Pel), label=\"Power injection Swing\", color=Cycled(2))\nlines!(ax, sol; idxs=VIndex(1,:load₊P), label=\"Power injection load\", color=Cycled(3))\naxislegend(ax)\n\nax = Axis(fig[2,1])\nlines!(ax, sol; idxs=VIndex(1,:busbar₊u_arg), label=\"swing bus voltage angle\", color=Cycled(1))\nlines!(ax, sol; idxs=VIndex(2,:busbar₊u_arg), label=\"slack bus voltage angle\", color=Cycled(2))\naxislegend(ax)\nfig #hide","category":"page"},{"location":"ModelingConcepts/#Internals","page":"Modeling Concepts","title":"Internals","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Internally, we use different input/output conventions for bus and line models. The predefined models BusBar() and LineEnd() are defined in the following way:","category":"page"},{"location":"ModelingConcepts/#Model:-BusBar()","page":"Modeling Concepts","title":"Model: BusBar()","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A busbar is a concrete model used in bus modeling. It represents the physical connection within a bus, the thing where all injectors and lines attach.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"           ┌──────────┐\ni_lines ──→│          │  (t)\n           │  Busbar  ├───o\n  u_bus ←──│          │\n           └──────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"It receives the sum of all line currents as an input and equals that to the currents flowing into the terminal. As an output, it forwards the terminal voltage to the backend.","category":"page"},{"location":"ModelingConcepts/#Model:-LineEnd()","page":"Modeling Concepts","title":"Model: LineEnd()","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A LineEnd model is very similar to the BusBar model. It represents one end of a transmission line.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"          ┌───────────┐\n u_bus ──→│           │  (t)\n          │  LineEnd  ├───o\ni_line ←──│           │\n          └───────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"It has special input/output connectors which handle the network interconnection. The main difference being the different input/output conventions for the network interface.","category":"page"},{"location":"generated/emt_toymodel/#emt-toymodel","page":"EMT Toymodel","title":"EMT Toy Model Example","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"This example demonstrates an electromagnetic transient (EMT) simulation of a simple two-bus system using PowerDynamics.jl. The system consists of a slack bus connected to a load bus through an RL transmission line, with the load bus having both a dynamic PQ load and a capacitive shunt element.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"We compare our simulation results with PowerFactory reference data to validate the EMT modeling approach.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"note: Pedagogical Example\nThis is a pedagogical example that demonstrates the modeling concepts in PowerDynamics.jl are generally compatible with EMT simulations. However, this is far from being an actual interesting simulation study. The way we want to handle EMT simulations in PowerDynamics.jl is not yet fully clear and remains an active area of development.The example serves to illustrate the flexibility of the modeling framework rather than provide a production-ready EMT simulation tool.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"This script can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/emt_toymodel/#System-Description","page":"EMT Toymodel","title":"System Description","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The test system includes:","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"Bus 1: Slack bus (infinite bus with constant voltage)\nBus 2: Load bus with PQ load and shunt capacitor\nTransmission line: RL model with distributed capacitance\nDisturbance: Load disconnection at t=0.1s","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"using PowerDynamics\nusing PowerDynamics.Library\nusing NetworkDynamics\nusing ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\nusing CSV\nusing SteadyStateDiffEq\nusing OrdinaryDiffEqRosenbrock\nusing DataFrames\nusing CairoMakie","category":"page"},{"location":"generated/emt_toymodel/#System-Parameters","page":"EMT Toymodel","title":"System Parameters","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"First, we define the base system parameters and component values.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"ω0    = 2π*50    ## Nominal frequency [rad/s]\nSbase = 300      ## Base power [MW]\nVbase = 110      ## Base voltage [kV]\n\nRline = 1        ## Line resistance [Ω]\nLline = (1/100π) ## Line inductance [H]\nCline = (2e-6)   ## Line capacitance [F]\nPload = -300     ## Load power (negative = consumption) [MW]\n\n# Convert to per-unit values\nRline_pu = Rline / Zbase(Sbase, Vbase)\nLline_pu = Lline / Zbase(Sbase, Vbase)\nCline_pu = Cline / Ybase(Sbase, Vbase)\nPload_pu = Pload / Sbase\nnothing # hide","category":"page"},{"location":"generated/emt_toymodel/#Bus-Definitions","page":"EMT Toymodel","title":"Bus Definitions","text":"","category":"section"},{"location":"generated/emt_toymodel/#Slack-Bus","page":"EMT Toymodel","title":"Slack Bus","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The slack bus maintains constant voltage magnitude and angle, representing an infinite bus or strong grid connection.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"slackbus = Bus(pfSlack(; V=1), vidx=1)","category":"page"},{"location":"generated/emt_toymodel/#Dynamic-Shunt-Capacitor-Model","page":"EMT Toymodel","title":"Dynamic Shunt Capacitor Model","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The shunt capacitor is modeled as a dynamic component in the dq-frame. This allows us to observe the three-phase voltages (u_a, u_b, u_c) by transforming from the dq-frame back to abc coordinates.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The capacitor dynamics are given by:","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"beginaligned\nfracdu_rdt = phantom-omega_0 u_i + frac1C i_r \nfracdu_idt = -omega_0 u_r + frac1C i_i\nendaligned","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"where the omega_0 u_i and -omega_0 u_r terms account for the rotating dq-frame.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"@mtkmodel DynamicShunt begin\n    @components begin\n        terminal = Terminal()\n    end\n    @variables begin\n        u_r(t), [guess=1, description=\"Real part of voltage\"]\n        u_i(t), [guess=0, description=\"Imaginary part of voltage\"]\n        # Three-phase voltages as observables\n        u_a(t), [description=\"Voltage in a phase\"]\n        u_b(t), [description=\"Voltage in b phase\"]\n        u_c(t), [description=\"Voltage in c phase\"]\n    end\n    @parameters begin\n        C, [description=\"Capacitance\"]\n        ω0, [description=\"Angular frequency of dq Frame\"]\n    end\n    begin\n        # Transformation matrix from dq to abc coordinates\n        Tdqinv(δ) = [cos(δ)       -sin(δ)\n                     cos(δ-2pi/3) -sin(δ-2pi/3)\n                     cos(δ+2pi/3) -sin(δ+2pi/3)]\n    end\n    @equations begin\n        # Capacitor dynamics in rotating dq-frame\n        Dt(u_r) ~  ω0*u_i + 1/C * terminal.i_r\n        Dt(u_i) ~ -ω0*u_r + 1/C * terminal.i_i\n        # Terminal connections\n        terminal.u_r ~ u_r\n        terminal.u_i ~ u_i\n        # Transform to three-phase voltages\n        [u_a, u_b, u_c] ~ Tdqinv(ω0*t) * [u_r, u_i]\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/emt_toymodel/#Load-Bus-Components","page":"EMT Toymodel","title":"Load Bus Components","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The load bus combines two components:","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"A PQ load consuming constant active power (injector model from Library)\nA dynamic shunt capacitor representing line charging","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"@named load = PQLoad(Pset=-Pload_pu, Qset=0)\n@named shunt = DynamicShunt(C=Cline_pu, ω0=ω0)\nloadbus = Bus(\n    MTKBus(load, shunt);\n    vidx=2\n)","category":"page"},{"location":"generated/emt_toymodel/#Transmission-Line-Model","page":"EMT Toymodel","title":"Transmission Line Model","text":"","category":"section"},{"location":"generated/emt_toymodel/#Dynamic-RL-Branch","page":"EMT Toymodel","title":"Dynamic RL Branch","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The transmission line is modeled as a dynamic RL branch in the dq-frame. The line current dynamics are given by:","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"beginaligned\nfracdi_rdt = phantom-omega_0 i_i - fracRL i_r + frac1L(u_textdstr - u_textsrcr) \nfracdi_idt = -omega_0 i_r - fracRL i_i + frac1L(u_textdsti - u_textsrci)\nendaligned","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"where the voltage difference drives the current through the line impedance.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"@mtkmodel DynamicRLBranch begin\n    @components begin\n        src = Terminal()\n        dst = Terminal()\n    end\n    @variables begin\n        i_r(t)=0, [description=\"Current in real part\"]\n        i_i(t)=-1, [description=\"Current in imaginary part\"]\n    end\n    @parameters begin\n        R, [description=\"Resistance\"]\n        L, [description=\"Inductance\"]\n        ω0, [description=\"Angular frequency of dq Frame\"]\n    end\n    @equations begin\n        # RL line dynamics in rotating dq-frame\n        Dt(i_r) ~  ω0 * i_i  - R/L * i_r + 1/L*(dst.u_r - src.u_r)\n        Dt(i_i) ~ -ω0 * i_r  - R/L * i_i + 1/L*(dst.u_i - src.u_i)\n        # Terminal current connections (KCL enforcement)\n        src.i_r ~ -i_r  ## Current flows out of source\n        src.i_i ~ -i_i\n        dst.i_r ~ i_r   ## Current flows into destination\n        dst.i_i ~ i_i\n    end\nend\n\n@named branch = DynamicRLBranch(; R=Rline_pu, L=Lline_pu, ω0=ω0)\nline_model = Line(\n    MTKLine(branch);\n    src=1, dst=2\n)","category":"page"},{"location":"generated/emt_toymodel/#Network-Assembly-and-Initialization","page":"EMT Toymodel","title":"Network Assembly and Initialization","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"We assemble the complete network and attempt initialization.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"nw = Network([slackbus, loadbus], line_model)\ntry #hide\ns0 = find_fixpoint(nw; alg=DynamicSS(Rodas5P()))\ncatch e #hide\n    @error e #hide\nend #hide","category":"page"},{"location":"generated/emt_toymodel/#Initialization-Challenge","page":"EMT Toymodel","title":"Initialization Challenge","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The direct initialization fails due to the stiffness of the PQ load model. When the load current is computed algebraically from i = P fracuu^2, the system becomes numerically challenging to initialize.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"To overcome this, we use a \"less stiff\" load model with dynamics that smooth out the algebraic singularity during initialization.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"We create a \"less stiff\" version of the PQ load that introduces first-order dynamics with a fast time constant (1/1000 s). This smooths the algebraic relation and makes initialization more robust:","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"beginaligned\nfracdi_rdt = 1000 left( P fracu_ru_r^2 + u_i^2 - i_r right) \nfracdi_idt = 1000 left( P fracu_iu_r^2 + u_i^2 - i_i right)\nendaligned","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"This approaches the algebraic PQ load behavior but avoids initialization issues.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"@mtkmodel LessStiffPQLoad begin\n    @components begin\n        terminal = Terminal()\n    end\n    @variables begin\n        i_r(t)=0, [description=\"Current in real part\"]\n        i_i(t)=0, [description=\"Current in imaginary part\"]\n    end\n    @parameters begin\n        Pset, [description=\"Active Power demand\"]\n    end\n    @equations begin\n        # First-order dynamics with fast time constant\n        Dt(i_r) ~ 1e3*(Pset * terminal.u_r/(terminal.u_r^2 + terminal.u_i^2) - i_r)\n        Dt(i_i) ~ 1e3*(Pset * terminal.u_i/(terminal.u_r^2 + terminal.u_i^2) - i_i)\n        terminal.i_r ~ i_r\n        terminal.i_i ~ i_i\n    end\nend\n\n@named less_stiff_load = LessStiffPQLoad(Pset=-Pload_pu)\nless_stiff_loadbus = Bus(\n    MTKBus(less_stiff_load, shunt);\n    vidx=2\n)\nless_stiff_nw = Network([slackbus, less_stiff_loadbus], line_model)\nless_stiff_s0 = find_fixpoint(less_stiff_nw; alg=DynamicSS(Rodas5P()))","category":"page"},{"location":"generated/emt_toymodel/#Initialize-Target-System","page":"EMT Toymodel","title":"Initialize Target System","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"Perfect! The less stiff load initialization worked. Now we use this solution as an initial guess for our target system with the algebraic PQ load.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"s0guess = NWState(nw)\n# Transfer key state variables from less stiff solution\ns0guess[VIndex(2, :busbar₊u_i)] = less_stiff_s0[VIndex(2, :busbar₊u_i)]\ns0guess[VIndex(2, :busbar₊u_r)] = less_stiff_s0[VIndex(2, :busbar₊u_r)]\ns0guess[EIndex(1, :branch₊i_i)] = less_stiff_s0[EIndex(1, :branch₊i_i)]\ns0guess[EIndex(1, :branch₊i_r)] = less_stiff_s0[EIndex(1, :branch₊i_r)]\ns0 = find_fixpoint(nw, s0guess; alg=DynamicSS(Rodas5P()))","category":"page"},{"location":"generated/emt_toymodel/#Disturbance-Setup","page":"EMT Toymodel","title":"Disturbance Setup","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"Excellent! The initialization succeeded. Now we set up a disturbance to observe the system's transient response. We'll disable the load at t=0.1s to simulate a sudden load disconnection.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"disable_load_affect = ComponentAffect([], [:load₊Pset]) do u, p, ctx\n    println(\"Disabling load at time $(ctx.t)\")\n    p[:load₊Pset] = 0  ## Set load power to zero\nend\nset_callback!(loadbus, PresetTimeComponentCallback(0.1, disable_load_affect))\nnothing #hide","category":"page"},{"location":"generated/emt_toymodel/#Dynamic-Simulation","page":"EMT Toymodel","title":"Dynamic Simulation","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"With the system properly initialized and the disturbance configured, we can now run the electromagnetic transient simulation.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"prob = ODEProblem(nw, uflat(s0), (0.0, 0.15), copy(pflat(s0)); callback=get_callbacks(nw))\nsol = solve(prob, Rodas5P());\nnothing #hide","category":"page"},{"location":"generated/emt_toymodel/#Results-and-Validation","page":"EMT Toymodel","title":"Results and Validation","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"We compare our EMT simulation results with PowerFactory reference data to validate the modeling approach. The comparison focuses on the three-phase voltages at bus 2 during the load disconnection transient.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The thick gray lines show the PowerFactory reference, while our PowerDynamics.jl results are overlaid in color. The close agreement validates our EMT modeling approach.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"fig = let\n    fig = Figure()\n    ax = Axis(fig[1,1];\n        title=\"Three-Phase Voltage at Bus 2\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Voltage [pu]\")\n    ts = range(0.09, 0.13; length=2000)\n\n    # Load PowerFactory reference data\n    df = CSV.read(\n        joinpath(pkgdir(PowerDynamics),\"docs\",\"examples\", \"emt_data_minimal.csv.gz\"),\n        DataFrame\n    )\n    # Plot PowerFactory results (thick gray lines)\n    lines!(ax, df.t, df.u_2_a; label=\"PowerFactory A\", color=:lightgray, linewidth=5)\n    lines!(ax, df.t, df.u_2_b; label=\"PowerFactory B\", color=:lightgray, linewidth=5)\n    lines!(ax, df.t, df.u_2_c; label=\"PowerFactory C\", color=:lightgray, linewidth=5)\n\n    # Extract and plot our simulation results\n    a = sol(ts, idxs=VIndex(2, :shunt₊u_a)).u\n    b = sol(ts, idxs=VIndex(2, :shunt₊u_b)).u\n    c = sol(ts, idxs=VIndex(2, :shunt₊u_c)).u\n    lines!(ax, ts, a, label=\"PowerDynamics A\", color=Cycled(1))\n    lines!(ax, ts, b, label=\"PowerDynamics B\", color=Cycled(2))\n    lines!(ax, ts, c, label=\"PowerDynamics C\", color=Cycled(3))\n\n    axislegend(ax, position=:rt)\n    xlims!(ax, ts[begin], ts[end])\n    fig\nend","category":"page"},{"location":"generated/emt_toymodel/#Detailed-View-of-Transient-Response","page":"EMT Toymodel","title":"Detailed View of Transient Response","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"Let's zoom in on the critical period around the load disconnection to better observe the transient behavior and compare with the reference.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"xlims!(0.0995, 0.105)\nfig","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"This page was generated using Literate.jl.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"The following functions are designed for public use.","category":"page"},{"location":"API/#Modeling-Tools","page":"API","title":"Modeling Tools","text":"","category":"section"},{"location":"API/#Connectors-and-Base-Components","page":"API","title":"Connectors and Base Components","text":"","category":"section"},{"location":"API/#PowerDynamics.Terminal","page":"API","title":"PowerDynamics.Terminal","text":"@named t = Terminal()\n\nA ModelingToolkit connector for electrical terminals in power system components.\n\nRepresents an electrical connection point with complex voltage and current in dq coordinates. The terminal defines the interface between power system components like buses, lines, and machines.\n\nVariables\n\nu_r(t): d-axis voltage component\nu_i(t): q-axis voltage component\ni_r(t): d-axis current component (flow variable)\ni_i(t): q-axis current component (flow variable)\n\nNotes\n\nCurrent variables are defined as flow variables, meaning they sum to zero at connection points according to Kirchhoff's current law.\n\nSee also: BusBar, LineEnd\n\n\n\n\n\n","category":"constant"},{"location":"API/#PowerDynamics.BusBar","page":"API","title":"PowerDynamics.BusBar","text":"@named busbar = BusBar()\n\nA ModelingToolkit model representing the physical connection point within a bus in power systems. It represents the physical busbar where all injectors and lines attach.\n\nWithin PowerDynamics.jl, it serves as an interface between the MTK world and the NetworkDynamics world: A MTK model containing a BusBar the highest level is consdered a busmodel (see isbusmodel) and describes the dynamics of an entire bus. It can be transformed in a VertexModel by calling Bus.\n\nSee also: Terminal, MTKBus, Bus\n\n\n\n\n\n","category":"constant"},{"location":"API/#PowerDynamics.LineEnd","page":"API","title":"PowerDynamics.LineEnd","text":"LineEnd\n\nA ModelingToolkit model representing one end of a transmission line in power systems. It represents the physical connection point at the end of a transmission line.\n\nWithin PowerDynamics.jl, it serves as an interface between the MTK world and the NetworkDynamics world: A MTK model containing two LineEnds (named :src and :dst) at the highest level is considered a linemodel (see islinemodel) and describes the dynamics of an entire line. It can be transformed in an EdgeModel by calling Line.\n\nSee also: Terminal, MTKLine, Line\n\n\n\n\n\n","category":"constant"},{"location":"API/#Bus-and-Line-Construction","page":"API","title":"Bus and Line Construction","text":"","category":"section"},{"location":"API/#PowerDynamics.MTKBus","page":"API","title":"PowerDynamics.MTKBus","text":"MTKBus(injectors...; name=:bus)\n\nCreate a ModelingToolkit bus system by connecting multiple injector components.\n\nConstructs a bus System by connecting all provided injector components to a central BusBar. Each injector component must satisfy the injector model interface (see isinjectormodel).\n\nArguments\n\ninjectors...: Variable number of injector components (generators, loads, etc.)\nname=:bus: Name for the resulting bus system\n\nReturns\n\nAn System representing the complete bus with all connected injectors\n\n                                 ┌────────────────────┐\n                                 │MTKBus   ┌─────────┐│\n                                 │        ┌┤Generator││\n        ┌─────────┐   ┌────┐     │┌──────┐│└─────────┘│\nMTKBus(o┤Generator│, o┤Load│) => ││BusBar├o           │\n        └─────────┘   └────┘     │└──────┘│┌────┐     │\n                                 │        └┤Load│     │\n                                 │         └────┘     │\n                                 └────────────────────┘\n\nSee also: Bus, BusBar, isinjectormodel\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.MTKLine","page":"API","title":"PowerDynamics.MTKLine","text":"MTKLine(branches...; name=:line)\n\nCreate a ModelingToolkit line system by connecting multiple branch components.\n\nConstructs a line System by connecting all provided branch components between source and destination line ends in parallel. Each branch component must satisfy the branch model interface.\n\nArguments\n\nbranches...: Variable number of branch components (transmission lines, transformers, etc.)\nname=:line: Name for the resulting line system\n\nReturns\n\nAn System representing the complete line with all connected branches\n\n                                     ┌─────────────────────────────┐\n                                     │MTKLine   ┌───────┐          │\n                                     │         ┌┤BranchA├┐         │\n         ┌───────┐    ┌───────┐      │┌───────┐│└───────┘│┌───────┐│\nMTKLine(o┤BranchA├o, o┤BranchB├o) => ││LineEnd├o         o┤LineEnd││\n         └───────┘    └───────┘      │└───────┘│┌───────┐│└───────┘│\n                                     │  :src   └┤BranchB├┘  :dst   │\n                                     │          └───────┘          │\n                                     └─────────────────────────────┘\n\nSee also: Line, LineEnd, isbranchmodel\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.CompositeInjector","page":"API","title":"PowerDynamics.CompositeInjector","text":"CompositeInjector(systems, eqs=autoconnections(systems); name=Symbol(join(getname.(systems), \"_\")))\n\nCreate an injector object which contains several subsystems. Every subsystem which has a terminal will be connected to a newly created terminal of the composite injector. The subsystems are namespaced within the composite injector.\n\nThere are two options for additional connections between the subsystems:\n\ninterconnections will be created automatically using some name-matching heuristics using autoconnections(systems): It searches all Blocks.RealOutput and Blocks.RealInput, and tries to find a single matching output for each input.\nalternatively pass connecting equations of the form [connect(sys1.output, sys2.input)] explicitly\n\nFor example, one could create a composite injector with three subsystems:\n\na generator,\na controller, and\na load;\n\nwhich is augmented with 2 connection equations\n\none for the measurements (generator -> controller), and\none for the actuation (controller -> generator).\n\nThe returned model contains a new terminal :terminal at the toplevel, thus satisfying the injector interface, see isinjectormodel). It can be used as such in the MTKBus constructor.\n\n    ┌────────────────────────────────────┐\n    │ CompositeInjector                  │\n    │              ╭───→───╮ measurements│\n    │    ┌─────────┴─┐   ┌─┴──────────┐  │\n(t) │  o─┤ Generator │   │ Controller │  │\n o──┼──┤ └─────────┬─┘   └─┬──────────┘  │\n    │  │           ╰───←───╯ actuation   │\n    │  │ ┌──────┐                        │\n    │  o─┤ Load │                        │\n    │    └──────┘                        │\n    └────────────────────────────────────┘\n\n\n\n\n\n","category":"function"},{"location":"API/#Base-Unit-Calculations","page":"API","title":"Base Unit Calculations","text":"","category":"section"},{"location":"API/#PowerDynamics.Ibase","page":"API","title":"PowerDynamics.Ibase","text":"Ibase(S, V)\n\nCalculates current pu base based on Sbase and Vbase: Ibase = Sbase/Vbase.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.Zbase","page":"API","title":"PowerDynamics.Zbase","text":"Zbase(S, V)\n\nCalculates impedance pu base based on Sbase and Vbase: Zbase = Vbase²/Sbase.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.Ybase","page":"API","title":"PowerDynamics.Ybase","text":"Ybase(S, V)\n\nCalculates admittance pu base based on Sbase and Vbase: Ybase = Sbase/Vbase².\n\n\n\n\n\n","category":"function"},{"location":"API/#Network-Components","page":"API","title":"Network Components","text":"","category":"section"},{"location":"API/#PowerDynamics.Bus","page":"API","title":"PowerDynamics.Bus","text":"Bus(sys::System; verbose=false, name=getname(sys), kwargs...)\n\nCreate a VertexModel from an System that satisfies the bus model interface.\n\nArguments\n\nsys::System: The system must satisfy the bus model interface (see isbusmodel)\nverbose::Bool=false: Enable verbose output during creation\nname: Name for the bus (defaults to system name)\nkwargs...: Additional keyword arguments passed to the Bus constructor\n\nReturns\n\nA VertexModel representing the bus\n\n\n                                          ╔═════════════════════════╗\n                                          ║ VertexModel (compiled)  ║\n    ┌────────────────────┐      Network   ║  ┌────────────────────┐ ║\n    │MTKBus   ┌─────────┐│     interface  ║  │MTKBus   ┌─────────┐│ ║\n    │        ┌┤Generator││                ║  │        ┌┤Generator││ ║\n    │┌──────┐│└─────────┘│      current ────→│┌──────┐│└─────────┘│ ║\nBus(││BusBar├o           │) =>            ║  ││BusBar├o           │ ║\n    │└──────┘│┌────┐     │      voltage ←────│└──────┘│┌────┐     │ ║\n    │        └┤Load│     │                ║  │        └┤Load│     │ ║\n    │         └────┘     │                ║  │         └────┘     │ ║\n    └────────────────────┘                ║  └────────────────────┘ ║\n                                          ╚═════════════════════════╝\n\nSee also: MTKBus\n\n\n\n\n\nBus(template::VertexModel; copy=true, vidx=nothing, pf=nothing, name=template.name, pairs...)\n\nSimilar to the Bus constructor, but takes a pre-compiled VertexModel. It copies the VertexModel and applies the keyword arguments. This is usefull when you want to create new bus models based on a template.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.Line","page":"API","title":"PowerDynamics.Line","text":"Line(sys::System; verbose=false, name=getname(sys), kwargs...)\n\nCreate an EdgeModel from a System that satisfies the line model interface.\n\nArguments\n\nsys::System: The system must satisfy the line model interface (see islinemodel)\nverbose::Bool=false: Enable verbose output during creation\nname: Name for the line (defaults to system name)\nkwargs...: Additional keyword arguments passed to the Line constructor\n\nReturns\n\nAn EdgeModel representing the line\n\n\n                                             ╔══════════════════════════════╗\n                                             ║ EdgeModel (compiled)         ║\n     ┌─────────────────────────────┐     src ║ ┌──────────────────────────┐ ║ dst\n     │MTKLine   ┌───────┐          │  vertex ║ │MTKLine   ┌────┐          │ ║ vertex\n     │         ┌┤BranchA├┐         │         ║ │         ┌┤    ├┐         │ ║\n     │┌───────┐│└───────┘│┌───────┐│     u ───→│┌───────┐│└────┘│┌───────┐│←─── u\nLine(││LineEnd├o         o┤LineEnd││) =>     ║ ││LineEnd├o      o┤LineEnd││ ║\n     │└───────┘│┌───────┐│└───────┘│     i ←───│└───────┘│┌────┐│└───────┘│───→ i\n     │  :src   └┤BranchB├┘  :dst   │         ║ │         └┤    ├┘         │ ║\n     │          └───────┘          │         ║ │          └────┘          │ ║\n     └─────────────────────────────┘         ║ └──────────────────────────┘ ║\n                                             ╚══════════════════════════════╝\n\nSee also: MTKLine\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.simplify_mtkbus","page":"API","title":"PowerDynamics.simplify_mtkbus","text":"simplify_mtkbus(sys::System; busbar=:busbar)\n\nStructurally simplify a bus model System by eliminating equations.\n\nClosely matches what VertexModel does, but returns the System after the simplifications rather than compiling it into a VertexModel.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.simplify_mtkline","page":"API","title":"PowerDynamics.simplify_mtkline","text":"simplify_mtkline(sys::System; src=:src, dst=:dst)\n\nStructurally simplify a line model System by eliminating equations.\n\nClosely matches what EdgeModel does, but returns the System after the simplifications rather than compiling it into an EdgeModel.\n\n\n\n\n\n","category":"function"},{"location":"API/#Interface-Checking-Functions","page":"API","title":"Interface Checking Functions","text":"","category":"section"},{"location":"API/#PowerDynamics.isinjectormodel","page":"API","title":"PowerDynamics.isinjectormodel","text":"isinjectormodel(sys::System)\n\nCheck if a System satisfies the injector model interface.\n\nAn injector model must contain a Terminal named :terminal. Injector models represent components like generators, loads, and other devices that connect to a single bus. They can have arbitrary internal complexity as long as they have exactly one terminal.\n\n   (t)    ┌──────────┐\n    o─────┤ Injector │\n:terminal └──────────┘\n\nSee also: Terminal\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.isbusmodel","page":"API","title":"PowerDynamics.isbusmodel","text":"isbusmodel(sys::System)\n\nCheck if a System satisfies the bus model interface.\n\nA bus model must contain a component named :busbar that satisfies the busbar interface. Bus models represent the complete dynamics of a power system bus and can be transformed into a VertexModel using Bus.\n\n┌───────────────────────────┐\n│BusModel     ┌────────────┐│\n│           ┌─┤ Injector 1 ││\n│┌────────┐ │ └────────────┘│\n││ BusBar ├─o               │\n│└────────┘ │               │\n│ :busbar   └ ...           │\n│                           │\n└───────────────────────────┘\n\nNote: The BusModel musst contain exaclty one BusBar, the rest of the structure is free. For example, you could also put a Brach between an injector and a Busbar or have multiple injectors and controllers connected.\n\nSee also: Bus, BusBar, MTKBus\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.isbranchmodel","page":"API","title":"PowerDynamics.isbranchmodel","text":"isbranchmodel(sys::System)\n\nCheck if a System satisfies the branch model interface.\n\nA branch model must contain two Terminal components named :src and :dst. Branch models represent two-port network elements like transmission lines, transformers, and other connecting devices.\n\n (t) ┌────────┐ (t)\n  o──┤ Branch ├──o\n:src └────────┘ :dst\n\nSee also: Terminal\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.islinemodel","page":"API","title":"PowerDynamics.islinemodel","text":"islinemodel(sys::System)\n\nCheck if a System satisfies the line model interface.\n\nA line model must contain two components named :src and :dst that both satisfy the line end interface. Line models represent transmission lines and can be transformed into an EdgeModel using Line.\n\n┌──────────────────────────────────────┐\n│LineModel     ┌────────┐              │\n│            ┌─┤ Branch ├─┐            │\n│┌─────────┐ │ └────────┘ │ ┌─────────┐│\n││ LineEnd ├─o            o─┤ LineEnd ││\n│└─────────┘ │            │ └─────────┘│\n│   :src     └    ....    ┘    :dst    │\n│                                      │\n└──────────────────────────────────────┘\n\nNote: Between the LineEnds there can be arbeitrary structures, for example branches in series or parallel.\n\nSee also: Line, LineEnd, MTKBus\n\n\n\n\n\n","category":"function"},{"location":"API/#Power-Flow-Analysis","page":"API","title":"Power Flow Analysis","text":"","category":"section"},{"location":"API/#Power-Flow-Bus-Types","page":"API","title":"Power Flow Bus Types","text":"","category":"section"},{"location":"API/#PowerDynamics.pfSlack","page":"API","title":"PowerDynamics.pfSlack","text":"pfSlack(; V=missing, δ=missing, u_r=missing, u_i=missing)\n\nCreate a slack bus for power flow analysis.\n\nA slack bus maintains constant voltage magnitude and phase angle (or real and imaginary voltage components). Either provide voltage magnitude V and phase angle δ, or provide real and imaginary voltage components u_r and u_i.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.pfPV","page":"API","title":"PowerDynamics.pfPV","text":"pfPV(; P, V)\n\nCreate a PV bus for power flow analysis.\n\nA PV bus maintains constant active power injection and voltage magnitude. The reactive power and voltage phase angle are determined by the power flow solution.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.pfPQ","page":"API","title":"PowerDynamics.pfPQ","text":"pfPQ(; P=0, Q=0)\n\nCreate a PQ bus for power flow analysis.\n\nA PQ bus has specified active and reactive power injections. The voltage magnitude and phase angle are determined by the power flow solution.\n\n\n\n\n\n","category":"function"},{"location":"API/#Power-Flow-Solution-Functions","page":"API","title":"Power Flow Solution Functions","text":"","category":"section"},{"location":"API/#PowerDynamics.solve_powerflow","page":"API","title":"PowerDynamics.solve_powerflow","text":"solve_powerflow(nw::Network;\n                pfnw = powerflow_model(nw),\n                pfs0 = NWState(nw),\n                verbose=true)\n\nSolve the power flow equations for a given network.\n\nUses find_fixpoint from NetworkDynamics to solve the algebraic power flow equations.\n\nParameters\n\nnw: The dynamic network model\npfnw: The power flow network model (default: created from nw)\npfs0: Initial state for the power flow calculation\nverbose: Whether to print the power flow solution\n\nReturns\n\nA NWState containing the solved power flow solution\n\nSee also initialize_from_pf.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.initialize_from_pf!","page":"API","title":"PowerDynamics.initialize_from_pf!","text":"initialize_from_pf[!](\n    nw::Network;\n    verbose = true,\n    subverbose = false,\n    pfnw = powerflow_model(nw),\n    pfs0 = NWState(pfnw),\n    pfs = solve_powerflow(nw; pfnw, pfs0, verbose),\n    kwargs...\n)\n\nInitialize a dynamic network model from a power flow solution.\n\nThis function performs a two-step initialization process:\n\nSolve the power flow equations for the network\nUse the power flow solution to initialize the dynamic model\n\nThere are two versions of this function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses initialize_componentwise! internally, the non-mutating one initialize_componentwise. When the mutating version is used, NWState(nw) after initialization will return the same initialized state again, as it is stored in the metadata.\n\nParameters\n\nnw: The dynamic network model to initialize\nverbose: Whether to print information about the power flow solution (default: true)\nsubverbose: Whether to print detailed information during component initialization (default: false). Can be Vector [VIndex(1), EIndex(3), ...] for selective output\npfnw: Power flow network model (default: created from nw using powerflow_model)\npfs0: Initial state for power flow calculation (default: created from pfnw)\npfs: Power flow solution (default: calculated using solve_powerflow)\nAdditional keyword arguments are passed to initialize_componentwise[!]\n\nReturns\n\nA fully initialized network state\n\nSee also: solve_powerflow, initialize_componentwise, interface_values\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.initialize_from_pf","page":"API","title":"PowerDynamics.initialize_from_pf","text":"initialize_from_pf[!](\n    nw::Network;\n    verbose = true,\n    subverbose = false,\n    pfnw = powerflow_model(nw),\n    pfs0 = NWState(pfnw),\n    pfs = solve_powerflow(nw; pfnw, pfs0, verbose),\n    kwargs...\n)\n\nInitialize a dynamic network model from a power flow solution.\n\nThis function performs a two-step initialization process:\n\nSolve the power flow equations for the network\nUse the power flow solution to initialize the dynamic model\n\nThere are two versions of this function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses initialize_componentwise! internally, the non-mutating one initialize_componentwise. When the mutating version is used, NWState(nw) after initialization will return the same initialized state again, as it is stored in the metadata.\n\nParameters\n\nnw: The dynamic network model to initialize\nverbose: Whether to print information about the power flow solution (default: true)\nsubverbose: Whether to print detailed information during component initialization (default: false). Can be Vector [VIndex(1), EIndex(3), ...] for selective output\npfnw: Power flow network model (default: created from nw using powerflow_model)\npfs0: Initial state for power flow calculation (default: created from pfnw)\npfs: Power flow solution (default: calculated using solve_powerflow)\nAdditional keyword arguments are passed to initialize_componentwise[!]\n\nReturns\n\nA fully initialized network state\n\nSee also: solve_powerflow, initialize_componentwise, interface_values\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.show_powerflow","page":"API","title":"PowerDynamics.show_powerflow","text":"show_powerflow(s::NWState/Network)\n\nDisplay power flow results in a tabular format.\n\nExtract and format power flow solution data from a network state, showing bus-level information including voltage magnitudes, phase angles, active power, and reactive power.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.powerflow_model","page":"API","title":"PowerDynamics.powerflow_model","text":"powerflow_model(cf::NetworkDynamics.ComponentModel; check=:error)\n\nExtract or create a power flow component model from a dynamic component model.\n\nIf the component has :pfmodel metadata, use that model (after validation)\nIf the component is already a valid power flow model (i.e. no ODE, just constraints), return it as-is\n\nParameters\n\ncf: The component model to extract/create a power flow model from\ncheck: Validation behavior (:error, :warn, or :none) when model validation fails\n\nReturns\n\nA component model suitable for power flow analysis (no dynamics)\n\nValidation\n\nThe returned model must satisfy ispfmodel criteria:\n\nEither no states or zero mass matrix (no dynamics)\n\nSee also: ispfmodel, pfSlack, pfPV, pfPQ\n\n\n\n\n\npowerflow_model(nw::Network; check=:error)\n\nCreate a power flow network model from a dynamic network model.\n\nThis method applies powerflow_model to all vertex and edge components in the network, creating a new network suitable for steady-state power flow analysis.\n\nParameters\n\nnw: The network to create a power flow model from\ncheck: Validation behavior (:error, :warn, or :none) passed to component-level powerflow_model calls\n\nReturns\n\nA new Network with the same graph structure but power flow component models\n\nSee also: solve_powerflow\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.ispfmodel","page":"API","title":"PowerDynamics.ispfmodel","text":"ispfmodel(cf::NetworkDynamics.ComponentModel)\n\nCheck if a component model is suitable for power flow analysis.\n\nA component model is considered a valid power flow model if it has no dynamics, i.e., either no states or a zero mass matrix.\n\nReturns\n\ntrue if the component is suitable for power flow analysis\nfalse otherwise\n\n\n\n\n\n","category":"function"},{"location":"API/#Power-Flow-Model-Management-Functions","page":"API","title":"Power Flow Model Management Functions","text":"","category":"section"},{"location":"API/#PowerDynamics.has_pfmodel","page":"API","title":"PowerDynamics.has_pfmodel","text":"has_pfmodel(c::ComponentModel)\nhas_pfmodel(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has a power flow model in metadata.\n\nSee also: get_pfmodel, set_pfmodel!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.get_pfmodel","page":"API","title":"PowerDynamics.get_pfmodel","text":"get_pfmodel(c::NetworkDynamics.ComponentModel)\nget_pfmodel(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the power flow model for the component model. May error if no power flow model is present. Use has_pfmodel to check first.\n\nSee also: has_pfmodel, set_pfmodel!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.set_pfmodel!","page":"API","title":"PowerDynamics.set_pfmodel!","text":"set_pfmodel!(c::NetworkDynamics.ComponentModel, model)\nset_pfmodel!(nw::Network, idx::Union{VIndex,EIndex}, model)\n\nSets the power flow model for the component. Overwrites any existing power flow model.\n\nSee also delete_pfmodel!, get_pfmodel.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.delete_pfmodel!","page":"API","title":"PowerDynamics.delete_pfmodel!","text":"delete_pfmodel!(c::NetworkDynamics.ComponentModel)\ndelete_pfmodel!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the power flow model from the component model, or from a component referenced by idx in a network. Returns true if the power flow model existed and was removed, false otherwise.\n\nSee also: set_pfmodel!.\n\n\n\n\n\n","category":"function"},{"location":"API/#Power-Flow-Initialization-Constraints","page":"API","title":"Power Flow Initialization Constraints","text":"","category":"section"},{"location":"API/#Constraint-Types","page":"API","title":"Constraint Types","text":"","category":"section"},{"location":"API/#PowerDynamics.PFInitConstraint","page":"API","title":"PowerDynamics.PFInitConstraint","text":"struct PFInitConstraint{F}\nPFInitConstraint(f, sym, pfsym, dim)\n\nA representation of an additional constraint that is applied during the initialization phase of a component. In contrast to a InitConstraint, this constraint may access additional variables which are available in the full NWState of the solved power flow!\n\nCrucially, this is only necessary for constraints, which cannot be expressed in terms of the interface variables (voltages and currents).\n\nSee also: @pfinitconstraint for a macro to create such constraints, PFInitConstraint, set_pfinitconstraint!, add_pfinitconstraint!\n\n\n\n\n\n","category":"type"},{"location":"API/#PowerDynamics.@pfinitconstraint","page":"API","title":"PowerDynamics.@pfinitconstraint","text":"@pfinitconstraint expr\n@pfinitconstraint begin\n    constraint1\n    constraint2\nend\n\nCreate a PFInitConstraint using macro syntax. Component variables are accessed with :symbol and power flow state variables with @pf :symbol. Multiple constraints can be defined in a begin...end block.\n\nSee also: PFInitConstraint, set_pfinitconstraint!, add_pfinitconstraint!\n\n\n\n\n\n","category":"macro"},{"location":"API/#PowerDynamics.PFInitFormula","page":"API","title":"PowerDynamics.PFInitFormula","text":"struct PFInitFormula{F}\nPFInitFormula(f, outsym, sym, pfsym)\n\nA representation of an initialization formula that is applied during the initialization phase of a component. In contrast to a InitFormula, this formula may access additional variables which are available in the full NWState of the solved power flow!\n\nCrucially, this is only necessary for formulas, which cannot be expressed in terms of the interface variables (voltages and currents).\n\nSimilar to InitFormula, this sets defaults rather than adding constraint equations. The formula is applied early in the initialization pipeline before constraints are solved.\n\nSee also: @pfinitformula for a macro to create such formulas, PFInitFormula, set_pfinitformula!, add_pfinitformula!\n\n\n\n\n\n","category":"type"},{"location":"API/#PowerDynamics.@pfinitformula","page":"API","title":"PowerDynamics.@pfinitformula","text":"@pfinitformula expr\n@pfinitformula begin\n    :var1 = expr1\n    :var2 = expr2\nend\n\nCreate a PFInitFormula using macro syntax. Component variables are accessed with :symbol and power flow state variables with @pf :symbol. Multiple formulas can be defined in a begin...end block.\n\nUnlike constraints, formulas use assignment syntax (:var = expression) to set variable values during initialization. The left-hand side specifies output variables, and the right-hand side can access both component variables and power flow state variables.\n\nSee also: PFInitFormula, set_pfinitformula!, add_pfinitformula!\n\n\n\n\n\n","category":"macro"},{"location":"API/#Constraint-Management-Functions","page":"API","title":"Constraint Management Functions","text":"","category":"section"},{"location":"API/#PowerDynamics.add_pfinitconstraint!","page":"API","title":"PowerDynamics.add_pfinitconstraint!","text":"add_pfinitconstraint!(c::NetworkDynamics.ComponentModel, constraint::PFInitConstraint) -> Bool\nadd_pfinitconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint) -> Bool\n\nAdds a new initialization constraint which depends on the powerflow solution to the component. If constraints already exist, the new constraint is added to the existing ones. If no constraints exist, this is equivalent to set_pfinitconstraint!.\n\nReturns true if the constraint was successfully added, false if it already exists.\n\nSee also set_pfinitconstraint!, delete_pfinitconstraints!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.add_pfinitformula!","page":"API","title":"PowerDynamics.add_pfinitformula!","text":"add_pfinitformula!(c::NetworkDynamics.ComponentModel, formula::PFInitFormula) -> Bool\nadd_pfinitformula!(nw::Network, idx::Union{VIndex,EIndex}, formula) -> Bool\n\nAdds a new initialization formula which depends on the powerflow solution to the component. If formulas already exist, the new formula is added to the existing ones. If no formulas exist, this is equivalent to set_pfinitformula!.\n\nReturns true if the formula was successfully added, false if it already exists.\n\nSee also set_pfinitformula!, delete_pfinitformulas!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.set_pfinitconstraint!","page":"API","title":"PowerDynamics.set_pfinitconstraint!","text":"set_pfinitconstraint!(c::NetworkDynamics.ComponentModel, constraint; check=true)\nset_pfinitconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint; check=true)\n\nSets initialization constraints which depend on the powerflow solution to the component. Accepts either a single PFInitConstraint or a tuple of PFInitConstraint objects. Overwrites any existing pf constraints. See also delete_pfinitconstraints!, add_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.set_pfinitformula!","page":"API","title":"PowerDynamics.set_pfinitformula!","text":"set_pfinitformula!(c::NetworkDynamics.ComponentModel, formula; check=true)\nset_pfinitformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)\n\nSets initialization formulas which depend on the powerflow solution to the component. Accepts either a single PFInitFormula or a tuple of PFInitFormula objects. Overwrites any existing pf formulas. See also delete_pfinitformulas!, add_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.has_pfinitconstraint","page":"API","title":"PowerDynamics.has_pfinitconstraint","text":"has_pfinitconstraint(c::ComponentModel)\nhas_pfinitconstraint(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has an initialization constraint which depends on the pf state in metadata.\n\nSee also: get_pfinitconstraints, set_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.has_pfinitformula","page":"API","title":"PowerDynamics.has_pfinitformula","text":"has_pfinitformula(c::ComponentModel)\nhas_pfinitformula(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has an initialization formula which depends on the pf state in metadata.\n\nSee also: get_pfinitformulas, set_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.get_pfinitconstraints","page":"API","title":"PowerDynamics.get_pfinitconstraints","text":"get_pfinitconstraints(c::NetworkDynamics.ComponentModel)\nget_pfinitconstraints(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the initialization constraints which depend on pf state for the component model. Returns a tuple of constraints, even if only one constraint is present. May error if no constraints are present. Use has_pfinitconstraint to check first.\n\nSee also: has_pfinitconstraint, set_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.get_pfinitformulas","page":"API","title":"PowerDynamics.get_pfinitformulas","text":"get_pfinitformulas(c::NetworkDynamics.ComponentModel)\nget_pfinitformulas(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the initialization formulas which depend on pf state for the component model. Returns a tuple of formulas, even if only one formula is present. May error if no formulas are present. Use has_pfinitformula to check first.\n\nSee also: has_pfinitformula, set_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.delete_pfinitconstraints!","page":"API","title":"PowerDynamics.delete_pfinitconstraints!","text":"delete_pfinitconstraints!(c::NetworkDynamics.ComponentModel)\ndelete_pfinitconstraints!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the powerflow dependent initialization constraint from the component model, or from a component referenced by idx in a network. Returns true if the constraint existed and was removed, false otherwise.\n\nSee also: set_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.delete_pfinitformulas!","page":"API","title":"PowerDynamics.delete_pfinitformulas!","text":"delete_pfinitformulas!(c::NetworkDynamics.ComponentModel)\ndelete_pfinitformulas!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the powerflow dependent initialization formula from the component model, or from a component referenced by idx in a network. Returns true if the formula existed and was removed, false otherwise.\n\nSee also: set_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.copy_pf_parameters","page":"API","title":"PowerDynamics.copy_pf_parameters","text":"copy_pf_parameters(cm::ComponentModel) -> PFInitFormula\n\nCreates a PFInitFormula that copies all parameters from the powerflow model to the component model. This formula can then be added to the component using add_pfinitformula!.\n\nThis is useful for components where the powerflow and dynamic models should have identical parameter values, ensuring consistency between the two models.\n\nSee also: PFInitFormula, add_pfinitformula!\n\n\n\n\n\n","category":"function"},{"location":"generated/custom_bus/#custom-bus","page":"Custom Generator Bus","title":"Define a Custom Bus Model","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"In this Tutorial, we will define a custom bus model that can be used in PowerDynamics.jl.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The model we set out to recreate is the classical machine from Chapter 15.1 from Milano's book","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"F. Milano, Power System Modelling and Scripting,  Berlin, Heidelberg: Springer Berlin Heidelberg, 2010. doi: 10.1007/978-3-642-13669-6.","category":"page"},{"location":"generated/custom_bus/#Defining-the-Machine-as-Injector","page":"Custom Generator Bus","title":"Defining the Machine as Injector","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"In order to use this model in a Bus, we need to define it in a way that it specifies the Injector Interface.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"            ┌───────────────────┐\nterminal    │                   │\n   o←───────┤ Machine Equations │\nu_r, u_i    │                   │\ni_r, i_i    └───────────────────┘\n","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The received values for u_r, u_i, i_r, and i_i at the terminal are in the global synchronous dq frame. The internal state δ describes the rotor angle of the machine in this frame. In order to obtain the local dq-frame voltages and currents, we need to apply a Park transformation.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"<picture>\n<source srcset=\"../../assets/dqgrafic-dark.svg\" media=\"(prefers-color-scheme: dark)\">\n<img src=\"../../assets/dqgrafic.svg\" width=\"70%\" height=\"70%\"/>\n</picture>","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"In addition to the transformation, the model is defined by the following equations:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"beginaligned\nfracddeltadt = omega_b(omega - 1) text(Milano 155) \n2H fracdomegadt = fracP_momega - tau_e text(Power form of Milano 155) \npsi_d = V_q + R_s I_q text(Milano 1511) \npsi_q = -V_d - R_s I_d text(Milano 1511) \ntau_e = psi_d I_q - psi_q I_d text(Milano 156) \n0 = V_q + R_s I_q + X_d I_d - v_ftextset text(Milano 1536) \n0 = V_d + R_s I_d - X_d I_q text(Milano 1536)\nendaligned","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We can use the ModelingToolkit DSL to define the full injector model:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"using PowerDynamics, NetworkDynamics, ModelingToolkit\nusing PowerDynamics.Library\nusing ModelingToolkit: t_nounits as t, D_nounits as Dt\nusing ModelingToolkitStandardLibrary.Blocks\nusing OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\n\n@mtkmodel MilanoClassicalMachine begin\n    @components begin\n        terminal=Terminal()\n    end\n    @parameters begin\n        R_s=0.000124, [description=\"stator resistance\"]\n        X′_d=0.0608, [description=\"d-axis transient reactance\"]\n        H=23.64, [description=\"inertia constant\"]\n        ω_b=2π*50, [description=\"System base frequency in rad/s\"]\n        vf_set, [guess=1, description=\"field voltage\"]\n        P_m, [guess=1, description=\"mechanical power\"]\n    end\n    @variables begin\n        δ(t), [guess=0, description=\"rotor angle\"]\n        ω(t), [guess=1, description=\"rotor speed\"]\n        τ_e(t), [description=\"electrical torque\"]\n        I_d(t), [description=\"d-axis current\"]\n        I_q(t), [description=\"q-axis current\"]\n        V_d(t), [description=\"d-axis voltage\"]\n        V_q(t), [description=\"q-axis voltage\"]\n        ψ_d(t), [description=\"d-axis flux linkage\"]\n        ψ_q(t), [description=\"q-axis flux linkage\"]\n    end\n    begin\n        T_to_loc(α)  = [ sin(α) -cos(α);\n                         cos(α)  sin(α)]\n        T_to_glob(α) = [ sin(α)  cos(α);\n                        -cos(α)  sin(α)]\n    end\n    @equations begin\n        # Park's transformations\n        [terminal.u_r, terminal.u_i] .~ T_to_glob(δ)*[V_d, V_q]\n        [I_d, I_q] .~ T_to_loc(δ)*[terminal.i_r, terminal.i_i]\n\n        # mechanical swing equation Milano 15.5\n        Dt(δ) ~ ω_b*(ω - 1)\n        2*H * Dt(ω) ~ P_m/ω - τ_e\n\n        # static flux linkage equations Milano 15.11\n        ψ_d ~  V_q + R_s*I_q\n        ψ_q ~ -V_d - R_s*I_d\n\n        # electrical torque Milano 15.6\n        τ_e ~ ψ_d*I_q - ψ_q*I_d\n\n        # magnetic equations from static model Milano 15.36\n        0 ~ V_q + R_s*I_q + X′_d*I_d - vf_set\n        0 ~ V_d + R_s*I_d - X′_d*I_q\n    end\nend\n\n\n@named machine = MilanoClassicalMachine();\nnothing #hide","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We can verify that the model satisfies the Injector Interface by checking","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"isinjectormodel(machine)","category":"page"},{"location":"generated/custom_bus/#Attaching-the-Machine-to-a-Busbar","page":"Custom Generator Bus","title":"Attaching the Machine to a Busbar","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"In order to use the machine model, we need to attach it to a busbar, thus forming a system which satisfies the MTKBus Interface. There are two ways of doing so: manually and using the MTKBus constructor.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Manual Construction","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We need to define a new MTK model, which has 2 components: a busbar and the machine. Both components have a terminal as a subcomponent, we can use the connect function to hook the machine on the busbar.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"@mtkmodel MyMTKBus begin\n    @components begin\n        busbar = BusBar()\n        machine = MilanoClassicalMachine()\n    end\n    @equations begin\n        connect(busbar.terminal, machine.terminal)\n    end\nend\nmtkbus = MyMTKBus(name=:bus)\nisbusmodel(mtkbus) # assert that the created model satisfies the interface","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Automatic Construction","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We can also use the MTKBus constructor to create a busbar with a machine attached. This constructor takes a list of injector models and hooks them all to the same busbar.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"mtkbus = MTKBus(machine; name=:bus)\nisbusmodel(mtkbus) # assert that the created model satisfies the interface","category":"page"},{"location":"generated/custom_bus/#Compiling-bus-to-VertexModel","page":"Custom Generator Bus","title":"Compiling bus to VertexModel","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"To actually simulate the system, we need to compile the model, i.e. transforming it from a purely symbolic representation to a numerical one.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Bus(mtkbus)","category":"page"},{"location":"generated/custom_bus/#Defining-a-Simulation-Scenario","page":"Custom Generator Bus","title":"Defining a Simulation Scenario","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"To simulate the model, we need to define some kind of scenario. We'll create a simple two-bus system where our custom Milano machine is connected to a slack bus through a transmission line. This will allow us to observe the machine's dynamic behavior in response to a frequency disturbance.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"First, we create a slack bus that provides the voltage and frequency reference for the system.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"slackbus = Bus(\n    PowerDynamics.VariableFrequencySlack(name=:variable_slack),\n    vidx=1,\n    pf=pfSlack(V=1)\n)","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We define a frequency event that increases the system frequency at t=1 second (see ND docs on Callbacks for details). This disturbance will cause our machine to respond dynamically as it tries to maintain synchronism with the network.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"freq_event = PresetTimeComponentCallback(\n    1, # trigger at time 1\n    ComponentAffect([],[:V,:ω]) do u, p, ctx\n        p[:ω] = 1.01 # set frequency to 1.01 pu\n    end\n)\nset_callback!(slackbus, freq_event)\nnothing #hide","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Next, we create the generator bus using our custom Milano machine model. We specify it as a PV bus for the power flow with 1 pu voltage and 1 pu active power.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"genbus = Bus(\n    mtkbus,\n    vidx=2,\n    pf=pfPV(V=1, P=1)\n)","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We connect the two buses with a simple PI transmission line model.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"line = Line(MTKLine(PiLine(; name=:piline)); src=1,dst=2)","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Now we can build the complete network with our two buses and the connecting line.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"nw = Network([slackbus, genbus], line)","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Before running dynamic simulation, we initialize the system from power flow. This ensures that all dynamic states start from a steady-state condition.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"To do so, we use the function initialize_from_pf!, which does several steps:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Calculate the powerflow according to the powerflow models.\nInitialize the \"free\" states and parameters of the dynamical components, such that the system is in a steady state.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"More information on initialization can be found in the docs on Powergrid Initialization.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"initialize_from_pf!(nw)\nnothing #hide","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Let's examine the initial state of our generator bus to verify proper initialization.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"dump_initial_state(nw[VIndex(2)])","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The printout shows us several important aspects: The free internal states delta, omega and the free internal parameters P_mathrm m and vf_mathrmset have been initialized. We see, that both power and excitation voltage are slightly above the given (1,1) for the powerflow, which is expected since there are some losses in the model. However the initialized state matches the powerflow solution at the network interface, i.e. busbar₊P and busbar₊u_mag are both 1 pu.","category":"page"},{"location":"generated/custom_bus/#Dynamic-Simulation","page":"Custom Generator Bus","title":"Dynamic Simulation","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"With the system properly initialized, we can set up and solve the dynamic simulation. We simulate for 100 seconds to capture the machine's response to the frequency disturbance.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"s0 = NWState(nw)\nprob = ODEProblem(nw, uflat(s0), (0,100), pflat(s0), callback=get_callbacks(nw))\nsol = solve(prob, Rodas5P())\nnothing #hide","category":"page"},{"location":"generated/custom_bus/#Visualizing-the-Results","page":"Custom Generator Bus","title":"Visualizing the Results","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Now let's create comprehensive plots to visualize how our custom Milano machine responds to the frequency disturbance. We'll plot several key variables that demonstrate the machine's electromechanical dynamics.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"let\n    fig = Figure(size=(800, 600));\n\n    ax1 = Axis(fig[1, 1];\n        title=\"Rotor Angle\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Rotor Angle δ [rad]\")\n    lines!(ax1, sol; idxs=VIndex(2, :machine₊δ), linewidth=2)\n    axislegend(ax1)\n\n    ax2 = Axis(fig[2, 1];\n        title=\"Rotor Speed\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Rotor Speed ω [pu]\")\n    lines!(ax2, sol; idxs=VIndex(2, :machine₊ω), linewidth=2)\n    axislegend(ax2)\n\n    ax3 = Axis(fig[3, 1];\n        title=\"Machine Voltages\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Voltage [pu]\")\n    lines!(ax3, sol; idxs=VIndex(2, :machine₊V_d), color=Cycled(1), linewidth=2)\n    lines!(ax3, sol; idxs=VIndex(2, :machine₊V_q), color=Cycled(2), linewidth=2)\n    axislegend(ax3)\n    fig\nend","category":"page"},{"location":"generated/custom_bus/#Observing-the-Poor-Damping-Problem","page":"Custom Generator Bus","title":"Observing the Poor Damping Problem","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"From the plots above, we can see that the Milano classical machine exhibits very lightly damped oscillations that persist for a very long time. The rotor angle and speed oscillate for hundreds of seconds without settling to a steady state.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"This poor damping behavior occurs because:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"No damper windings: The model lacks electromagnetic damping mechanisms\nConstant field voltage: No dynamic response to help stabilize the machine\nNo mechanical damping: The swing equation has no friction losses","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The only source of damping here is, that we have specified a constant mechanical power rather than a constant mechanical torque.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"To solve this problem, real power systems use control systems, particularly Power System Stabilizers (PSS) that are specifically designed to damp electromechanical oscillations.","category":"page"},{"location":"generated/custom_bus/#Adding-a-Power-System-Stabilizer-(PSS)","page":"Custom Generator Bus","title":"Adding a Power System Stabilizer (PSS)","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Let's create an improved machine model with controllable field voltage and add the simplest possible PSS to demonstrate the damping improvement.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The implemented PSS is a simple device, which adjusts the excitation voltage based on frequency deviation. It consists of a washout filter to remove steady-state errors and only react to frequency changes, and a gain to amplify the response.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"To achieve this goal we will:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Modify the Milano machine model to include a controllable field voltage input and a rotor frequency measurement output.\nCreate a simple PSS model that takes the frequency input and outputs a stabilizing signal to the field voltage.\nCombine the machine and PSS into a new composite model that forms an injector.\nRepeat the simulation above with our new controlled-generator model and compare the results.","category":"page"},{"location":"generated/custom_bus/#Controllable-Machine-Model","page":"Custom Generator Bus","title":"Controllable Machine Model","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"First, we create a modified Milano machine with control inputs/outputs: vf_in for field voltage and ω_out for frequency output.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"@mtkmodel MilanoControllableMachine begin\n    @components begin\n        terminal=Terminal()\n        # Control interface\n        vf_in = RealInput(guess=1)  # field voltage input\n        ω_out = RealOutput()        # frequency output for PSS\n    end\n    @parameters begin\n        R_s=0.000124, [description=\"stator resistance\"]\n        X′_d=0.0608, [description=\"d-axis transient reactance\"]\n        H=23.64, [description=\"inertia constant\"]\n        ω_b=2π*50, [description=\"System base frequency in rad/s\"]\n        P_m, [guess=1, description=\"mechanical power\"]\n    end\n    @variables begin\n        δ(t), [guess=0, description=\"rotor angle\"]\n        ω(t), [guess=1, description=\"rotor speed\"]\n        τ_e(t), [description=\"electrical torque\"]\n        I_d(t), [description=\"d-axis current\"]\n        I_q(t), [description=\"q-axis current\"]\n        V_d(t), [description=\"d-axis voltage\"]\n        V_q(t), [description=\"q-axis voltage\"]\n        ψ_d(t), [description=\"d-axis flux linkage\"]\n        ψ_q(t), [description=\"q-axis flux linkage\"]\n    end\n    begin\n        T_to_loc(α)  = [ sin(α) -cos(α);\n                         cos(α)  sin(α)]\n        T_to_glob(α) = [ sin(α)  cos(α);\n                        -cos(α)  sin(α)]\n    end\n    @equations begin\n        # Park's transformations\n        [terminal.u_r, terminal.u_i] .~ T_to_glob(δ)*[V_d, V_q]\n        [I_d, I_q] .~ T_to_loc(δ)*[terminal.i_r, terminal.i_i]\n\n        # mechanical swing equation Milano 15.5\n        Dt(δ) ~ ω_b*(ω - 1)\n        2*H * Dt(ω) ~ P_m/ω - τ_e\n\n        # static flux linkage equations Milano 15.11\n        ψ_d ~  V_q + R_s*I_q\n        ψ_q ~ -V_d - R_s*I_d\n\n        # electrical torque Milano 15.6\n        τ_e ~ ψ_d*I_q - ψ_q*I_d\n\n        # magnetic equations from static model Milano 15.36\n        0 ~ V_q + R_s*I_q + X′_d*I_d - vf_in.u  # Use controllable input\n        0 ~ V_d + R_s*I_d - X′_d*I_q\n\n        # Control interface - output frequency for PSS\n        ω_out.u ~ ω\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_bus/#Simple-Power-System-Stabilizer","page":"Custom Generator Bus","title":"Simple Power System Stabilizer","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The simplest PSS consists of a washout filter with gain. The washout filter ensures the PSS only responds to frequency changes, not steady-state errors.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"@mtkmodel SimplePSS begin\n    @components begin\n        ω_in = RealInput() # frequency input from machine\n        vst = RealOutput() # stabilizer output signal\n    end\n    @parameters begin\n        Tw=10, [description=\"washout time constant\"]\n        Ks=20, [description=\"stabilizer gain\"]\n    end\n    @variables begin\n        y(t), [guess=0, description=\"washout filter output\"]\n    end\n    @equations begin\n        # Washout filter: dy/dt = (ω - y)/Tw\n        Dt(y) ~ (ω_in.u - y) / Tw\n        # output gain\n        vst.u ~ Ks * (ω_in.u - y)\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_bus/#Complete-Generator-with-PSS","page":"Custom Generator Bus","title":"Complete Generator with PSS","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The PSS only adds an offset to the field voltage based on the frequency input. Therefore, our combined injector model needs to look something like this:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"    ┌───────────────────────────┐\n    │GeneratorWithPss           │\n    │         ╭─────→─────╮     │\n(t) │ ┌───────┴─┐ ω_out ┌─┴───┐ │\n o──┼─┤ Machine │       │ PSS │ │\n    │ └───────┬─┘       └─┬───┘ │\n    │   vf_in ╰──←─(+)──←─╯ vst │\n    │               ↑           │\n    │            vf_base        │\n    └───────────────────────────┘","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Notably, similar to how we left vf_set free for initialization in the previous example, now we need to leave vf_base free.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We define a new mtkmodel which combines machine with controller and forms a new injector:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"@mtkmodel GeneratorWithPSS begin\n    @components begin\n        terminal = Terminal()\n        machine = MilanoControllableMachine()\n        pss = SimplePSS()\n    end\n    @parameters begin\n        vf_base, [guess=1.0, description=\"base field voltage\"]\n    end\n    @equations begin\n        # Connect terminals\n        connect(terminal, machine.terminal)\n        # Connect control loop: machine frequency → PSS → back to machine field voltage\n        connect(machine.ω_out, pss.ω_in)\n        # Sum base field voltage with PSS output\n        machine.vf_in.u ~ vf_base + pss.vst.u\n    end\nend\n\n@named gen_with_pss = GeneratorWithPSS()\nisinjectormodel(gen_with_pss) # Verify it's still an injector","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Since this is an injector, we can use MTKBus(gen_with_pss) to build the symbolic bus model. However, this leads to another level of namespacing, as the overall bus will have variable names like gen_with_pss₊machine₊δ due to the encapsulation.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Alternatively, we could define a model which directly implements the MTKBus interface:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"┌─────────────────────────────────────┐\n│MyMTKBus                             │\n│                   ╭─────→─────╮     │\n│┌──────┐   ┌───────┴─┐ ω_out ┌─┴───┐ │\n││BusBar├─o─┤ Machine │       │ PSS │ │\n│└──────┘   └───────┬─┘       └─┬───┘ │\n│             vf_in ╰──←─(+)──←─╯ vst │\n│                         ↑           │\n│                      vf_base        │\n└─────────────────────────────────────┘","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"@mtkmodel CustomMTKBus begin\n    @components begin\n        busbar = BusBar()\n        machine = MilanoControllableMachine()\n        pss = SimplePSS()\n    end\n    @parameters begin\n        vf_base, [guess=1.0, description=\"base field voltage\"]\n    end\n    @equations begin\n        connect(busbar.terminal, machine.terminal)\n        connect(machine.ω_out, pss.ω_in)\n        machine.vf_in.u ~ vf_base + pss.vst.u\n    end\nend\n@named genbus_custom = CustomMTKBus()\n@assert isbusmodel(genbus_custom)","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"In practice, it doesn't really matter which approach you choose, as both will work. However this highlights the flexibility of the MTK modeling framework before you go to the compiled-model domain by calling Bus on the model fulfilling the MTKBus interface.","category":"page"},{"location":"generated/custom_bus/#Simulation-with-PSS","page":"Custom Generator Bus","title":"Simulation with PSS","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Now let's run the same simulation scenario with the PSS-equipped generator to observe the damping improvement.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Create the improved generator bus with simple PSS","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"genbus_pss = Bus(\n    MTKBus(gen_with_pss; name=:bus_pss),\n    vidx=2,\n    pf=pfPV(V=1, P=1)\n)","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Create network with PSS-equipped generator","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"nw_pss = Network([slackbus, genbus_pss], line)\ninitialize_from_pf!(nw_pss)\nnothing #hide","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Run simulation with simple PSS","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"s0_pss = NWState(nw_pss)\nprob_pss = ODEProblem(nw_pss, uflat(s0_pss), (0,100), pflat(s0_pss), callback=get_callbacks(nw_pss))\nsol_pss = solve(prob_pss, Rodas5P())\nnothing #hide","category":"page"},{"location":"generated/custom_bus/#Comparing-Results:-With-and-Without-PSS","page":"Custom Generator Bus","title":"Comparing Results: With and Without PSS","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Let's create comparison plots to clearly see the damping improvement:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"let\n    fig = Figure(size=(800, 600));\n\n    # Compare rotor speeds\n    ax1 = Axis(fig[1, 1];\n        title=\"Rotor Speed Comparison: Effect of PSS on Damping\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Rotor Speed ω [pu]\")\n    lines!(ax1, sol; idxs=VIndex(2, :machine₊ω), label=\"No PSS\", color=Cycled(2))\n    lines!(ax1, sol_pss; idxs=VIndex(2, :gen_with_pss₊machine₊ω), label=\"Simple PSS\", color=Cycled(1), linewidth=2)\n    axislegend(ax1, position=:rt)\n    xlims!(ax1, 0, 30)  # Focus on first 30 seconds\n\n    # PSS Output - shows the actual stabilizer signal\n    ax2 = Axis(fig[2, 1];\n        title=\"PSS Output Signal\",\n        xlabel=\"Time [s]\",\n        ylabel=\"PSS Output [pu]\")\n    lines!(ax2, sol_pss; idxs=VIndex(2, :gen_with_pss₊pss₊vst₊u), label=\"PSS Output\", linewidth=2)\n    axislegend(ax2, position=:rt)\n    xlims!(ax2, 0, 30)\n\n    fig\nend","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#PowerDynamics","page":"Home","title":"PowerDynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PowerDynamics.jl is a Julia package for modeling and simulating power grid dynamics. It provides a comprehensive framework for analyzing electrical power systems, including synchronous machines, loads, lines, and various control elements. The package is built on top of NetworkDynamics.jl and offers both predefined component models and the flexibility to create custom power system components.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: PowerDynamics.Library Under Active Development\nThe PowerDynamics.Library component library is currently excluded from semantic versioning and is under heavy development.While PowerDynamics itself follows semantic versioning, the Library submodule's API is highly unstable and variable names, function signatures, and model interfaces may change frequently without notice. If you are using specific models from PowerDynamics.Library in their current state, we strongly recommend copying them to your own source code to avoid breaking changes in future updates.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modeling Concepts - Learn the fundamental concepts behind PowerDynamics modeling\nComponent Library - Explore the available power system component models\nPowergrid Initialization - Understand how to properly initialize power system simulations\nAPI Reference - Complete function and type documentation","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is also highly recommend to out check the docs on NetworkDynamics.jl as those explain lots of the underlying functionality and concepts","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Custom Components - Shows how to implement Milano's classical synchronous machine model with a power system stabilizer (PSS)\nCustom Transmission Lines - Demonstrates creating a PI-branch transmission line model with overcurrent protection that can trip during faults","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IEEE 9-Bus System - Simulates the complete 9-bus IEEE test system with synchronous generators and dynamic load changes\nIEEE 39-Bus System Part 1 - Shows how to build the 39-bus New England test system from custom CSV data files with proper component modeling\nIEEE 39-Bus System Part 2 - Demonstrates the detailed initialization process for the 39-bus system including power flow and initialization of dynamic models\nIEEE 39-Bus System Part 3 - Runs dynamic simulation of the 39-bus system with a short circuit disturbance and fault clearing\nIEEE 39-Bus System Part 4 - Implements a custom droop-controlled inverter model and performs parameter optimization using sensitivity analysis\nEMT Toy Model Example - Demonstrates very basic EMT modeling using dynamic shunt capacitor and RL transmission line components in rotating dq coordinates","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>Direct dependencies used for this documentation:</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg #hide\nPkg.status() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>Julia Version:</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils #hide\nversioninfo() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>Full Manifest:</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg #hide\nPkg.status(; mode = PKGMODE_MANIFEST) #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Development of this project was in part funded by the German Federal Ministry for Economic Affairs and Climate Action as part of the OpPoDyn-Project (Project ID 01258425/1, 2024-2027).","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/bmwk_logo_en.svg\" width=\"300\"/>","category":"page"}]
}
