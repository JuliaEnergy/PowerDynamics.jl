<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modeling Concepts ¬∑ PowerDynamics.jl</title><meta name="title" content="Modeling Concepts ¬∑ PowerDynamics.jl"/><meta property="og:title" content="Modeling Concepts ¬∑ PowerDynamics.jl"/><meta property="twitter:title" content="Modeling Concepts ¬∑ PowerDynamics.jl"/><meta name="description" content="Documentation for PowerDynamics.jl."/><meta property="og:description" content="Documentation for PowerDynamics.jl."/><meta property="twitter:description" content="Documentation for PowerDynamics.jl."/><meta property="og:url" content="https://juliaenergy.github.io/PowerDynamics.jl/ModelingConcepts/"/><meta property="twitter:url" content="https://juliaenergy.github.io/PowerDynamics.jl/ModelingConcepts/"/><link rel="canonical" href="https://juliaenergy.github.io/PowerDynamics.jl/ModelingConcepts/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PowerDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Modeling Concepts</a><ul class="internal"><li><a class="tocitem" href="#Relationship-between-ModelingToolkit-and-NetworkDynamics"><span>Relationship between ModelingToolkit and NetworkDynamics</span></a></li><li><a class="tocitem" href="#ModelingToolkit-Models"><span>ModelingToolkit Models</span></a></li><li><a class="tocitem" href="#From-MTK-Models-to-NetworkDynamics"><span>From MTK Models to NetworkDynamics</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li></ul></li><li><a class="tocitem" href="../initialization/">Initialization</a></li><li><a class="tocitem" href="../Library/">Component Library</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../generated/custom_bus/">Custom Generator Bus</a></li><li><a class="tocitem" href="../generated/custom_line/">Custom Transmission Line</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/ieee9bus/">IEEE 9Bus Example</a></li><li><a class="tocitem" href="../generated/ieee39_part1/">IEEE39 Part I: Modeling</a></li><li><a class="tocitem" href="../generated/ieee39_part2/">IEEE39 Part II: Initialization</a></li><li><a class="tocitem" href="../generated/ieee39_part3/">IEEE39 Part III: Simulation</a></li><li><a class="tocitem" href="../generated/ieee39_part4/">IEEE39 Part IV: Parameter Tuning</a></li><li><a class="tocitem" href="../generated/emt_toymodel/">EMT Toymodel</a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../networkdynamics_forward/">üîó NetworkDynamics.jl Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Modeling Concepts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modeling Concepts</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaEnergy/PowerDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/main/docs/src/ModelingConcepts.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Modeling-Concepts"><a class="docs-heading-anchor" href="#Modeling-Concepts">Modeling Concepts</a><a id="Modeling-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-Concepts" title="Permalink"></a></h1><p>In general, PowerDynamics models power grids as a set of dynamical systems for both <strong>nodes</strong> and <strong>edges</strong> on a graph. Check out the <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/mathematical_model/#Mathematical-Model">Mathematical Model</a> documentation of NetworkDynamics for the underlying concepts.</p><p>The simulation happens entirely in a synchronous dq-frame. Due to their conceptual similarity to complex phasors, variables in this global dq-frame are referenced by subscripts <code>_r</code> and <code>_i</code> (for real and imaginary). This helps distinguish the variables from local dq frames, e.g. a generator model might transform <code>u_r</code> and <code>u_i</code> into <code>u_d</code> and <code>u_q</code>.</p><p>Both edge and node models are so-called input-output-systems: the edges receive the voltage of adjacent nodes as an input, the nodes receive the currents on adjacent edges as an input. In general, this leads to the following structure of a bus/node model:</p><p class="math-container">\[\begin{aligned}
M_{\mathrm v}\,\frac{\mathrm{d}}{\mathrm{d}t}x_{\mathrm v} &amp;= f^{\mathrm v}\left(x^{\mathrm v}, \sum_k\begin{bmatrix}i^k_r\\ i^k_i\end{bmatrix}, p_{\mathrm v}, t\right)\\
\begin{bmatrix}u_r\\ u_i\end{bmatrix} &amp;= g^{\mathrm v}(x^\mathrm{v},p_{\mathrm v}, t)
\end{aligned}\]</p><p>where <span>$M_{\mathrm v}$</span> is the (possibly singular) mass-matrix, <span>$x_{\mathrm v}$</span> are the internal states and <span>$p_{\mathrm v}$</span> are parameters. Function <span>$f_{\mathrm v}$</span> describes the time evolution of the internal states while output equation <span>$g_{\mathrm v}$</span> defines the output voltage. The input for the system is the sum of all inflowing currents from adjacent lines <span>$k$</span>. Note how vertices are modeled as one-port systems, i.e. they receive the accumulated current from all connected lines, they can&#39;t distinguish which line provides which current. For special cases, this limitation might be mitigated using <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/external_inputs/#External-Inputs">External Inputs</a>.</p><div class="admonition is-info" id="Nodal-dynamics-include-injectors-e98c68486552f09c"><header class="admonition-header">Nodal dynamics include injectors<a class="admonition-anchor" href="#Nodal-dynamics-include-injectors-e98c68486552f09c" title="Permalink"></a></header><div class="admonition-body"><p>An important distinction between our modeling and the modeling in many other libraries is that we include the <strong>injector dynamics</strong> inside the <strong>node dynamics</strong>. I.e. if you have a bus with a load and a generator, the overall node dynamics will include both machine and load dynamics within their equations. The modularity and model reuse on the bus level is provided by <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit.jl</a> integration.</p></div></div><p>The edge model on the other hand looks like this:</p><p class="math-container">\[\begin{aligned}
M_{\mathrm e}\,\frac{\mathrm{d}}{\mathrm{d}t}x_{\mathrm e} &amp;= f_{\mathrm e}\left(x_{\mathrm e}, \begin{bmatrix} u_r^\mathrm{src}\\u_i^\mathrm{src}\end{bmatrix}, \begin{bmatrix} u_r^\mathrm{dst}\\u_i^\mathrm{dst}\end{bmatrix},p_\mathrm{e}, t\right)\\
\begin{bmatrix}i_r^\mathrm{src}\\i_i^\mathrm{src}\end{bmatrix} &amp;= g^\mathrm{src}_{\mathrm e}\left(x_{\mathrm e}, \begin{bmatrix} u_r^\mathrm{src}\\u_i^\mathrm{src}\end{bmatrix}, \begin{bmatrix} u_r^\mathrm{dst}\\u_i^\mathrm{dst}\end{bmatrix}, p_\mathrm{e}, t\right)\\
\begin{bmatrix}i_r^\mathrm{dst}\\i_i^\mathrm{dst}\end{bmatrix} &amp;= g^\mathrm{dst}_{\mathrm e}\left(x_{\mathrm e}, \begin{bmatrix} u_r^\mathrm{src}\\u_i^\mathrm{src}\end{bmatrix}, \begin{bmatrix} u_r^\mathrm{dst}\\u_i^\mathrm{dst}\end{bmatrix}, p_\mathrm{e}, t\right)\\
\end{aligned}\]</p><p>There are a few notable differences: Edges are two port systems, they have <strong>two distinct</strong> inputs and <strong>two distinct</strong> outputs. Namely, they receive the dq voltage from both source and destination end and define the current for both ends separately. In very simple systems without losses, those output currents might be just antisymmetric, in general cases however the current on both ends can differ drastically.</p><div class="admonition is-info" id="Note-841986a26bce6288"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-841986a26bce6288" title="Permalink"></a></header><div class="admonition-body"><p>Source and destination end of a line are purely conventional. It has nothing to do with the actual flow direction. Per convention from <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a>, edges in undirected graphs always go from vertex with lower index to vertex with higher index, i.e. <span>$15 \to 23$</span> never <span>$23 \to 15$</span>.</p></div></div><p>The above descriptions are important to understand what&#39;s happening inside the package. However, since we use ModelingToolkit to define the individual models a lot of this complexity is hidden from the user. In the following, we&#39;ll go through the most important concepts when designing models using ModelingToolkit.</p><h2 id="Relationship-between-ModelingToolkit-and-NetworkDynamics"><a class="docs-heading-anchor" href="#Relationship-between-ModelingToolkit-and-NetworkDynamics">Relationship between ModelingToolkit and NetworkDynamics</a><a id="Relationship-between-ModelingToolkit-and-NetworkDynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Relationship-between-ModelingToolkit-and-NetworkDynamics" title="Permalink"></a></h2><p>A crucial part of using this Library is understanding the relationship between ModelingToolkit models and NetworkDynamics.</p><p>In a nutshell, ModelingToolkit models are <strong>symbolic models</strong>, i.e. they consist of symbolic equations which are not yet &quot;compiled&quot; for use as a numeric model. The modeling in MTK is very flexible and similar to the Modelica language. What we need in the end is models in the structure defined in the equations above. For that, we need the MTK Models to have a specific structure. Then we can use the <a href="../API/#PowerDynamics.Bus"><code>Bus</code></a> and <a href="../API/#PowerDynamics.Line"><code>Line</code></a> function to compile the MTK models and create <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#Component-Models-with-MTK"><code>EdgeModel</code></a> and <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#Component-Models-with-MTK"><code>VertexModel</code></a> objects from them. Those objects are not symbolic anymore but compiled numeric versions of the symbolically created systems.</p><h2 id="ModelingToolkit-Models"><a class="docs-heading-anchor" href="#ModelingToolkit-Models">ModelingToolkit Models</a><a id="ModelingToolkit-Models-1"></a><a class="docs-heading-anchor-permalink" href="#ModelingToolkit-Models" title="Permalink"></a></h2><h3 id="Terminal"><a class="docs-heading-anchor" href="#Terminal">Terminal</a><a id="Terminal-1"></a><a class="docs-heading-anchor-permalink" href="#Terminal" title="Permalink"></a></h3><p>The <code>Terminal</code>‚îÄConnector is an important building block for every model. It represents a connection point with constant voltage in dq‚îÄcoordinates <code>u_r</code> and <code>u_i</code> and enforces the Kirchhoff constraints <code>sum(i_r)=0</code> and <code>sum(i_i)=0</code>.</p><h3 id="Modeling-of-Buses"><a class="docs-heading-anchor" href="#Modeling-of-Buses">Modeling of Buses</a><a id="Modeling-of-Buses-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-of-Buses" title="Permalink"></a></h3><h4 id="Injector-Interface"><a class="docs-heading-anchor" href="#Injector-Interface">Model class <code>Injector</code></a><a id="Injector-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Injector-Interface" title="Permalink"></a></h4><p>An injector is a class of components with a single <code>Terminal()</code> (called <code>:terminal</code>). Examples for injectors might be Generators, Shunts, Loads.</p><pre><code class="nohighlight hljs">      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
(t)   ‚îÇ           ‚îÇ
 o‚Üê‚îÄ‚îÄ‚îÄ‚î§  Injector ‚îÇ
      ‚îÇ           ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre><p>The current for injectors is always in injector convention, i.e. positive currents flow <em>out</em> of the injector <em>towards</em> the terminal.</p><div class="admonition is-info" id="Model-classes-363501e4cfa2294c"><header class="admonition-header">Model classes<a class="admonition-anchor" href="#Model-classes-363501e4cfa2294c" title="Permalink"></a></header><div class="admonition-body"><p>Model &quot;classes&quot; are nothing formalized. In this document, a model class is just a description for some <code>System</code> from <code>ModelingToolkit.jl</code>, which satisfies certain requirements. For example, any <code>System</code> is considered an &quot;Injector&quot; if it contains a connector <code>Terminal()</code> called <code>:terminal</code>.</p></div></div><details class="admonition is-details" id="Code-example:-definition-of-PQ-load-as-injector-d648a8d71d1146ae"><summary class="admonition-header">Code example: definition of PQ load as injector<a class="admonition-anchor" href="#Code-example:-definition-of-PQ-load-as-injector-d648a8d71d1146ae" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs">using PowerDynamics, PowerDynamics.Library, ModelingToolkit
using ModelingToolkit: D_nounits as Dt, t_nounits as t
@mtkmodel MyPQLoad begin
    @components begin
        terminal = Terminal()
    end
    @parameters begin
        Pset, [description=&quot;Active Power demand&quot;]
        Qset, [description=&quot;Reactive Power demand&quot;]
    end
    @variables begin
        P(t), [description=&quot;Active Power&quot;]
        Q(t), [description=&quot;Reactive Power&quot;]
    end
    @equations begin
        P ~ terminal.u_r*terminal.i_r + terminal.u_i*terminal.i_i
        Q ~ terminal.u_i*terminal.i_r - terminal.u_r*terminal.i_i
        # if possible, it&#39;s better for the solver to explicitly provide algebraic equations for the current
        terminal.i_r ~ (Pset*terminal.u_r + Qset*terminal.u_i)/(terminal.u_r^2 + terminal.u_i^2)
        terminal.i_i ~ (Pset*terminal.u_i - Qset*terminal.u_r)/(terminal.u_r^2 + terminal.u_i^2)
    end
end</code></pre></div></details><h4 id="MTKBus-Interface"><a class="docs-heading-anchor" href="#MTKBus-Interface">Model class <code>MTKBus</code></a><a id="MTKBus-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#MTKBus-Interface" title="Permalink"></a></h4><p>A <code>MTKBus</code> is a class of models, which are used to describe the dynamic behavior of a full bus in a power grid. Each <code>MTKBus</code> must contain a predefined model of type <code>BusBar()</code> (named <code>:busbar</code>). This busbar represents the connection point to the grid. Optionally, it may contain various injectors. If there are no injectors, the model just describes a junction bus, i.e. a Bus that just satisfies the Kirchhoff constraint for the flows of connected lines.</p><pre><code class="nohighlight hljs"> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ MTKBus             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
 ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚î§ Generator ‚îÇ  ‚îÇ
 ‚îÇ  ‚îÇ          ‚îÇ   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
 ‚îÇ  ‚îÇ  BusBar  ‚îú‚îÄ‚îÄ‚îÄo                 ‚îÇ
 ‚îÇ  ‚îÇ          ‚îÇ   ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
 ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚î§ Load      ‚îÇ  ‚îÇ
 ‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre><p>Sometimes it is not possible to connect all injectors directly but instead one needs or wants <code>Branches</code> between the busbar and injector terminal. As long as the <code>:busbar</code> is present at the toplevel, there are few limitations on the overall model complexity.</p><p>For simple models (direct connections of a few injectors) it is possible to use the convenience method <code>MTKBus(injectors...)</code> to create the composite model based on provided injector models.</p><details class="admonition is-details" id="Code-example:-definition-of-a-Bus-containing-a-swing-equation-and-a-load-8524c40dcd06336c"><summary class="admonition-header">Code example: definition of a Bus containing a swing equation and a load<a class="admonition-anchor" href="#Code-example:-definition-of-a-Bus-containing-a-swing-equation-and-a-load-8524c40dcd06336c" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs">using PowerDynamics, PowerDynamics.Library, ModelingToolkit
@mtkmodel MyMTKBus begin
    @components begin
        busbar = BusBar()
        swing = Swing()
        load = PQLoad()
    end
    @equations begin
        connect(busbar.terminal, swing.terminal)
        connect(busbar.terminal, load.terminal)
    end
end</code></pre><p>Alternatively, for that system you could have just called</p><pre><code class="language-julia hljs">mybus = MTKBus(Swing(;name=:swing), PQLoad(;name=:load))</code></pre><p>to get an instance of a model which is structurally equivalent to <code>MyMTKBus</code>.</p></div></details><h3 id="Line-Modeling"><a class="docs-heading-anchor" href="#Line-Modeling">Line Modeling</a><a id="Line-Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Line-Modeling" title="Permalink"></a></h3><h4 id="Branch-Interface"><a class="docs-heading-anchor" href="#Branch-Interface">Model class <code>Branch</code></a><a id="Branch-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-Interface" title="Permalink"></a></h4><p>A branch is the two-port equivalent to an injector. It needs to have two <code>Terminal()</code>s, one is called <code>:src</code>, the other <code>:dst</code>.</p><p>Examples for branches are: PI‚îÄModel branches, dynamic RL branches or transformers.</p><pre><code class="nohighlight hljs">      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
(src) ‚îÇ           ‚îÇ (dst)
  o‚Üê‚îÄ‚îÄ‚î§  Branch   ‚îú‚îÄ‚îÄ‚Üío
      ‚îÇ           ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre><p><em>Both</em> ends follow the injector interface, i.e. current leaving the device towards the terminals is always positive.</p><details class="admonition is-details" id="Code-example:-algebraic-R-line-8379e0a0d9fadd6e"><summary class="admonition-header">Code example: algebraic R-line<a class="admonition-anchor" href="#Code-example:-algebraic-R-line-8379e0a0d9fadd6e" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs">using PowerDynamics, PowerDynamics.Library, ModelingToolkit
@mtkmodel MyRLine begin
    @components begin
        src = Terminal()
        dst = Terminal()
    end
    @parameters begin
        R=0, [description=&quot;Resistance&quot;]
    end
    @equations begin
        dst.i_r ~ (dst.u_r - src.u_r)/R
        dst.i_i ~ (dst.u_i - src.u_i)/R
        src.i_r ~ -dst.i_r
        src.i_i ~ -dst.i_i
    end
end</code></pre></div></details><h4 id="MTKLine-Interface"><a class="docs-heading-anchor" href="#MTKLine-Interface">Model class: <code>MTKLine</code></a><a id="MTKLine-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#MTKLine-Interface" title="Permalink"></a></h4><p>Similar to the <code>MTKBus</code>, a <code>MTKLine</code> is a model class which represents a transmission line in the network.</p><p>It must contain two <code>LineEnd()</code> instances, one called <code>:src</code>, one called <code>:dst</code>.</p><pre><code class="nohighlight hljs"> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ MTKLine          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îÇ
 ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚î§ Branch A ‚îú‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
 ‚îÇ  ‚îÇ LineEnd ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ  ‚îÇ LineEnd ‚îÇ  ‚îÇ
 ‚îÇ  ‚îÇ  :src   ‚îú‚îÄ‚îÄo                o‚îÄ‚îÄ‚î§  :dst   ‚îÇ  ‚îÇ
 ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ
 ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚î§ Branch B ‚îú‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
 ‚îÇ                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre><p>Simple line models, which consist only of valid <code>Branch</code> models can be instantiated using the <code>MTKLine(branches...)</code> constructor.</p><p>More complex models can be created manually. For example if you want to chain multiple branches between the <code>LineEnds</code>, for example something like</p><pre><code class="nohighlight hljs">LineEnd(:src) ‚îÄ‚îÄo‚îÄ‚îÄ Transformer ‚îÄ‚îÄo‚îÄ‚îÄ Pi‚îÄLine ‚îÄ‚îÄo‚îÄ‚îÄ LineEnd(:dst)</code></pre><details class="admonition is-details" id="Code-example:-Transmission-line-with-two-pi-branches-8ba27cb4fc45d938"><summary class="admonition-header">Code example: Transmission line with two pi-branches<a class="admonition-anchor" href="#Code-example:-Transmission-line-with-two-pi-branches-8ba27cb4fc45d938" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs">using PowerDynamics, PowerDynamics.Library, ModelingToolkit
@mtkmodel MyMTKLine begin
    @components begin
        src = LineEnd()
        dst = LineEnd()
        branch1 = PiLine()
        branch2 = PiLine()
    end
    @equations begin
        connect(src.terminal, branch1.src)
        connect(src.terminal, branch2.src)
        connect(dst.terminal, branch1.dst)
        connect(dst.terminal, branch2.dst)
    end
end</code></pre><p>Alternatively, an equivalent model with multiple valid branch models in parallel could be created and instantiated with the convenience constructor</p><pre><code class="language-julia hljs">line = MTKLine(PiLine(;name=:branch1), PiLine(;name=:branch2))</code></pre></div></details><h2 id="From-MTK-Models-to-NetworkDynamics"><a class="docs-heading-anchor" href="#From-MTK-Models-to-NetworkDynamics">From MTK Models to NetworkDynamics</a><a id="From-MTK-Models-to-NetworkDynamics-1"></a><a class="docs-heading-anchor-permalink" href="#From-MTK-Models-to-NetworkDynamics" title="Permalink"></a></h2><p>Both <code>MTKLine</code> and <code>MTKBus</code> are still purely symbolic ModelingToolkit models. However they have an important property: they possess the correct input-output-structure and variable names to be compiled into <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#Component-Models-with-MTK"><code>VertexModel</code></a> and <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#Component-Models-with-MTK"><code>EdgeModel</code></a> models. To do so, PowerDynamics.jl provides the <a href="../API/#PowerDynamics.Line"><code>Line</code></a> and <a href="../API/#PowerDynamics.Bus"><code>Bus</code></a> constructors.</p><p>Putting the knowledge from this document together, we can start a short simulation of an example network:</p><pre><code class="language-julia hljs">using PowerDynamics, PowerDynamics.Library, ModelingToolkit
using Graphs, NetworkDynamics
using OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve
using CairoMakie</code></pre><p>First, we define an <code>MTKBus</code> consisting of two predefined injector models from the Library: a <code>Swing</code> generator model and a <code>PQLoad</code>. To do so, we use the <a href="../API/#PowerDynamics.MTKBus"><code>MTKBus(injectors...)</code></a> constructor.</p><pre><code class="language-julia hljs">@named swing = Swing(; Pm=1, V=1, D=0.1)
@named load = PQLoad(; Pset=-.5, Qset=0)
bus1mtk = MTKBus(swing, load; name=:swingbus)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">Model swingbus:</span>
<span class="sgr1">Subsystems (3):</span> see hierarchy(swingbus)
  busbar
  swing
  load
<span class="sgr1">Equations (25):</span>
  19 standard: see equations(swingbus)
  6 connecting: see equations(expand_connections(swingbus))
<span class="sgr1">Unknowns (27):</span> see unknowns(swingbus)
  busbar‚Çäu_r(t) [defaults to 1]: bus d-voltage
  busbar‚Çäu_i(t) [defaults to 0]: bus q-voltage
  busbar‚Çäi_r(t): bus d-current (flowing into bus)
  busbar‚Çäi_i(t): bus d-current (flowing into bus)
  busbar‚ÇäP(t): bus active power (flowing into network)
  busbar‚ÇäQ(t): bus reactive power (flowing into network)
  busbar‚Çäu_mag(t): bus voltage magnitude
  busbar‚Çäu_arg(t): bus voltage argument
  busbar‚Çäi_mag(t): bus current magnitude
  busbar‚Çäi_arg(t): bus current argument
  busbar‚Çäterminal‚Çäu_r(t): d-voltage
  busbar‚Çäterminal‚Çäu_i(t): q-voltage
  busbar‚Çäterminal‚Çäi_r(t): d-current
  busbar‚Çäterminal‚Çäi_i(t): q-current
  swing‚Çäœâ(t): Rotor frequency
  swing‚ÇäŒ∏(t): Rotor angle
  swing‚ÇäPel(t): Electrical Power injected into the grid
  swing‚Çäterminal‚Çäu_r(t): d-voltage
  swing‚Çäterminal‚Çäu_i(t): q-voltage
  swing‚Çäterminal‚Çäi_r(t): d-current
  swing‚Çäterminal‚Çäi_i(t): q-current
  load‚ÇäP(t): Active Power
  load‚ÇäQ(t): Reactive Power
  load‚Çäterminal‚Çäu_r(t): d-voltage
  load‚Çäterminal‚Çäu_i(t): q-voltage
  load‚Çäterminal‚Çäi_r(t): d-current
  load‚Çäterminal‚Çäi_i(t): q-current
<span class="sgr1">Parameters (7):</span> see parameters(swingbus)
  swing‚Çäœâ_ref [defaults to 1]: Reference frequency
  swing‚ÇäPm [defaults to 1]: Mechanical Power
  swing‚ÇäM [defaults to 0.005]: Inertia
  swing‚ÇäD [defaults to 0.1]: Damping
  swing‚ÇäV [defaults to 1]: Voltage magnitude
  load‚ÇäPset [defaults to -0.5]: Active Power demand
  load‚ÇäQset [defaults to 0]: Reactive Power demand</code></pre><p>This results in an MTK model, which fulfills the <code>MTKBus</code> interface and thus can be compiled into an actual <code>VertexModel</code> for simulation:</p><pre><code class="language-julia hljs">vertex1f = Bus(bus1mtk) # extract component function</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:swingbus</span> <span class="sgr94">NoFeedForward()</span>
 ‚îú‚îÄ 2 inputs:  [busbar‚Çäi_r, busbar‚Çäi_i]
 ‚îú‚îÄ 2 states:  [swing‚Çäœâ<span class="sgr90">‚âà0</span>, swing‚ÇäŒ∏<span class="sgr90">‚âà0</span>]
 ‚îú‚îÄ 2 outputs: [busbar‚Çäu_r=1, busbar‚Çäu_i=0]
 ‚îî‚îÄ 7 params:  [swing‚Çäœâ_ref=1, swing‚ÇäPm=1, swing‚ÇäM=0.005, swing‚ÇäD=0.1, swing‚ÇäV=1, load‚ÇäPset=-0.5, load‚ÇäQset=0]</code></pre><p>As a second bus in this example, we use a <a href><code>SlackDifferential</code></a> from the Library. This model is not an Injector but an MTKBus directly, as it does not make sense to connect anything else to a slack bus.</p><pre><code class="language-julia hljs">bus2mtk = SlackDifferential(; name=:slackbus)
vertex2f = Bus(bus2mtk) # extract component function</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:slackbus</span> <span class="sgr94">PureStateMap()</span>
 ‚îú‚îÄ 2 inputs:  [busbar‚Çäi_r, busbar‚Çäi_i]
 ‚îú‚îÄ 2 states:  [busbar‚Çäu_i=0, busbar‚Çäu_r=1]
 ‚îú‚îÄ 2 outputs: [busbar‚Çäu_r=1, busbar‚Çäu_i=0]
 ‚îî‚îÄ 2 params:  [u_init_r=1, u_init_i=0]</code></pre><p>For the connecting line, we instantiate two <a href><code>PiLine</code></a> from the library. Each PiLine fulfills the Branch interface. Therefore we can define a <code>MTKLine</code> model by putting both Branches in parallel:</p><pre><code class="language-julia hljs">@named branch1 = PiLine()
@named branch2 = PiLine()
linemtk = MTKLine(branch1, branch2; name=:powerline)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">Model swingbus:</span>
<span class="sgr1">Subsystems (3):</span> see hierarchy(swingbus)
  busbar
  swing
  load
<span class="sgr1">Equations (25):</span>
  19 standard: see equations(swingbus)
  6 connecting: see equations(expand_connections(swingbus))
<span class="sgr1">Unknowns (27):</span> see unknowns(swingbus)
  busbar‚Çäu_r(t) [defaults to 1]: bus d-voltage
  busbar‚Çäu_i(t) [defaults to 0]: bus q-voltage
  busbar‚Çäi_r(t): bus d-current (flowing into bus)
  busbar‚Çäi_i(t): bus d-current (flowing into bus)
  busbar‚ÇäP(t): bus active power (flowing into network)
  busbar‚ÇäQ(t): bus reactive power (flowing into network)
  busbar‚Çäu_mag(t): bus voltage magnitude
  busbar‚Çäu_arg(t): bus voltage argument
  busbar‚Çäi_mag(t): bus current magnitude
  busbar‚Çäi_arg(t): bus current argument
  busbar‚Çäterminal‚Çäu_r(t): d-voltage
  busbar‚Çäterminal‚Çäu_i(t): q-voltage
  busbar‚Çäterminal‚Çäi_r(t): d-current
  busbar‚Çäterminal‚Çäi_i(t): q-current
  swing‚Çäœâ(t): Rotor frequency
  swing‚ÇäŒ∏(t): Rotor angle
  swing‚ÇäPel(t): Electrical Power injected into the grid
  swing‚Çäterminal‚Çäu_r(t): d-voltage
  swing‚Çäterminal‚Çäu_i(t): q-voltage
  swing‚Çäterminal‚Çäi_r(t): d-current
  swing‚Çäterminal‚Çäi_i(t): q-current
  load‚ÇäP(t): Active Power
  load‚ÇäQ(t): Reactive Power
  load‚Çäterminal‚Çäu_r(t): d-voltage
  load‚Çäterminal‚Çäu_i(t): q-voltage
  load‚Çäterminal‚Çäi_r(t): d-current
  load‚Çäterminal‚Çäi_i(t): q-current
<span class="sgr1">Parameters (7):</span> see parameters(swingbus)
  swing‚Çäœâ_ref [defaults to 1]: Reference frequency
  swing‚ÇäPm [defaults to 1]: Mechanical Power
  swing‚ÇäM [defaults to 0.005]: Inertia
  swing‚ÇäD [defaults to 0.1]: Damping
  swing‚ÇäV [defaults to 1]: Voltage magnitude
  load‚ÇäPset [defaults to -0.5]: Active Power demand
  load‚ÇäQset [defaults to 0]: Reactive Power demand</code></pre><p>Similar to before, we need to compile the MTKModel by calling <a href="../API/#PowerDynamics.Line"><code>Line</code></a>.</p><pre><code class="language-julia hljs">edgef = Line(linemtk) # extract component function</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EdgeModel <span class="sgr1">:powerline</span> <span class="sgr94">PureFeedForward()</span>
 ‚îú‚îÄ 2/2 inputs:  src=[src‚Çäu_r, src‚Çäu_i] dst=[dst‚Çäu_r, dst‚Çäu_i]
 ‚îú‚îÄ   0 states:  []  
 ‚îú‚îÄ 2/2 outputs: src=[src‚Çäi_r, src‚Çäi_i] dst=[dst‚Çäi_r, dst‚Çäi_i]
 ‚îî‚îÄ  18 params:  [branch1‚ÇäR=0, branch1‚ÇäX=0.1, branch1‚ÇäG_src=0, branch1‚ÇäB_src=0, branch1‚ÇäG_dst=0, branch1‚ÇäB_dst=0, branch1‚Çär_src=1, branch1‚Çär_dst=1, branch1‚Çäactive=1, branch2‚ÇäR=0, branch2‚ÇäX=0.1, branch2‚ÇäG_src=0, branch2‚ÇäB_src=0, branch2‚ÇäG_dst=0, branch2‚ÇäB_dst=0, branch2‚Çär_src=1, branch2‚Çär_dst=1, branch2‚Çäactive=1]</code></pre><p>To simulate the system, we place both components on a graph and connect them. We define both graph topology as well as the models for the individual components.</p><pre><code class="language-julia hljs">g = complete_graph(2)
nw = Network(g, [vertex1f, vertex2f], edgef)
u0 = NWState(nw) # extract parameters and state from models
u0.v[1, :swing‚ÇäŒ∏] = 0 # set missing initial conditions
u0.v[1, :swing‚Çäœâ] = 1</code></pre><p>Then we can solve the problem</p><pre><code class="language-julia hljs">prob = ODEProblem(nw, uflat(u0), (0,1), pflat(u0))
sol = solve(prob, Rodas5P())</code></pre><p>And finally we can plot the solution:</p><pre><code class="language-julia hljs">fig = Figure();
ax = Axis(fig[1,1])
lines!(ax, sol; idxs=VIndex(1,:busbar‚ÇäP), label=&quot;Power injection Bus&quot;, color=Cycled(1))
lines!(ax, sol; idxs=VIndex(1,:swing‚ÇäPel), label=&quot;Power injection Swing&quot;, color=Cycled(2))
lines!(ax, sol; idxs=VIndex(1,:load‚ÇäP), label=&quot;Power injection load&quot;, color=Cycled(3))
axislegend(ax)

ax = Axis(fig[2,1])
lines!(ax, sol; idxs=VIndex(1,:busbar‚Çäu_arg), label=&quot;swing bus voltage angle&quot;, color=Cycled(1))
lines!(ax, sol; idxs=VIndex(2,:busbar‚Çäu_arg), label=&quot;slack bus voltage angle&quot;, color=Cycled(2))
axislegend(ax)</code></pre><img src="2ec25eba.png" alt="Example block output"/><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><p>Internally, we use different input/output conventions for bus and line models. The predefined models <code>BusBar()</code> and <code>LineEnd()</code> are defined in the following way:</p><h3 id="Model:-BusBar()"><a class="docs-heading-anchor" href="#Model:-BusBar()">Model: <code>BusBar()</code></a><a id="Model:-BusBar()-1"></a><a class="docs-heading-anchor-permalink" href="#Model:-BusBar()" title="Permalink"></a></h3><p>A busbar is a concrete model used in bus modeling. It represents the physical connection within a bus, the thing where all injectors and lines attach.</p><pre><code class="nohighlight hljs">           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
i_lines ‚îÄ‚îÄ‚Üí‚îÇ          ‚îÇ  (t)
           ‚îÇ  Busbar  ‚îú‚îÄ‚îÄ‚îÄo
  u_bus ‚Üê‚îÄ‚îÄ‚îÇ          ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre><p>It receives the sum of all line currents as an input and equals that to the currents flowing into the terminal. As an output, it forwards the terminal voltage to the backend.</p><h3 id="Model:-LineEnd()"><a class="docs-heading-anchor" href="#Model:-LineEnd()">Model: <code>LineEnd()</code></a><a id="Model:-LineEnd()-1"></a><a class="docs-heading-anchor-permalink" href="#Model:-LineEnd()" title="Permalink"></a></h3><p>A <code>LineEnd</code> model is very similar to the <code>BusBar</code> model. It represents one end of a transmission line.</p><pre><code class="nohighlight hljs">          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 u_bus ‚îÄ‚îÄ‚Üí‚îÇ           ‚îÇ  (t)
          ‚îÇ  LineEnd  ‚îú‚îÄ‚îÄ‚îÄo
i_line ‚Üê‚îÄ‚îÄ‚îÇ           ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre><p>It has special input/output connectors which handle the network interconnection. The main difference being the different input/output conventions for the network interface.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ Home</a><a class="docs-footer-nextpage" href="../initialization/">Initialization ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 19 August 2025 10:23">Tuesday 19 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
