<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Initialization ¬∑ PowerDynamics.jl</title><meta name="title" content="Initialization ¬∑ PowerDynamics.jl"/><meta property="og:title" content="Initialization ¬∑ PowerDynamics.jl"/><meta property="twitter:title" content="Initialization ¬∑ PowerDynamics.jl"/><meta name="description" content="Documentation for PowerDynamics.jl."/><meta property="og:description" content="Documentation for PowerDynamics.jl."/><meta property="twitter:description" content="Documentation for PowerDynamics.jl."/><meta property="og:url" content="https://juliaenergy.github.io/PowerDynamics.jl/initialization/"/><meta property="twitter:url" content="https://juliaenergy.github.io/PowerDynamics.jl/initialization/"/><link rel="canonical" href="https://juliaenergy.github.io/PowerDynamics.jl/initialization/"/><meta property="og:image" content="https://juliaenergy.github.io/PowerDynamics.jl/assets/preview.png"/><meta property="twitter:image" content="https://juliaenergy.github.io/PowerDynamics.jl/assets/preview.png"/><meta property="twitter:card" content="summary_large_image"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="PowerDynamics.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="PowerDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PowerDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../ModelingConcepts/">Modeling Concepts</a></li><li class="is-active"><a class="tocitem" href>Initialization</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Multi-Step-Initialization-Process"><span>Multi-Step Initialization Process</span></a></li><li><a class="tocitem" href="#Advanced-Component-Initialization"><span>Advanced Component Initialization</span></a></li></ul></li><li><a class="tocitem" href="../Library/">Component Library</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../julia_setup/">Julia Setup for New Users</a></li><li><a class="tocitem" href="../generated/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../generated/typical_simulation_workflow/">Typical Simulation Workflow</a></li><li><a class="tocitem" href="../generated/custom_bus/">Custom Generator Bus</a></li><li><a class="tocitem" href="../generated/custom_line/">Custom Transmission Line</a></li></ul></li><li><span class="tocitem">Advanced Examples</span><ul><li><a class="tocitem" href="../generated/ieee9bus/">IEEE 9-Bus Example</a></li><li><a class="tocitem" href="../generated/ieee39_part1/">IEEE39 Part I: Modeling</a></li><li><a class="tocitem" href="../generated/ieee39_part2/">IEEE39 Part II: Initialization</a></li><li><a class="tocitem" href="../generated/ieee39_part3/">IEEE39 Part III: Simulation</a></li><li><a class="tocitem" href="../generated/ieee39_part4/">IEEE39 Part IV: Parameter Tuning</a></li><li><a class="tocitem" href="../generated/emt_toymodel/">EMT Toymodel</a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../networkdynamics_forward/">üîó NetworkDynamics.jl Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Initialization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Initialization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaEnergy/PowerDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/main/docs/src/initialization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Powergrid-Initialization"><a class="docs-heading-anchor" href="#Powergrid-Initialization">Powergrid Initialization</a><a id="Powergrid-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Powergrid-Initialization" title="Permalink"></a></h1><p>Initialization of power grid simulations follows a multi-step approach that combines steady-state power flow analysis with dynamic component initialization. PowerDynamics.jl provides a structured framework for this process, building on the initialization capabilities of NetworkDynamics.jl.</p><p>For general background on NetworkDynamics initialization concepts, see the <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/initialization/#initialization-guide">NetworkDynamics Initialization Guide</a>.</p><p>This document is a technical description of the process, for a hands-on example which goes through the initialization process of a full network check out the <a href="../generated/ieee39_part2/#ieee39-part2">Part II of the  the IEEE39 Bus Example</a>.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Power grid initialization involves finding valid initial conditions that satisfy both:</p><ol><li><strong>Power flow constraints</strong>: Electrical power balance equations (steady-state)</li><li><strong>Dynamic constraints</strong>: Initial conditions for dynamic components (generators, controllers, etc.)</li></ol><p>This is typically achieved through a two-step process:</p><ol><li>Solve the power flow problem to determine steady-state electrical conditions</li><li>Initialize dynamic components using the power flow solution as boundary conditions, i.e. find the initial states/parameters of the dynamical models in a way, that they are in a steady state at the powerflow solution.</li></ol><p>This follows the <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/initialization/#Component-wise-Network-Initialization">Two-Step Initialization Pattern</a> described in NetworkDynamics.jl, specialized for power grid applications.</p><h2 id="Multi-Step-Initialization-Process"><a class="docs-heading-anchor" href="#Multi-Step-Initialization-Process">Multi-Step Initialization Process</a><a id="Multi-Step-Initialization-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Step-Initialization-Process" title="Permalink"></a></h2><pre><code class="language-julia hljs">nw = get_dynamic_network(...)

# extract powerflow model       # ‚é´                 ‚é´
pfnw = powerflow_model(nw)      # ‚îÇ                 ‚îÇ
# initial guess for powerflow   # ‚é¨ solve_powerflow ‚îÇ
pfs0 = NWState(pfnw)            # ‚îÇ                 ‚îÇ
# find fixpoint for pf model    # ‚îÇ                 ‚îÇ
pfs = find_fixpoint(pfnw, pfs0) # ‚é≠                 ‚é¨ initialize_from_pf[!]
# extract interface (u/i values)#                   ‚îÇ
interf = interface_values(pfs)  #                   ‚îÇ
# initialize around powerflow   #                   ‚îÇ
initialize_componentwise[!](    #                   ‚îÇ
    nw;                         #                   ‚îÇ
    default_overrides = interf  #                   ‚îÇ
)                               #                   ‚é≠</code></pre><p>This low-level step-wise interface allows users full control and complete management of the initialization process. However, PowerDynamics.jl also provides higher-level wrapper functions <a href="../API/#PowerDynamics.solve_powerflow"><code>solve_powerflow</code></a> and <a href="../API/#PowerDynamics.initialize_from_pf"><code>initialize_from_pf</code></a> that combine these steps for common use cases.</p><p>Note: This workflow above is slightly simplified, see <a href="#Integration-with-Initialization-Process">Integration with Initialization Process</a> below for the full set of commands.</p><h3 id="Step-1:-Power-Flow-Model-Extraction"><a class="docs-heading-anchor" href="#Step-1:-Power-Flow-Model-Extraction">Step 1: Power Flow Model Extraction</a><a id="Step-1:-Power-Flow-Model-Extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Power-Flow-Model-Extraction" title="Permalink"></a></h3><p>The first step creates a simplified, algebraic representation of the power grid that captures the essential power flow relationships:</p><pre><code class="language-julia hljs">pfnw = powerflow_model(nw)</code></pre><p>This function extracts the power flow network from the full dynamic network model, creating a steady-state representation. The power flow network itself is also a <code>Network</code> in the NetworkDynamics.jl sense.</p><p>The <code>powerflow_model</code> function determines the appropriate power flow representation for each dynamic Node and LineModel by: checking if <code>:pfmodel</code> metadata is set, which points to a different component model specifically designed for power flow analysis</p><p>If the <code>:pfmodel</code> is <strong>not</strong> set, it assumes that the same model is used for both power flow and dynamic simulation. This is the case for purely static models such as PiLines or PQ-Loads.</p><h3 id="Step-2:-Power-Flow-Solution"><a class="docs-heading-anchor" href="#Step-2:-Power-Flow-Solution">Step 2: Power Flow Solution</a><a id="Step-2:-Power-Flow-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Power-Flow-Solution" title="Permalink"></a></h3><p>The power flow problem is solved using NetworkDynamics.jl&#39;s <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.find_fixpoint"><code>find_fixpoint</code></a> function, which internally uses <a href="https://github.com/SciML/NonlinearSolve.jl">NonlinearSolve.jl</a>:</p><pre><code class="language-julia hljs">pfs0 = NWState(pfnw)            # Initial guess for power flow state
pfs = find_fixpoint(pfnw, pfs0) # Solve power flow equations</code></pre><p>This step finds the steady-state solution where:</p><ul><li>Active and reactive power are balanced at each bus</li><li>Generation and load are in equilibrium</li></ul><h3 id="Step-3:-Interface-Value-Extraction"><a class="docs-heading-anchor" href="#Step-3:-Interface-Value-Extraction">Step 3: Interface Value Extraction</a><a id="Step-3:-Interface-Value-Extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Interface-Value-Extraction" title="Permalink"></a></h3><p>The power flow solution provides boundary conditions for dynamic component initialization:</p><pre><code class="language-julia hljs">interf = interface_values(pfs)</code></pre><p>This extracts voltage magnitudes, voltage angles, and current flows at each network node, which serve as interface constraints for the dynamic components.</p><h3 id="Step-4:-Component-wise-Dynamic-Initialization"><a class="docs-heading-anchor" href="#Step-4:-Component-wise-Dynamic-Initialization">Step 4: Component-wise Dynamic Initialization</a><a id="Step-4:-Component-wise-Dynamic-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Component-wise-Dynamic-Initialization" title="Permalink"></a></h3><p>Finally, each dynamic component is initialized individually using the power flow solution as boundary conditions:</p><pre><code class="language-julia hljs">initialize_componentwise!(nw; default_overrides = interf)</code></pre><p>This step leverages NetworkDynamics.jl&#39;s <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/initialization/#Component-wise-Network-Initialization">component-wise initialization</a> to determine free internal states and parameters (such as rotor angles or controller setpoints), such that the <strong>steady state</strong> of the overall network matches the flows from the power flow solution (i.e. all currents and voltages match).</p><p>For details on how component initialization works, see the <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/initialization/#Single-Component-Initialization">Single Component Initialization</a> section in NetworkDynamics.jl.</p><h2 id="Advanced-Component-Initialization"><a class="docs-heading-anchor" href="#Advanced-Component-Initialization">Advanced Component Initialization</a><a id="Advanced-Component-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Component-Initialization" title="Permalink"></a></h2><p>In some cases, the standard initialization process may not be sufficient. For example, when component initialization constraints cannot be expressed solely in terms of <strong>interface variables</strong> (voltages and currents), but need access to other variables from the complete power flow solution.</p><p>NetworkDynamics.jl provides general <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/initialization/#Advanced-Component-Initialization%3A-Formulas-and-Constraints">InitFormulas and InitConstraints</a> for advanced component initialization. PowerDynamics.jl extends these concepts with power flow-aware variants that can access the complete power flow solution.</p><h3 id="PFInitConstraints-vs-PFInitFormulas"><a class="docs-heading-anchor" href="#PFInitConstraints-vs-PFInitFormulas">PFInitConstraints vs PFInitFormulas</a><a id="PFInitConstraints-vs-PFInitFormulas-1"></a><a class="docs-heading-anchor-permalink" href="#PFInitConstraints-vs-PFInitFormulas" title="Permalink"></a></h3><table><tr><th style="text-align: left">Method</th><th style="text-align: left">Purpose</th><th style="text-align: left">Usage</th></tr><tr><td style="text-align: left"><a href="../API/#PowerDynamics.PFInitConstraint"><code>PFInitConstraint</code></a></td><td style="text-align: left">Add constraint equations that must be satisfied</td><td style="text-align: left">When you need to enforce specific relationships between variables</td></tr><tr><td style="text-align: left"><a href="../API/#PowerDynamics.PFInitFormula"><code>PFInitFormula</code></a></td><td style="text-align: left">Set default initial values directly</td><td style="text-align: left">When you need to initialize variables based on power flow results</td></tr></table><p>Both methods can access any variable from the solved power flow state, not just interface variables. You get access to states, parameters and observables from the power flow model of the same component.</p><p><strong>Key difference</strong>: Constraints <strong>increase the number of equations</strong> that must be satisfied during initialization, while formulas <strong>reduce the number of free variables</strong> by setting additional default values.</p><p>These are power flow-aware extensions of NetworkDynamics.jl&#39;s standard <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.InitConstraint"><code>InitConstraint</code></a> and <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.InitFormula"><code>InitFormula</code></a> mechanisms.</p><h3 id="Power-Flow-Dependent-Initialization-Constraints"><a class="docs-heading-anchor" href="#Power-Flow-Dependent-Initialization-Constraints">Power Flow Dependent Initialization Constraints</a><a id="Power-Flow-Dependent-Initialization-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-Dependent-Initialization-Constraints" title="Permalink"></a></h3><p><a href="../API/#PowerDynamics.PFInitConstraint"><code>PFInitConstraint</code></a> adds constraint equations to the initialization problem. Unlike regular <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.InitConstraint"><code>InitConstraint</code></a>s from NetworkDynamics.jl, PFInitConstraints can access power flow variables.</p><p>The <a href="../API/#PowerDynamics.@pfinitconstraint"><code>@pfinitconstraint</code></a> macro provides convenient syntax for defining these constraints:</p><pre><code class="language-julia hljs"># Single constraint accessing both component and power flow variables
constraint = @pfinitconstraint :dynamicload‚ÇäP - @pf(:PQ‚ÇäPset)

# Multiple constraints in a single block
constraints = @pfinitconstraint begin
    :pibranch‚ÇäX - @pf(:pibranch‚ÇäX) # &quot;copy&quot; parameters from pf
    :P_gen - @pf(:P_load)          # Power balance constraint
    :AVR‚ÇäVset - :busbar‚Çäu_mag      # init controller setpoints
end

# Attach to a component
set_pfinitconstraint!(my_generator, constraints)</code></pre><h3 id="Power-Flow-Dependent-Initialization-Formulas"><a class="docs-heading-anchor" href="#Power-Flow-Dependent-Initialization-Formulas">Power Flow Dependent Initialization Formulas</a><a id="Power-Flow-Dependent-Initialization-Formulas-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-Dependent-Initialization-Formulas" title="Permalink"></a></h3><p><a href="../API/#PowerDynamics.PFInitFormula"><code>PFInitFormula</code></a> sets default initial values for variables using both component and power flow variables. Unlike constraints, formulas directly assign values without adding equations to solve.</p><p>The <a href="../API/#PowerDynamics.@pfinitformula"><code>@pfinitformula</code></a> macro provides convenient syntax:</p><pre><code class="language-julia hljs"># Single formula - set variable from component variables
@pfinitformula :Vset = sqrt(:u_r^2 + :u_i^2)

# Formula using power flow variables
@pfinitformula :Pset = @pf(:generator_power)

# Multiple formulas in a block
@pfinitformula begin
    :Vset = sqrt(:u_r^2 + :u_i^2)
    :Pset = @pf(:generator_power)
end

# Attach to a component
set_pfinitformula!(my_generator, formulas)</code></pre><h3 id="Integration-with-Initialization-Process"><a class="docs-heading-anchor" href="#Integration-with-Initialization-Process">Integration with Initialization Process</a><a id="Integration-with-Initialization-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-Initialization-Process" title="Permalink"></a></h3><p>Both PFInitConstraints and PFInitFormulas are automatically handled during <a href="../API/#PowerDynamics.initialize_from_pf"><code>initialize_from_pf[!]</code></a>:</p><ol><li><strong>Power flow solution</strong>: The power flow equations are solved first</li><li><strong>Specialization</strong>: All <code>PFInitConstraints</code> and <code>PFInitFormulas</code> are converted to regular <code>InitConstraints</code> and <code>InitFormulas</code> by &quot;specializing&quot; them with the power flow solution (i.e. the <code>@pf(:x)</code> blocks are replaced by the actual values)</li><li><strong>Component initialization</strong>: The specialized constraints and formulas are passed to NetworkDynamics.jl&#39;s component initialization</li></ol><p>This process is transparent to the user - simply define your power flow dependent initialization methods and use <code>initialize_from_pf[!]</code> as usual.</p><p>The underlying mechanism follows NetworkDynamics.jl&#39;s <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/initialization/#Single-Component-Initialization">component initialization pipeline</a>, with the power flow solution providing additional context for constraint and formula evaluation.</p><p>The extended initialization workflow (automatically done in <code>initialize_from_pf[!]</code>) looks like this:</p><pre><code class="language-julia hljs">nw = get_dynamic_network(...)
pfnw = powerflow_model(nw)
pfs0 = NWState(pfnw)
pfs = find_fixpoint(pfnw, pfs0)
interf = interface_values(pfs)

# specialize the constraints and formulas and pass them down
pfconstraints = specialize_pfinitconstraints(nw, pfs)
pfformulas    = specialize_pfinitformulas(nw, pfs)
initialize_componentwise[!](
    nw;
    default_overrides = interf,
    additional_initconstraints = pfconstraints,
    additional_initformulas = pfformulas,
)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ModelingConcepts/">¬´ Modeling Concepts</a><a class="docs-footer-nextpage" href="../Library/">Component Library ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 30 October 2025 12:58">Thursday 30 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
