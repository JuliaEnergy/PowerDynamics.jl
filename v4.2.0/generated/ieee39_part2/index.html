<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>IEEE39 Part II: Initialization Â· PowerDynamics.jl</title><meta name="title" content="IEEE39 Part II: Initialization Â· PowerDynamics.jl"/><meta property="og:title" content="IEEE39 Part II: Initialization Â· PowerDynamics.jl"/><meta property="twitter:title" content="IEEE39 Part II: Initialization Â· PowerDynamics.jl"/><meta name="description" content="Documentation for PowerDynamics.jl."/><meta property="og:description" content="Documentation for PowerDynamics.jl."/><meta property="twitter:description" content="Documentation for PowerDynamics.jl."/><meta property="og:url" content="https://juliaenergy.github.io/PowerDynamics.jl/generated/ieee39_part2/"/><meta property="twitter:url" content="https://juliaenergy.github.io/PowerDynamics.jl/generated/ieee39_part2/"/><link rel="canonical" href="https://juliaenergy.github.io/PowerDynamics.jl/generated/ieee39_part2/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PowerDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../ModelingConcepts/">Modeling Concepts</a></li><li><a class="tocitem" href="../../initialization/">Initialization</a></li><li><a class="tocitem" href="../../Library/">Component Library</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../custom_bus/">Custom Generator Bus</a></li><li><a class="tocitem" href="../custom_line/">Custom Transmission Line</a></li></ul></li><li><span class="tocitem">Advanced Examples</span><ul><li><a class="tocitem" href="../ieee9bus/">IEEE 9-Bus Example</a></li><li><a class="tocitem" href="../ieee39_part1/">IEEE39 Part I: Modeling</a></li><li class="is-active"><a class="tocitem" href>IEEE39 Part II: Initialization</a><ul class="internal"><li><a class="tocitem" href="#Power-Flow"><span>Power Flow</span></a></li><li><a class="tocitem" href="#Initialization-of-Dynamic-Components"><span>Initialization of Dynamic Components</span></a></li><li><a class="tocitem" href="#Handling-Structurally-Underconstrained-Components"><span>Handling Structurally Underconstrained Components</span></a></li><li><a class="tocitem" href="#initialize-all-components"><span>Automatic Initialization of Full Network</span></a></li></ul></li><li><a class="tocitem" href="../ieee39_part3/">IEEE39 Part III: Simulation</a></li><li><a class="tocitem" href="../ieee39_part4/">IEEE39 Part IV: Parameter Tuning</a></li><li><a class="tocitem" href="../emt_toymodel/">EMT Toymodel</a></li></ul></li><li><a class="tocitem" href="../../API/">API</a></li><li><a class="tocitem" href="../../networkdynamics_forward/">ğŸ”— NetworkDynamics.jl Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Advanced Examples</a></li><li class="is-active"><a href>IEEE39 Part II: Initialization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>IEEE39 Part II: Initialization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaEnergy/PowerDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/main/docs/examples/ieee39_part2.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ieee39-part2"><a class="docs-heading-anchor" href="#ieee39-part2">IEEE39 Bus Tutorial - Part II: Initialization</a><a id="ieee39-part2-1"></a><a class="docs-heading-anchor-permalink" href="#ieee39-part2" title="Permalink"></a></h1><p>This is the second part of a four-part tutorial series for the IEEE 39-bus test system:</p><ul><li><strong>Part I: Model Creation</strong> - Build the network structure with buses, lines, and components</li><li><strong>Part II: Initialization</strong> (this tutorial) - Perform power flow calculations and dynamic initialization</li><li><strong>Part III: Dynamic Simulation</strong> - Run time-domain simulations and analyze system behavior</li><li><strong>Part IV: Advanced Modeling &amp; Parameter Optimization</strong> - Create custom components and optimize system parameters</li></ul><p>The goal of this tutorial is to get an understanding of the initialization process in PowerDynamics.jl.</p><p>For comprehensive documentation on initialization, see:</p><ul><li><a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/initialization/#initialization-guide">NetworkDynamics.jl initialization docs</a></li><li><a href="../../initialization/#Advanced-Component-Initialization">PowerDynamics.jl initialization docs</a></li></ul><div class="admonition is-success" id="Quick-Start-9bef60e1f9dcdf77"><header class="admonition-header">Quick Start<a class="admonition-anchor" href="#Quick-Start-9bef60e1f9dcdf77" title="Permalink"></a></header><div class="admonition-body"><p>If you&#39;re looking for the practical initialization approach without diving into implementation details, jump directly to the <a href="#initialize-all-components">Initialize all Components</a> section at the end.</p></div></div><p>This tutorial goes deep into the initialization internals for educational purposes. In practice, you&#39;ll typically use the high-level functions shown at the end rather than the detailed step-by-step process demonstrated here.</p><p>As a prerequisite, we load part I of the tutorial, which contains the network model:</p><pre><code class="language-julia hljs">using PowerDynamics
EXAMPLEDIR = joinpath(pkgdir(PowerDynamics), &quot;docs&quot;, &quot;examples&quot;)
include(joinpath(EXAMPLEDIR, &quot;ieee39_part1.jl&quot;))
nw # nw object now available</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Network with 201 states and 1306 parameters
 â”œâ”€ 39 vertices (5 unique types)
 â””â”€ 46 edges (1 unique type)
Edge-Aggregation using SequentialAggregator(+)</code></pre><p>The initialization process in PowerDynamics.jl is a two-step process: first we solve the power flow, then we use the power flow results to initialize the individual network components.</p><p>There are shortcut functions to do this (as shown <a href="#initialize-all-components">later</a>), but we will go through the steps in detail for educational purposes.</p><h2 id="Power-Flow"><a class="docs-heading-anchor" href="#Power-Flow">Power Flow</a><a id="Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow" title="Permalink"></a></h2><p>To solve the power flow, we first need to get the power flow model. We can use the function <a href="../../API/#PowerDynamics.powerflow_model"><code>powerflow_model</code></a>.</p><pre><code class="language-julia hljs">pfnw = powerflow_model(nw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Network with 76 states and 814 parameters
 â”œâ”€ 39 vertices (3 unique types)
 â””â”€ 46 edges (1 unique type)
Edge-Aggregation using SequentialAggregator(+)</code></pre><p>The power flow model is a <code>Network</code> object like the original network. It is built from the original network, by calling <code>powerflow_model</code> on the individual components. For example, we have this rather complex dynamic model at bus 30:</p><pre><code class="language-julia hljs">nw[VIndex(30)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:bus30</span> <span class="sgr94">PureStateMap()</span> @ Vertex 30
 â”œâ”€  2 inputs:  [busbarâ‚Ši_r, busbarâ‚Ši_i]
 â”œâ”€ 15 states:  [ctrld_genâ‚Šgovâ‚ŠÏ„_mâ‚Šu<span class="sgr90">â‰ˆ0</span>, ctrld_genâ‚Šgovâ‚Šxg1<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šgovâ‚Šxg2<span class="sgr90">â‰ˆ0</span>, ctrld_genâ‚Šavrâ‚Švfout<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šavrâ‚Šv_fb<span class="sgr90">â‰ˆ0</span>, ctrld_genâ‚Šavrâ‚Švr<span class="sgr90">â‰ˆ0</span>, ctrld_genâ‚Šavrâ‚Švm<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_q<span class="sgr90">â‰ˆ0</span>, ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_d<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šmachineâ‚ŠEâ€²_d<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šmachineâ‚ŠEâ€²_q<span class="sgr90">â‰ˆ0</span>, ctrld_genâ‚Šmachineâ‚ŠÏ‰<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šmachineâ‚ŠÎ´<span class="sgr90">â‰ˆ0</span>, busbarâ‚Šu_r, busbarâ‚Šu_i]
 |     with diagonal mass matrix [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]
 â”œâ”€  2 outputs: [busbarâ‚Šu_r, busbarâ‚Šu_i]
 â””â”€ 42 params:  [ctrld_genâ‚Šmachineâ‚ŠR_s=0, ctrld_genâ‚Šmachineâ‚ŠX_d=1, ctrld_genâ‚Šmachineâ‚ŠX_q=0.69, ctrld_genâ‚Šmachineâ‚ŠXâ€²_d=0.31, ctrld_genâ‚Šmachineâ‚ŠXâ€²_q=0.5, ctrld_genâ‚Šmachineâ‚ŠXâ€³_d=0.25, ctrld_genâ‚Šmachineâ‚ŠXâ€³_q=0.25, ctrld_genâ‚Šmachineâ‚ŠX_ls=0.125, ctrld_genâ‚Šmachineâ‚ŠTâ€²_d0=10.2, ctrld_genâ‚Šmachineâ‚ŠTâ€³_d0=0.05, ctrld_genâ‚Šmachineâ‚ŠTâ€²_q0=2, ctrld_genâ‚Šmachineâ‚ŠTâ€³_q0=0.035, ctrld_genâ‚Šmachineâ‚ŠH=4.2, ctrld_genâ‚Šmachineâ‚ŠD=0, ctrld_genâ‚Šmachineâ‚ŠS_b=100, ctrld_genâ‚Šmachineâ‚ŠV_b=16.5, ctrld_genâ‚Šmachineâ‚ŠÏ‰_b=376.99, ctrld_genâ‚Šmachineâ‚ŠSn=1000, ctrld_genâ‚Šmachineâ‚ŠVn=16.5, ctrld_genâ‚Šavrâ‚ŠTr=0.01, ctrld_genâ‚Šavrâ‚Švref<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šavrâ‚ŠKa=5, ctrld_genâ‚Šavrâ‚ŠKe=-0.0485, ctrld_genâ‚Šavrâ‚ŠKf=0.04, ctrld_genâ‚Šavrâ‚ŠTa=0.06, ctrld_genâ‚Šavrâ‚ŠTf=1, ctrld_genâ‚Šavrâ‚ŠTe=0.25, ctrld_genâ‚Šavrâ‚Švr_min=-1, ctrld_genâ‚Šavrâ‚Švr_max=1, ctrld_genâ‚Šavrâ‚ŠE1=3.5461, ctrld_genâ‚Šavrâ‚ŠE2=4.7281, ctrld_genâ‚Šavrâ‚ŠSe1=0.08, ctrld_genâ‚Šavrâ‚ŠSe2=0.26, ctrld_genâ‚Šgovâ‚ŠÏ‰_ref=1, ctrld_genâ‚Šgovâ‚Šp_ref<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šgovâ‚ŠV_min=0, ctrld_genâ‚Šgovâ‚ŠV_max=1, ctrld_genâ‚Šgovâ‚ŠR=0.05, ctrld_genâ‚Šgovâ‚ŠT1=0.5, ctrld_genâ‚Šgovâ‚ŠT2=2.1, ctrld_genâ‚Šgovâ‚ŠT3=7.2, ctrld_genâ‚Šgovâ‚ŠDT=0]
<span class="sgr34"><span class="sgr1">Powerflow model </span></span>:pvbus with [pvâ‚ŠP=2.5, pvâ‚ŠV=1.0475]</code></pre><p>From the printout, we can see that a power flow model <code>:pvbus</code> is attached to the generator model.</p><p>We can extract the attached PV power flow model by calling <code>powerflow_model</code></p><pre><code class="language-julia hljs">powerflow_model(nw[VIndex(30)])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:pvbus</span> <span class="sgr94">PureStateMap()</span>
 â”œâ”€ 2 inputs:  [busbarâ‚Ši_r, busbarâ‚Ši_i]
 â”œâ”€ 2 states:  [busbarâ‚Šu_r=1.0475, busbarâ‚Šu_i=0]
 |    with diagonal mass matrix [0, 0]
 â”œâ”€ 2 outputs: [busbarâ‚Šu_r=1.0475, busbarâ‚Šu_i=0]
 â””â”€ 2 params:  [pvâ‚ŠP=2.5, pvâ‚ŠV=1.0475]</code></pre><p>The function <code>powerflow_model</code> checks if there is a power flow model attached (it checks the <code>:pfmodel</code> <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/metadata/#Metadata">metadata</a>).</p><p>Per component, the <code>powerflow_model</code> function will do the following:</p><ol><li>If the model has the <code>:pfmodel</code> metadata set (see <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/metadata/#Metadata">Metadata</a>), it will return the <code>VertexModel</code> stored in the metadata. In <a href="../ieee39_part1/#ieee39-part1">Part I</a> we set the <code>:pfmodel</code> metadata using the <code>pf</code> keyword to the [<code>compile_bus</code>].</li><li>If the model <strong>does not have</strong> the <code>:pfmodel</code> metadata set, PowerDynamics will check if the model itself is a valid power flow model. If so, it&#39;ll just use the dynamic model as the power flow model.</li></ol><p><strong>What is a valid power flow model?</strong>: A valid power flow model is a model that has no internal dynamics, i.e. it either has <code>dim(model) == 0</code> OR it has a zero mass matrix (i.e. only constraints).</p><p>For example, the PiLine models are completely static:</p><pre><code class="language-julia hljs">nw[EIndex(1)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EdgeModel <span class="sgr1">:piline_template</span> <span class="sgr94">PureFeedForward()</span> @ Edge 1=&gt;2
 â”œâ”€ 2/2 inputs:  src=[srcâ‚Šu_r, srcâ‚Šu_i] dst=[dstâ‚Šu_r, dstâ‚Šu_i]
 â”œâ”€   0 states:  []  
 â”œâ”€ 2/2 outputs: src=[srcâ‚Ši_r, srcâ‚Ši_i] dst=[dstâ‚Ši_r, dstâ‚Ši_i]
 â””â”€  16 params:  [pilineâ‚ŠR=0.0035, pilineâ‚ŠX=0.0411, pilineâ‚ŠG_src=0, pilineâ‚ŠB_src=0.34935, pilineâ‚ŠG_dst=0, pilineâ‚ŠB_dst=0.34935, pilineâ‚Šr_src=1, pilineâ‚Šr_dst=1, pilineâ‚ŠR_fault=0, pilineâ‚ŠX_fault=0, pilineâ‚ŠG_fault=0, pilineâ‚ŠB_fault=0, pilineâ‚Špos=0.5, pilineâ‚Šactive=1, pilineâ‚Šshortcircuit=0, pilineâ‚Šfaultimp=0]</code></pre><p>This model has no internal states and no <code>:pfmodel</code> metadata.</p><pre><code class="language-julia hljs">@assert ispfmodel(nw[EIndex(1)]) # is pf model itself
powerflow_model(nw[EIndex(1)]) === nw[EIndex(1)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>As a result, when we call <code>powerflow_model(nw)</code>, we get a <strong>completely static</strong> network, i.e. only constraints, no dynamics.</p><pre><code class="language-julia hljs">all(iszero, pfnw.mass_matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>The fully static network has the form</p><p class="math-container">\[\dot{x} = 0 = f_{\mathrm{nw}}(x, p, t)\]</p><p>Where <code>x</code> are the network states (mainly voltages <span>$u_r$</span> and <span>$u_i$</span> at the buses) and <code>p</code> are all the parameters such as <span>$P$</span>, <span>$V$</span> and <span>$Q$</span> values for bus models and line parameters for branch models.</p><p>To solve this root-finding problem, we first need to find an initial guess. The initial guess is prefilled with all the default values from the components. In our case, all parameters and states have default values attached, so the initial state is fully determined.</p><pre><code class="language-julia hljs">pfs0 = NWState(pfnw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NWState{Vector{Float64}} of Network (39 vertices, 46 edges)
  â”œâ”€ VIndex(1, :busbarâ‚Šu_i)  =&gt; 0.0
  â”œâ”€ VIndex(1, :busbarâ‚Šu_r)  =&gt; 1.0
  â”œâ”€ VIndex(2, :busbarâ‚Šu_i)  =&gt; 0.0
  â”œâ”€ VIndex(2, :busbarâ‚Šu_r)  =&gt; 1.0
  â”œâ”€ VIndex(3, :busbarâ‚Šu_i)  =&gt; 0.0
  â”œâ”€ VIndex(3, :busbarâ‚Šu_r)  =&gt; 1.0
  â”œâ”€ VIndex(4, :busbarâ‚Šu_i)  =&gt; 0.0
  â”œâ”€ VIndex(4, :busbarâ‚Šu_r)  =&gt; 1.0
  â‹®
  â”œâ”€ VIndex(36, :busbarâ‚Šu_r) =&gt; 1.0635000467300415
  â”œâ”€ VIndex(36, :busbarâ‚Šu_i) =&gt; 0.0
  â”œâ”€ VIndex(37, :busbarâ‚Šu_r) =&gt; 1.0277999639511108
  â”œâ”€ VIndex(37, :busbarâ‚Šu_i) =&gt; 0.0
  â”œâ”€ VIndex(38, :busbarâ‚Šu_r) =&gt; 1.0264999866485596
  â”œâ”€ VIndex(38, :busbarâ‚Šu_i) =&gt; 0.0
  â”œâ”€ VIndex(39, :busbarâ‚Šu_r) =&gt; 1.0299999713897705
  â””â”€ VIndex(39, :busbarâ‚Šu_i) =&gt; 0.0<span class="sgr90">
 p = NWParameter([0.0, 0.0, 0.0, 0.0, -3.22, -0.024, -5.0, -1.84, 0.0, 0.0  â€¦  0.97561, 1.0, 0.0, 0.0, 0.0, 0.0, 0.5, 1.0, 0.0, 0.0])
 t = nothing</span></code></pre><p>With the default state, we can call <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.find_fixpoint"><code>find_fixpoint</code></a>, which keeps <span>$p$</span> constant and tries to find an <span>$x$</span> such that the root-finding problem stated above is fulfilled:</p><pre><code class="language-julia hljs">pfs = find_fixpoint(pfnw, pfs0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NWState{Vector{Float64}} of Network (39 vertices, 46 edges)
  â”œâ”€ VIndex(1, :busbarâ‚Šu_i)  =&gt; -0.1537005168018229
  â”œâ”€ VIndex(1, :busbarâ‚Šu_r)  =&gt; 1.0360171229045203
  â”œâ”€ VIndex(2, :busbarâ‚Šu_i)  =&gt; -0.10513936683885863
  â”œâ”€ VIndex(2, :busbarâ‚Šu_r)  =&gt; 1.0434526576051297
  â”œâ”€ VIndex(3, :busbarâ‚Šu_i)  =&gt; -0.15402146042175108
  â”œâ”€ VIndex(3, :busbarâ‚Šu_r)  =&gt; 1.0185938884459298
  â”œâ”€ VIndex(4, :busbarâ‚Šu_i)  =&gt; -0.16752811347984345
  â”œâ”€ VIndex(4, :busbarâ‚Šu_r)  =&gt; 0.989785207542011
  â‹®
  â”œâ”€ VIndex(36, :busbarâ‚Šu_r) =&gt; 1.0522992315769326
  â”œâ”€ VIndex(36, :busbarâ‚Šu_i) =&gt; 0.15394374497652633
  â”œâ”€ VIndex(37, :busbarâ‚Šu_r) =&gt; 1.0268824837830115
  â”œâ”€ VIndex(37, :busbarâ‚Šu_i) =&gt; 0.043418088368074
  â”œâ”€ VIndex(38, :busbarâ‚Šu_r) =&gt; 1.0169838480457412
  â”œâ”€ VIndex(38, :busbarâ‚Šu_i) =&gt; 0.13944918574007406
  â”œâ”€ VIndex(39, :busbarâ‚Šu_r) =&gt; 1.01418619676775
  â””â”€ VIndex(39, :busbarâ‚Šu_i) =&gt; -0.17979515941397015<span class="sgr90">
 p = NWParameter([0.0, 0.0, 0.0, 0.0, -3.22, -0.024, -5.0, -1.84, 0.0, 0.0  â€¦  0.97561, 1.0, 0.0, 0.0, 0.0, 0.0, 0.5, 1.0, 0.0, 0.0])
 t = nothing</span></code></pre><p>As a result, we get a <code>NWState</code> object which contains the <strong>full state</strong> for the power flow model.</p><p>Since power flow model and dynamic model share the same topology and the same <em>network interface</em> (i.e. nodes create voltages, edges create currents), we can extract the interface values from the power flow model state and apply them to the dynamic model:</p><pre><code class="language-julia hljs">interf = interface_values(pfs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OrderedCollections.OrderedDict{NetworkDynamics.SymbolicIndex{Int64, Symbol}, Float64} with 524 entries:
  VIndex(1, :busbarâ‚Ši_r) =&gt; 2.22045e-15
  VIndex(1, :busbarâ‚Ši_i) =&gt; -1.58762e-14
  VIndex(1, :busbarâ‚Šu_r) =&gt; 1.03602
  VIndex(1, :busbarâ‚Šu_i) =&gt; -0.153701
  VIndex(2, :busbarâ‚Ši_r) =&gt; -2.22045e-15
  VIndex(2, :busbarâ‚Ši_i) =&gt; -9.54792e-15
  VIndex(2, :busbarâ‚Šu_r) =&gt; 1.04345
  VIndex(2, :busbarâ‚Šu_i) =&gt; -0.105139
  VIndex(3, :busbarâ‚Ši_r) =&gt; 3.08707
  VIndex(3, :busbarâ‚Ši_i) =&gt; -0.490358
  VIndex(3, :busbarâ‚Šu_r) =&gt; 1.01859
  VIndex(3, :busbarâ‚Šu_i) =&gt; -0.154021
  VIndex(4, :busbarâ‚Ši_r) =&gt; 4.60503
  VIndex(4, :busbarâ‚Ši_i) =&gt; -2.63842
  VIndex(4, :busbarâ‚Šu_r) =&gt; 0.989785
  VIndex(4, :busbarâ‚Šu_i) =&gt; -0.167528
  VIndex(5, :busbarâ‚Ši_r) =&gt; 0.0
  VIndex(5, :busbarâ‚Ši_i) =&gt; -2.22045e-14
  VIndex(5, :busbarâ‚Šu_r) =&gt; 0.993976
  â‹®                      =&gt; â‹®</code></pre><p>The interface values give us the <strong>inputs</strong> and <strong>outputs</strong> for every component in the network, i.e. for all buses we get values for</p><ul><li><code>busbarâ‚Ši_r</code> and <code>busbarâ‚Ši_i</code>: current input</li><li><code>busbarâ‚Šu_r</code> and <code>busbarâ‚Šu_i</code>: voltage output</li></ul><p>For all branches we get:</p><ul><li><code>srcâ‚Šu_r</code> and <code>srcâ‚Šu_i</code>: source side voltage input</li><li><code>dstâ‚Šu_r</code> and <code>dstâ‚Šu_i</code>: destination side voltage input</li><li><code>srcâ‚Ši_r</code> and <code>srcâ‚Ši_i</code>: source side current output</li><li><code>dstâ‚Ši_r</code> and <code>dstâ‚Ši_i</code>: destination side current output</li></ul><p>With those interface values fixed, we can go over to the second step of the initialization process: the initialization of the dynamic component.</p><h2 id="Initialization-of-Dynamic-Components"><a class="docs-heading-anchor" href="#Initialization-of-Dynamic-Components">Initialization of Dynamic Components</a><a id="Initialization-of-Dynamic-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization-of-Dynamic-Components" title="Permalink"></a></h2><p>Initialization of a bus model means, we want to find a <strong>steady state</strong> of the dynamics given the interface values from the power flow model.</p><p>Therefore, the equations for the bus models (recall from <a href="../../ModelingConcepts/#Modeling-Concepts">Modeling Concepts</a>) become</p><p class="math-container">\[\begin{aligned}
M_{\mathrm v}\,\frac{\mathrm{d}}{\mathrm{d}t}x_{\mathrm v} = \color{red}{0} &amp;= f^{\mathrm v}\left(x^{\mathrm v}, \color{red}{\sum_k\begin{bmatrix}i^k_r\\ i^k_i\end{bmatrix}}, p_{\mathrm v}, t\right)\\
\color{red}{\begin{bmatrix}u_r\\ u_i\end{bmatrix}} &amp;= g^{\mathrm v}(x^\mathrm{v},p_{\mathrm v}, t)
\end{aligned}\]</p><p>where red symbols are fixed by either the power flow solution or our steady state condition (i.e. <span>$\dot{x}=0$</span>). This leaves us with a system of <span>$N=\mathrm{dim}(x) + \mathrm{dim}(u)$</span> equations â€“ we can solve for <span>$N$</span> unknowns.</p><details class="admonition is-details" id="Edge-Initialization-Equations-7f0ffd0fcb0ce55f"><summary class="admonition-header">Edge Initialization Equations<a class="admonition-anchor" href="#Edge-Initialization-Equations-7f0ffd0fcb0ce55f" title="Permalink"></a></summary><div class="admonition-body"><p class="math-container">\[\begin{aligned}
M_{\mathrm e}\,\frac{\mathrm{d}}{\mathrm{d}t}x_{\mathrm e} = \color{red}{0} &amp;= f_{\mathrm e}\left(x_{\mathrm e}, \color{red}{\begin{bmatrix} u_r^\mathrm{src}\\u_i^\mathrm{src}\end{bmatrix}}, \color{red}{\begin{bmatrix} u_r^\mathrm{dst}\\u_i^\mathrm{dst}\end{bmatrix}},p_\mathrm{e}, t\right)\\
\color{red}{\begin{bmatrix}i_r^\mathrm{src}\\i_i^\mathrm{src}\end{bmatrix}} &amp;= g^\mathrm{src}_{\mathrm e}\left(x_{\mathrm e},\color{red}{ \begin{bmatrix} u_r^\mathrm{src}\\u_i^\mathrm{src}\end{bmatrix}}, \color{red}{\begin{bmatrix} u_r^\mathrm{dst}\\u_i^\mathrm{dst}\end{bmatrix}}, p_\mathrm{e}, t\right)\\
\color{red}{\begin{bmatrix}i_r^\mathrm{dst}\\i_i^\mathrm{dst}\end{bmatrix}} &amp;= g^\mathrm{dst}_{\mathrm e}\left(x_{\mathrm e}, \color{red}{\begin{bmatrix} u_r^\mathrm{src}\\u_i^\mathrm{src}\end{bmatrix}}, \color{red}{\begin{bmatrix} u_r^\mathrm{dst}\\u_i^\mathrm{dst}\end{bmatrix}}, p_\mathrm{e}, t\right)\\
\end{aligned}\]</p></div></details><p>Notably, the unknowns can come from either the set of states or the set of parameters. We divide the set of symbols into two sets:</p><ul><li><strong>fixed</strong> symbols have a <code>default</code> metadata set. They are considered fixed in the solution of the nonlinear system.</li><li><strong>free</strong> symbols only have a <code>guess</code> metadata set. They are considered free in the solution of the nonlinear system.</li></ul><p>Let&#39;s take a look at the bus model at bus 30:</p><pre><code class="language-julia hljs">gen = nw[VIndex(30)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:bus30</span> <span class="sgr94">PureStateMap()</span> @ Vertex 30
 â”œâ”€  2 inputs:  [busbarâ‚Ši_r, busbarâ‚Ši_i]
 â”œâ”€ 15 states:  [ctrld_genâ‚Šgovâ‚ŠÏ„_mâ‚Šu<span class="sgr90">â‰ˆ0</span>, ctrld_genâ‚Šgovâ‚Šxg1<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šgovâ‚Šxg2<span class="sgr90">â‰ˆ0</span>, ctrld_genâ‚Šavrâ‚Švfout<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šavrâ‚Šv_fb<span class="sgr90">â‰ˆ0</span>, ctrld_genâ‚Šavrâ‚Švr<span class="sgr90">â‰ˆ0</span>, ctrld_genâ‚Šavrâ‚Švm<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_q<span class="sgr90">â‰ˆ0</span>, ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_d<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šmachineâ‚ŠEâ€²_d<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šmachineâ‚ŠEâ€²_q<span class="sgr90">â‰ˆ0</span>, ctrld_genâ‚Šmachineâ‚ŠÏ‰<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šmachineâ‚ŠÎ´<span class="sgr90">â‰ˆ0</span>, busbarâ‚Šu_r, busbarâ‚Šu_i]
 |     with diagonal mass matrix [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]
 â”œâ”€  2 outputs: [busbarâ‚Šu_r, busbarâ‚Šu_i]
 â””â”€ 42 params:  [ctrld_genâ‚Šmachineâ‚ŠR_s=0, ctrld_genâ‚Šmachineâ‚ŠX_d=1, ctrld_genâ‚Šmachineâ‚ŠX_q=0.69, ctrld_genâ‚Šmachineâ‚ŠXâ€²_d=0.31, ctrld_genâ‚Šmachineâ‚ŠXâ€²_q=0.5, ctrld_genâ‚Šmachineâ‚ŠXâ€³_d=0.25, ctrld_genâ‚Šmachineâ‚ŠXâ€³_q=0.25, ctrld_genâ‚Šmachineâ‚ŠX_ls=0.125, ctrld_genâ‚Šmachineâ‚ŠTâ€²_d0=10.2, ctrld_genâ‚Šmachineâ‚ŠTâ€³_d0=0.05, ctrld_genâ‚Šmachineâ‚ŠTâ€²_q0=2, ctrld_genâ‚Šmachineâ‚ŠTâ€³_q0=0.035, ctrld_genâ‚Šmachineâ‚ŠH=4.2, ctrld_genâ‚Šmachineâ‚ŠD=0, ctrld_genâ‚Šmachineâ‚ŠS_b=100, ctrld_genâ‚Šmachineâ‚ŠV_b=16.5, ctrld_genâ‚Šmachineâ‚ŠÏ‰_b=376.99, ctrld_genâ‚Šmachineâ‚ŠSn=1000, ctrld_genâ‚Šmachineâ‚ŠVn=16.5, ctrld_genâ‚Šavrâ‚ŠTr=0.01, ctrld_genâ‚Šavrâ‚Švref<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šavrâ‚ŠKa=5, ctrld_genâ‚Šavrâ‚ŠKe=-0.0485, ctrld_genâ‚Šavrâ‚ŠKf=0.04, ctrld_genâ‚Šavrâ‚ŠTa=0.06, ctrld_genâ‚Šavrâ‚ŠTf=1, ctrld_genâ‚Šavrâ‚ŠTe=0.25, ctrld_genâ‚Šavrâ‚Švr_min=-1, ctrld_genâ‚Šavrâ‚Švr_max=1, ctrld_genâ‚Šavrâ‚ŠE1=3.5461, ctrld_genâ‚Šavrâ‚ŠE2=4.7281, ctrld_genâ‚Šavrâ‚ŠSe1=0.08, ctrld_genâ‚Šavrâ‚ŠSe2=0.26, ctrld_genâ‚Šgovâ‚ŠÏ‰_ref=1, ctrld_genâ‚Šgovâ‚Šp_ref<span class="sgr90">â‰ˆ1</span>, ctrld_genâ‚Šgovâ‚ŠV_min=0, ctrld_genâ‚Šgovâ‚ŠV_max=1, ctrld_genâ‚Šgovâ‚ŠR=0.05, ctrld_genâ‚Šgovâ‚ŠT1=0.5, ctrld_genâ‚Šgovâ‚ŠT2=2.1, ctrld_genâ‚Šgovâ‚ŠT3=7.2, ctrld_genâ‚Šgovâ‚ŠDT=0]
<span class="sgr34"><span class="sgr1">Powerflow model </span></span>:pvbus with [pvâ‚ŠP=2.5, pvâ‚ŠV=1.0475]</code></pre><p>We have a system with 15 States and 42 parameters. Of those, most are fixed, i.e. have a <code>default</code> metadata set. In the VertexModel printout, defaults are shown with <code>=</code> while guesses are shown with <code>â‰ˆ</code>. We can use <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.dump_initial_state"><code>dump_initial_state</code></a> to get an overview of the free and set states:</p><pre><code class="language-julia hljs">dump_initial_state(gen; obs=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">Inputs:</span>
  busbarâ‚Ši_i              = <span class="sgr31"> uninitialized</span>
  busbarâ‚Ši_r              = <span class="sgr31"> uninitialized</span>
<span class="sgr1">States:</span>
  busbarâ‚Šu_i              = <span class="sgr31"> uninitialized</span>
  busbarâ‚Šu_r              = <span class="sgr31"> uninitialized</span>
  ctrld_genâ‚Šavrâ‚Šv_fb      = <span class="sgr31"> uninitialized</span> (guess  0)
  ctrld_genâ‚Šavrâ‚Švfout     = <span class="sgr31"> uninitialized</span> (guess  1) (bounds 0.0..Inf)
  ctrld_genâ‚Šavrâ‚Švm        = <span class="sgr31"> uninitialized</span> (guess  1)
  ctrld_genâ‚Šavrâ‚Švr        = <span class="sgr31"> uninitialized</span> (guess  0)
  ctrld_genâ‚Šgovâ‚Šxg1       = <span class="sgr31"> uninitialized</span> (guess  1)
  ctrld_genâ‚Šgovâ‚Šxg2       = <span class="sgr31"> uninitialized</span> (guess  0)
  ctrld_genâ‚Šgovâ‚ŠÏ„_mâ‚Šu     = <span class="sgr31"> uninitialized</span> (guess  0)
  ctrld_genâ‚Šmachineâ‚ŠEâ€²_d  = <span class="sgr31"> uninitialized</span> (guess  1)
  ctrld_genâ‚Šmachineâ‚ŠEâ€²_q  = <span class="sgr31"> uninitialized</span> (guess  0)
  ctrld_genâ‚Šmachineâ‚ŠÎ´     = <span class="sgr31"> uninitialized</span> (guess  0)
  ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_d  = <span class="sgr31"> uninitialized</span> (guess  1)
  ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_q  = <span class="sgr31"> uninitialized</span> (guess  0)
  ctrld_genâ‚Šmachineâ‚ŠÏ‰     = <span class="sgr31"> uninitialized</span> (guess  1)
<span class="sgr1">Outputs:</span>
  busbarâ‚Šu_i              = <span class="sgr31"> uninitialized</span>
  busbarâ‚Šu_r              = <span class="sgr31"> uninitialized</span>
<span class="sgr1">Parameters:</span>
  ctrld_genâ‚Šavrâ‚ŠE1        = <span class="sgr34"> 3.5461</span>
  ctrld_genâ‚Šavrâ‚ŠE2        = <span class="sgr34"> 4.7281</span>
  ctrld_genâ‚Šavrâ‚ŠKa        = <span class="sgr34"> 5</span>
  ctrld_genâ‚Šavrâ‚ŠKe        = <span class="sgr34">-0.0485</span>
  ctrld_genâ‚Šavrâ‚ŠKf        = <span class="sgr34"> 0.04</span>
  ctrld_genâ‚Šavrâ‚ŠSe1       = <span class="sgr34"> 0.08</span>
  ctrld_genâ‚Šavrâ‚ŠSe2       = <span class="sgr34"> 0.26</span>
  ctrld_genâ‚Šavrâ‚ŠTa        = <span class="sgr34"> 0.06</span>
  ctrld_genâ‚Šavrâ‚ŠTe        = <span class="sgr34"> 0.25</span>
  ctrld_genâ‚Šavrâ‚ŠTf        = <span class="sgr34"> 1</span>
  ctrld_genâ‚Šavrâ‚ŠTr        = <span class="sgr34"> 0.01</span>
  ctrld_genâ‚Šavrâ‚Švr_max    = <span class="sgr34"> 1</span>
  ctrld_genâ‚Šavrâ‚Švr_min    = <span class="sgr34">-1</span>
  ctrld_genâ‚Šavrâ‚Švref      = <span class="sgr31"> uninitialized</span> (guess  1)
  ctrld_genâ‚Šgovâ‚ŠDT        = <span class="sgr34"> 0</span>
  ctrld_genâ‚Šgovâ‚ŠR         = <span class="sgr34"> 0.05</span>
  ctrld_genâ‚Šgovâ‚ŠT1        = <span class="sgr34"> 0.5</span>
  ctrld_genâ‚Šgovâ‚ŠT2        = <span class="sgr34"> 2.1</span>
  ctrld_genâ‚Šgovâ‚ŠT3        = <span class="sgr34"> 7.2</span>
  ctrld_genâ‚Šgovâ‚ŠV_max     = <span class="sgr34"> 1</span>
  ctrld_genâ‚Šgovâ‚ŠV_min     = <span class="sgr34"> 0</span>
  ctrld_genâ‚Šgovâ‚Šp_ref     = <span class="sgr31"> uninitialized</span> (guess  1)
  ctrld_genâ‚Šgovâ‚ŠÏ‰_ref     = <span class="sgr34"> 1</span>
  ctrld_genâ‚Šmachineâ‚ŠD     = <span class="sgr34"> 0</span>
  ctrld_genâ‚Šmachineâ‚ŠH     = <span class="sgr34"> 4.2</span>
  ctrld_genâ‚Šmachineâ‚ŠR_s   = <span class="sgr34"> 0</span>
  ctrld_genâ‚Šmachineâ‚ŠS_b   = <span class="sgr34"> 100</span>
  ctrld_genâ‚Šmachineâ‚ŠSn    = <span class="sgr34"> 1000</span>
  ctrld_genâ‚Šmachineâ‚ŠTâ€²_d0 = <span class="sgr34"> 10.2</span>
  ctrld_genâ‚Šmachineâ‚ŠTâ€²_q0 = <span class="sgr34"> 2</span>
  ctrld_genâ‚Šmachineâ‚ŠTâ€³_d0 = <span class="sgr34"> 0.05</span>
  ctrld_genâ‚Šmachineâ‚ŠTâ€³_q0 = <span class="sgr34"> 0.035</span>
  ctrld_genâ‚Šmachineâ‚ŠV_b   = <span class="sgr34"> 16.5</span>
  ctrld_genâ‚Šmachineâ‚ŠVn    = <span class="sgr34"> 16.5</span>
  ctrld_genâ‚Šmachineâ‚ŠX_d   = <span class="sgr34"> 1</span>
  ctrld_genâ‚Šmachineâ‚ŠX_ls  = <span class="sgr34"> 0.125</span>
  ctrld_genâ‚Šmachineâ‚ŠX_q   = <span class="sgr34"> 0.69</span>
  ctrld_genâ‚Šmachineâ‚ŠXâ€²_d  = <span class="sgr34"> 0.31</span>
  ctrld_genâ‚Šmachineâ‚ŠXâ€²_q  = <span class="sgr34"> 0.5</span>
  ctrld_genâ‚Šmachineâ‚ŠXâ€³_d  = <span class="sgr34"> 0.25</span>
  ctrld_genâ‚Šmachineâ‚ŠXâ€³_q  = <span class="sgr34"> 0.25</span>
  ctrld_genâ‚Šmachineâ‚ŠÏ‰_b   = <span class="sgr34"> 376.99</span></code></pre><p>Right now, we have 2 free parameters, 2 free inputs, 2 free outputs and 15 free states. We can use <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.initialize_component"><code>initialize_component</code></a> to find values for the free symbols:</p><pre><code class="language-julia hljs">initialize_component(gen)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr91"><span class="sgr1">â”Œ Error: </span></span>Initialization problem underconstraint. 17 Equations for 21 free variables: [:busbarâ‚Šu_r, :busbarâ‚Šu_i, :ctrld_genâ‚Šgovâ‚ŠÏ„_mâ‚Šu, :ctrld_genâ‚Šgovâ‚Šxg1, :ctrld_genâ‚Šgovâ‚Šxg2, :ctrld_genâ‚Šavrâ‚Švfout, :ctrld_genâ‚Šavrâ‚Šv_fb, :ctrld_genâ‚Šavrâ‚Švr, :ctrld_genâ‚Šavrâ‚Švm, :ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_q, :ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_d, :ctrld_genâ‚Šmachineâ‚ŠEâ€²_d, :ctrld_genâ‚Šmachineâ‚ŠEâ€²_q, :ctrld_genâ‚Šmachineâ‚ŠÏ‰, :ctrld_genâ‚Šmachineâ‚ŠÎ´, :busbarâ‚Šu_r, :busbarâ‚Šu_i, :busbarâ‚Ši_r, :busbarâ‚Ši_i, :ctrld_genâ‚Šavrâ‚Švref, :ctrld_genâ‚Šgovâ‚Šp_ref]. Consider passing additional constraints using `InitConstraint`.
<span class="sgr91"><span class="sgr1">â”” </span></span><span class="sgr90">@ Main ieee39_part2.md:188</span></code></pre><p>Wait! The initialization failed! Why? Well, we need to apply additional defaults, so called <code>default_overwrites</code> for the inputs/outputs to make the system solvable.</p><pre><code class="language-julia hljs">interf_v30 = Dict( # manually define interface values for demonstration
    :busbarâ‚Šu_r =&gt; 1.04573,
    :busbarâ‚Šu_i =&gt; -0.0609188,
    :busbarâ‚Ši_i =&gt; 1.53174,
    :busbarâ‚Ši_r =&gt; -2.30145,
)
initialize_component(gen; default_overrides=interf_v30)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Apply positivity/negativity conserving variable transformation on [:ctrld_genâ‚Šavrâ‚Švfout] to satisfy bounds.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization problem is overconstrained (15 vars for 17 equations). Create NonlinearLeastSquaresProblem for [:ctrld_genâ‚Šgovâ‚ŠÏ„_mâ‚Šu, :ctrld_genâ‚Šgovâ‚Šxg1, :ctrld_genâ‚Šgovâ‚Šxg2, :ctrld_genâ‚Šavrâ‚Švfout, :ctrld_genâ‚Šavrâ‚Šv_fb, :ctrld_genâ‚Šavrâ‚Švr, :ctrld_genâ‚Šavrâ‚Švm, :ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_q, :ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_d, :ctrld_genâ‚Šmachineâ‚ŠEâ€²_d, :ctrld_genâ‚Šmachineâ‚ŠEâ€²_q, :ctrld_genâ‚Šmachineâ‚ŠÏ‰, :ctrld_genâ‚Šmachineâ‚ŠÎ´, :ctrld_genâ‚Šavrâ‚Švref, :ctrld_genâ‚Šgovâ‚Šp_ref].
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization successful with residual 2.2358126609832515e-14</code></pre><div class="admonition is-info" id="Mutating-vs-non-mutating-Initialization-7856ff491816911"><header class="admonition-header">Mutating vs non-mutating Initialization<a class="admonition-anchor" href="#Mutating-vs-non-mutating-Initialization-7856ff491816911" title="Permalink"></a></header><div class="admonition-body"><p>The non mutating <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.initialize_component"><code>initialize_component</code></a> returns a dictionary containing a full initialized component state. That can be useful for certain purposes, often it is easier to work with the <em>mutating</em> version of initialization function, which will write the initialized values back to the component metadata (i.e setting the <code>:init</code> property for the symbols).</p></div></div><p>Let&#39;s call the mutating <code>initialize_component!</code> function to write the initialized values back to the component and inspect the initial state using <code>dump_initial_state</code>:</p><pre><code class="language-julia hljs">initialize_component!(gen; default_overrides=interf_v30)
dump_initial_state(gen; obs=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Set additional default for busbarâ‚Šu_r: 1.04573
Set additional default for busbarâ‚Šu_i: -0.0609188
Set additional default for busbarâ‚Ši_i: 1.53174
Set additional default for busbarâ‚Ši_r: -2.30145
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Apply positivity/negativity conserving variable transformation on [:ctrld_genâ‚Šavrâ‚Švfout] to satisfy bounds.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization problem is overconstrained (15 vars for 17 equations). Create NonlinearLeastSquaresProblem for [:ctrld_genâ‚Šgovâ‚ŠÏ„_mâ‚Šu, :ctrld_genâ‚Šgovâ‚Šxg1, :ctrld_genâ‚Šgovâ‚Šxg2, :ctrld_genâ‚Šavrâ‚Švfout, :ctrld_genâ‚Šavrâ‚Šv_fb, :ctrld_genâ‚Šavrâ‚Švr, :ctrld_genâ‚Šavrâ‚Švm, :ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_q, :ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_d, :ctrld_genâ‚Šmachineâ‚ŠEâ€²_d, :ctrld_genâ‚Šmachineâ‚ŠEâ€²_q, :ctrld_genâ‚Šmachineâ‚ŠÏ‰, :ctrld_genâ‚Šmachineâ‚ŠÎ´, :ctrld_genâ‚Šavrâ‚Švref, :ctrld_genâ‚Šgovâ‚Šp_ref].
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization successful with residual 2.2358126609832515e-14
<span class="sgr1">Inputs:</span>
  busbarâ‚Ši_i                     = <span class="sgr34"> 1.5317</span>
  busbarâ‚Ši_r                     = <span class="sgr34">-2.3014</span>
<span class="sgr1">States:</span>
  busbarâ‚Šu_i                     = <span class="sgr34">-0.060919</span>
  busbarâ‚Šu_r                     = <span class="sgr34"> 1.0457</span>
  ctrld_genâ‚Šavrâ‚Šv_fb             = <span class="sgr33"> 7.2327e-23</span> (guess  0)
  ctrld_genâ‚Šavrâ‚Švfout            = <span class="sgr33"> 1.2089</span>     (guess  1) (bounds 0.0..Inf)
  ctrld_genâ‚Šavrâ‚Švm               = <span class="sgr33"> 1.0475</span>     (guess  1)
  ctrld_genâ‚Šavrâ‚Švr               = <span class="sgr33">-0.058633</span>   (guess  0)
  ctrld_genâ‚Šgovâ‚Šxg1              = <span class="sgr33"> 0.25</span>       (guess  1)
  ctrld_genâ‚Šgovâ‚Šxg2              = <span class="sgr33"> 0.25</span>       (guess  0)
  ctrld_genâ‚Šgovâ‚ŠÏ„_mâ‚Šu            = <span class="sgr33"> 0.25</span>       (guess  0)
  ctrld_genâ‚Šmachineâ‚ŠEâ€²_d         = <span class="sgr33"> 0.041105</span>   (guess  1)
  ctrld_genâ‚Šmachineâ‚ŠEâ€²_q         = <span class="sgr33"> 1.0902</span>     (guess  0)
  ctrld_genâ‚Šmachineâ‚ŠÎ´            = <span class="sgr33"> 0.084805</span>   (guess  0)
  ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_d         = <span class="sgr33"> 1.0583</span>     (guess  1)
  ctrld_genâ‚Šmachineâ‚ŠÏˆâ€³_q         = <span class="sgr33">-0.12223</span>    (guess  0)
  ctrld_genâ‚Šmachineâ‚ŠÏ‰            = <span class="sgr33"> 1</span>          (guess  1)
<span class="sgr1">Outputs:</span>
  busbarâ‚Šu_i                     = <span class="sgr34">-0.060919</span>
  busbarâ‚Šu_r                     = <span class="sgr34"> 1.0457</span>
<span class="sgr1">Parameters:</span>
  ctrld_genâ‚Šavrâ‚ŠE1               = <span class="sgr34"> 3.5461</span>
  ctrld_genâ‚Šavrâ‚ŠE2               = <span class="sgr34"> 4.7281</span>
  ctrld_genâ‚Šavrâ‚ŠKa               = <span class="sgr34"> 5</span>
  ctrld_genâ‚Šavrâ‚ŠKe               = <span class="sgr34">-0.0485</span>
  ctrld_genâ‚Šavrâ‚ŠKf               = <span class="sgr34"> 0.04</span>
  ctrld_genâ‚Šavrâ‚ŠSe1              = <span class="sgr34"> 0.08</span>
  ctrld_genâ‚Šavrâ‚ŠSe2              = <span class="sgr34"> 0.26</span>
  ctrld_genâ‚Šavrâ‚ŠTa               = <span class="sgr34"> 0.06</span>
  ctrld_genâ‚Šavrâ‚ŠTe               = <span class="sgr34"> 0.25</span>
  ctrld_genâ‚Šavrâ‚ŠTf               = <span class="sgr34"> 1</span>
  ctrld_genâ‚Šavrâ‚ŠTr               = <span class="sgr34"> 0.01</span>
  ctrld_genâ‚Šavrâ‚Švr_max           = <span class="sgr34"> 1</span>
  ctrld_genâ‚Šavrâ‚Švr_min           = <span class="sgr34">-1</span>
  ctrld_genâ‚Šavrâ‚Švref             = <span class="sgr33"> 1.0358</span>     (guess  1)
  ctrld_genâ‚Šgovâ‚ŠDT               = <span class="sgr34"> 0</span>
  ctrld_genâ‚Šgovâ‚ŠR                = <span class="sgr34"> 0.05</span>
  ctrld_genâ‚Šgovâ‚ŠT1               = <span class="sgr34"> 0.5</span>
  ctrld_genâ‚Šgovâ‚ŠT2               = <span class="sgr34"> 2.1</span>
  ctrld_genâ‚Šgovâ‚ŠT3               = <span class="sgr34"> 7.2</span>
  ctrld_genâ‚Šgovâ‚ŠV_max            = <span class="sgr34"> 1</span>
  ctrld_genâ‚Šgovâ‚ŠV_min            = <span class="sgr34"> 0</span>
  ctrld_genâ‚Šgovâ‚Šp_ref            = <span class="sgr33"> 0.0125</span>     (guess  1)
  ctrld_genâ‚Šgovâ‚ŠÏ‰_ref            = <span class="sgr34"> 1</span>
  ctrld_genâ‚Šmachineâ‚ŠD            = <span class="sgr34"> 0</span>
  ctrld_genâ‚Šmachineâ‚ŠH            = <span class="sgr34"> 4.2</span>
  ctrld_genâ‚Šmachineâ‚ŠR_s          = <span class="sgr34"> 0</span>
  ctrld_genâ‚Šmachineâ‚ŠS_b          = <span class="sgr34"> 100</span>
  ctrld_genâ‚Šmachineâ‚ŠSn           = <span class="sgr34"> 1000</span>
  ctrld_genâ‚Šmachineâ‚ŠTâ€²_d0        = <span class="sgr34"> 10.2</span>
  ctrld_genâ‚Šmachineâ‚ŠTâ€²_q0        = <span class="sgr34"> 2</span>
  ctrld_genâ‚Šmachineâ‚ŠTâ€³_d0        = <span class="sgr34"> 0.05</span>
  ctrld_genâ‚Šmachineâ‚ŠTâ€³_q0        = <span class="sgr34"> 0.035</span>
  ctrld_genâ‚Šmachineâ‚ŠV_b          = <span class="sgr34"> 16.5</span>
  ctrld_genâ‚Šmachineâ‚ŠVn           = <span class="sgr34"> 16.5</span>
  ctrld_genâ‚Šmachineâ‚ŠX_d          = <span class="sgr34"> 1</span>
  ctrld_genâ‚Šmachineâ‚ŠX_ls         = <span class="sgr34"> 0.125</span>
  ctrld_genâ‚Šmachineâ‚ŠX_q          = <span class="sgr34"> 0.69</span>
  ctrld_genâ‚Šmachineâ‚ŠXâ€²_d         = <span class="sgr34"> 0.31</span>
  ctrld_genâ‚Šmachineâ‚ŠXâ€²_q         = <span class="sgr34"> 0.5</span>
  ctrld_genâ‚Šmachineâ‚ŠXâ€³_d         = <span class="sgr34"> 0.25</span>
  ctrld_genâ‚Šmachineâ‚ŠXâ€³_q         = <span class="sgr34"> 0.25</span>
  ctrld_genâ‚Šmachineâ‚ŠÏ‰_b          = <span class="sgr34"> 376.99</span></code></pre><p>In the state dump we see how the initialization successfully set all the previously unknown values, including the control parameters <code>avrâ‚Švref</code> and <code>govâ‚Šp_ref</code>. We have our first initialized component!</p><p>However, in practice it&#39;s not always so easy.</p><h2 id="Handling-Structurally-Underconstrained-Components"><a class="docs-heading-anchor" href="#Handling-Structurally-Underconstrained-Components">Handling Structurally Underconstrained Components</a><a id="Handling-Structurally-Underconstrained-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-Structurally-Underconstrained-Components" title="Permalink"></a></h2><p>Recalling from <a href="../ieee39_part1/#ieee39-part1">Part 1</a>, we have an uncontrolled machine together with a load on bus 39.</p><pre><code class="nohighlight hljs">            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            â•‘ Unctr. Ma. Load Bus (compiled) â•‘
            â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â•‘
  Network   â•‘  â”‚MTKBus      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â•‘
 interface  â•‘  â”‚          â”Œâ”€â”¤ Machine â”‚ â”‚    â•‘
  current â”€â”€â”€â”€â†’â”‚ â”Œâ”€â”€â”€â”€â”€â”€â” â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â•‘
            â•‘  â”‚ â”‚BusBarâ”œâ”€o             â”‚    â•‘
  voltage â†â”€â”€â”€â”€â”‚ â””â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”    â”‚    â•‘
            â•‘  â”‚          â””â”€â”¤ Load â”‚    â”‚    â•‘
            â•‘  â”‚            â””â”€â”€â”€â”€â”€â”€â”˜    â”‚    â•‘
            â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â•‘
            â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</code></pre><p>If we try to initialize this component as before, we run into a problem:</p><pre><code class="language-julia hljs">interf_v39 = Dict(
  :busbarâ‚Šu_r =&gt; 1.01419,
  :busbarâ‚Šu_i =&gt; -0.179795,
  :busbarâ‚Ši_i =&gt; -1.72223,
  :busbarâ‚Ši_r =&gt; 0.720135,
)
initialize_component!(nw[VIndex(39)]; default_overrides=interf_v39)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Set additional default for busbarâ‚Šu_r: 1.01419
Set additional default for busbarâ‚Šu_i: -0.179795
Set additional default for busbarâ‚Ši_i: -1.72223
Set additional default for busbarâ‚Ši_r: 0.720135
<span class="sgr91"><span class="sgr1">â”Œ Error: </span></span>Initialization problem underconstraint. 10 Equations for 11 free variables: [:machineâ‚Šterminalâ‚Ši_i, :machineâ‚Šterminalâ‚Ši_r, :machineâ‚ŠÏˆâ€³_q, :machineâ‚ŠÏˆâ€³_d, :machineâ‚ŠEâ€²_d, :machineâ‚ŠEâ€²_q, :machineâ‚ŠÏ‰, :machineâ‚ŠÎ´, :machineâ‚Švf_set, :machineâ‚ŠÏ„_m_set, :ZIPLoadâ‚ŠVset]. Consider passing additional constraints using `InitConstraint`.
<span class="sgr91"><span class="sgr1">â”” </span></span><span class="sgr90">@ Main ieee39_part2.md:251</span></code></pre><p>Even though we set the interface values, the problem is still underconstrained! Let&#39;s check the free symbols:</p><pre><code class="language-julia hljs">println(&quot;free u: &quot;, free_u(nw[VIndex(39)]))
println(&quot;free p: &quot;, free_p(nw[VIndex(39)]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">free u: [:machineâ‚Šterminalâ‚Ši_i, :machineâ‚Šterminalâ‚Ši_r, :machineâ‚ŠÏˆâ€³_q, :machineâ‚ŠÏˆâ€³_d, :machineâ‚ŠEâ€²_d, :machineâ‚ŠEâ€²_q, :machineâ‚ŠÏ‰, :machineâ‚ŠÎ´]
free p: [:machineâ‚Švf_set, :machineâ‚ŠÏ„_m_set, :ZIPLoadâ‚ŠVset]</code></pre><p>We see 8 free states and 3 free parameters, however we only have 8 state + 2 output equations:</p><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:bus39</span> <span class="sgr94">NoFeedForward()</span> @ Vertex 39
 â”œâ”€  2 inputs:  [busbarâ‚Ši_r=0.72013, busbarâ‚Ši_i=-1.7222]
 â”œâ”€  8 states:  [machineâ‚Šterminalâ‚Ši_i<span class="sgr90">â‰ˆ0</span>, machineâ‚Šterminalâ‚Ši_r<span class="sgr90">â‰ˆ0</span>, machineâ‚ŠÏˆâ€³_q<span class="sgr90">â‰ˆ0</span>, machineâ‚ŠÏˆâ€³_d<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠEâ€²_d<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠEâ€²_q<span class="sgr90">â‰ˆ0</span>, machineâ‚ŠÏ‰<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠÎ´<span class="sgr90">â‰ˆ0</span>]
 |     with diagonal mass matrix [0, 0, 1, 1, 1, 1, 1, 1]
 â”œâ”€  2 outputs: [busbarâ‚Šu_r=1.0142, busbarâ‚Šu_i=-0.1798]
 â””â”€ 30 params:  [machineâ‚Švf_set<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠÏ„_m_set<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠR_s=0, machineâ‚ŠX_d=2, machineâ‚ŠX_q=1.9, machineâ‚ŠXâ€²_d=0.6, machineâ‚ŠXâ€²_q=0.8, machineâ‚ŠXâ€³_d=0.4, machineâ‚ŠXâ€³_q=0.4, machineâ‚ŠX_ls=0.3, machineâ‚ŠTâ€²_d0=7, machineâ‚ŠTâ€³_d0=0.05, machineâ‚ŠTâ€²_q0=0.7, machineâ‚ŠTâ€³_q0=0.035, machineâ‚ŠH=5, machineâ‚ŠD=0, machineâ‚ŠS_b=100, machineâ‚ŠV_b=345, machineâ‚ŠÏ‰_b=376.99, machineâ‚ŠSn=10000, machineâ‚ŠVn=345, ZIPLoadâ‚ŠPset=-11.04, ZIPLoadâ‚ŠQset=-2.5, ZIPLoadâ‚ŠVset<span class="sgr90">â‰ˆ1</span>, ZIPLoadâ‚ŠKpZ=1, ZIPLoadâ‚ŠKqZ=1, ZIPLoadâ‚ŠKpI=0, ZIPLoadâ‚ŠKqI=0, ZIPLoadâ‚ŠKpC=0, ZIPLoadâ‚ŠKqC=0]
<span class="sgr34"><span class="sgr1">Powerflow model </span></span>:pvbus with [pvâ‚ŠP=-1.04, pvâ‚ŠV=1.03]</code></pre><p>Even though we have enough set parameters to initialize machine and load on its own, we cannot do it simultaneously. Intuitively speaking, it&#39;s just not clear for the solver which of the two components provides how much power.</p><p>To solve this, we have essentially 3 methods:</p><h3 id="Method-1:-Manual-setting-of-defaults"><a class="docs-heading-anchor" href="#Method-1:-Manual-setting-of-defaults">Method 1: Manual setting of defaults</a><a id="Method-1:-Manual-setting-of-defaults-1"></a><a class="docs-heading-anchor-permalink" href="#Method-1:-Manual-setting-of-defaults" title="Permalink"></a></h3><p>The simplest solution is to manually set more defaults. For example, we know that we want to initialize the ZIP load around the initialization point, i.e. <span>$V_\mathrm{set}$</span> should be the same as the bus voltage magnitude.</p><pre><code class="language-julia hljs">vm_manual = copy(nw[VIndex(39)])
u_r = get_initial_state(vm_manual, :busbarâ‚Šu_r)
u_i = get_initial_state(vm_manual, :busbarâ‚Šu_i)
set_default!(vm_manual, :ZIPLoadâ‚ŠVset, sqrt(u_r^2 + u_i^2))
initialize_component!(vm_manual)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Apply positivity/negativity conserving variable transformation on [:machineâ‚Švf_set, :machineâ‚ŠÏ„_m_set] to satisfy bounds.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization problem is fully constrained. Created NonlinearLeastSquaresProblem for [:machineâ‚Šterminalâ‚Ši_i, :machineâ‚Šterminalâ‚Ši_r, :machineâ‚ŠÏˆâ€³_q, :machineâ‚ŠÏˆâ€³_d, :machineâ‚ŠEâ€²_d, :machineâ‚ŠEâ€²_q, :machineâ‚ŠÏ‰, :machineâ‚ŠÎ´, :machineâ‚Švf_set, :machineâ‚ŠÏ„_m_set]
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization successful with residual 1.2820961574625452e-15</code></pre><p>The initialization succeeded now!</p><div class="admonition is-info" id="No-more-default_overrides-2acc9b91718652b9"><header class="admonition-header">No more default_overrides<a class="admonition-anchor" href="#No-more-default_overrides-2acc9b91718652b9" title="Permalink"></a></header><div class="admonition-body"><p>Note how we can skip the <code>default_overrides</code> keyword argument, since the first (failing) call of <code>initialize_component!</code> already &quot;burned in&quot; the default overrides! Mutating state is a powerful tool, but it needs care!</p></div></div><h3 id="Method-2:-Adding-an-init_formula"><a class="docs-heading-anchor" href="#Method-2:-Adding-an-init_formula">Method 2: Adding an <code>init_formula</code></a><a id="Method-2:-Adding-an-init_formula-1"></a><a class="docs-heading-anchor-permalink" href="#Method-2:-Adding-an-init_formula" title="Permalink"></a></h3><p>The problem with the previous method is that it is quite manual. In reality, we would never go through this very manual initialization process. The fact that the model is structurally underconstrained is a property of the model and should therefore be handled by the model. To do so, NetworkDynamics.jl provides the <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.InitFormula"><code>InitFormula</code></a> mechanism.</p><p>An <code>InitFormula</code> is a symbolic formula that is evaluated during the initialization process. It is attached to the VertexModel so it can be evaluated automatically during the initialization process. The &quot;formula&quot; we want to apply is simply the equation</p><p class="math-container">\[V_\mathrm{set} = \sqrt{u_r^2 + u_i^2}\]</p><pre><code class="language-julia hljs">vm_formula = copy(nw[VIndex(39)])
formula = @initformula :ZIPLoadâ‚ŠVset = sqrt(:busbarâ‚Šu_r^2 + :busbarâ‚Šu_i^2)
set_initformula!(vm_formula, formula)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:bus39</span> <span class="sgr94">NoFeedForward()</span> @ Vertex 39
 â”œâ”€  2 inputs:  [busbarâ‚Ši_r=0.72013, busbarâ‚Ši_i=-1.7222]
 â”œâ”€  8 states:  [machineâ‚Šterminalâ‚Ši_i<span class="sgr90">â‰ˆ0</span>, machineâ‚Šterminalâ‚Ši_r<span class="sgr90">â‰ˆ0</span>, machineâ‚ŠÏˆâ€³_q<span class="sgr90">â‰ˆ0</span>, machineâ‚ŠÏˆâ€³_d<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠEâ€²_d<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠEâ€²_q<span class="sgr90">â‰ˆ0</span>, machineâ‚ŠÏ‰<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠÎ´<span class="sgr90">â‰ˆ0</span>]
 |     with diagonal mass matrix [0, 0, 1, 1, 1, 1, 1, 1]
 â”œâ”€  2 outputs: [busbarâ‚Šu_r=1.0142, busbarâ‚Šu_i=-0.1798]
 â”œâ”€ 30 params:  [machineâ‚Švf_set<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠÏ„_m_set<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠR_s=0, machineâ‚ŠX_d=2, machineâ‚ŠX_q=1.9, machineâ‚ŠXâ€²_d=0.6, machineâ‚ŠXâ€²_q=0.8, machineâ‚ŠXâ€³_d=0.4, machineâ‚ŠXâ€³_q=0.4, machineâ‚ŠX_ls=0.3, machineâ‚ŠTâ€²_d0=7, machineâ‚ŠTâ€³_d0=0.05, machineâ‚ŠTâ€²_q0=0.7, machineâ‚ŠTâ€³_q0=0.035, machineâ‚ŠH=5, machineâ‚ŠD=0, machineâ‚ŠS_b=100, machineâ‚ŠV_b=345, machineâ‚ŠÏ‰_b=376.99, machineâ‚ŠSn=10000, machineâ‚ŠVn=345, ZIPLoadâ‚ŠPset=-11.04, ZIPLoadâ‚ŠQset=-2.5, ZIPLoadâ‚ŠVset<span class="sgr90">â‰ˆ1</span>, ZIPLoadâ‚ŠKpZ=1, ZIPLoadâ‚ŠKqZ=1, ZIPLoadâ‚ŠKpI=0, ZIPLoadâ‚ŠKqI=0, ZIPLoadâ‚ŠKpC=0, ZIPLoadâ‚ŠKqC=0]
 â””â”€  1 add. init eq. from 1 formula setting [:ZIPLoadâ‚ŠVset]
<span class="sgr34"><span class="sgr1">Powerflow model </span></span>:pvbus with [pvâ‚ŠP=-1.04, pvâ‚ŠV=1.03]</code></pre><p>The printout shows 1 additional initialization equation was attached to the model.</p><p>The initialization works now:</p><pre><code class="language-julia hljs">initialize_component!(vm_formula)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">InitFomula: setting default for :ZIPLoadâ‚ŠVset to 1.0300036884035901
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Apply positivity/negativity conserving variable transformation on [:machineâ‚Švf_set, :machineâ‚ŠÏ„_m_set] to satisfy bounds.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization problem is fully constrained. Created NonlinearLeastSquaresProblem for [:machineâ‚Šterminalâ‚Ši_i, :machineâ‚Šterminalâ‚Ši_r, :machineâ‚ŠÏˆâ€³_q, :machineâ‚ŠÏˆâ€³_d, :machineâ‚ŠEâ€²_d, :machineâ‚ŠEâ€²_q, :machineâ‚ŠÏ‰, :machineâ‚ŠÎ´, :machineâ‚Švf_set, :machineâ‚ŠÏ„_m_set]
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization successful with residual 1.2820961574625452e-15</code></pre><p>The init formula is applied early in the initialization process, essentially writing a new <code>default</code> for <code>ZIPLoadâ‚ŠVset</code> based on the other defaults.</p><p>This reduced the number of free variables to 10, thus the system was solvable.</p><h3 id="Method-3:-Using-an-InitConstraint"><a class="docs-heading-anchor" href="#Method-3:-Using-an-InitConstraint">Method 3: Using an <code>InitConstraint</code></a><a id="Method-3:-Using-an-InitConstraint-1"></a><a class="docs-heading-anchor-permalink" href="#Method-3:-Using-an-InitConstraint" title="Permalink"></a></h3><p>Sometimes, your additional initialization needs are more complicated. Similar to defining a <em>formula</em>, which is evaluated <em>before</em> the actual initialization, NetworkDynamics provides a mechanism for injecting additional constraints into the initialization process.</p><p>In contrast to the formula, the constraint does not need to be explicitly solvable, as it defines a residual equation</p><p class="math-container">\[0 = c(x) = V_\mathrm{set} - \sqrt{u_r^2 + u_i^2}\]</p><pre><code class="language-julia hljs">vm_constraint = copy(nw[VIndex(39)])
constraint = @initconstraint begin
  :ZIPLoadâ‚ŠVset - sqrt(:busbarâ‚Šu_r^2 + :busbarâ‚Šu_i^2)
end
set_initconstraint!(vm_constraint, constraint)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:bus39</span> <span class="sgr94">NoFeedForward()</span> @ Vertex 39
 â”œâ”€  2 inputs:  [busbarâ‚Ši_r=0.72013, busbarâ‚Ši_i=-1.7222]
 â”œâ”€  8 states:  [machineâ‚Šterminalâ‚Ši_i<span class="sgr90">â‰ˆ0</span>, machineâ‚Šterminalâ‚Ši_r<span class="sgr90">â‰ˆ0</span>, machineâ‚ŠÏˆâ€³_q<span class="sgr90">â‰ˆ0</span>, machineâ‚ŠÏˆâ€³_d<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠEâ€²_d<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠEâ€²_q<span class="sgr90">â‰ˆ0</span>, machineâ‚ŠÏ‰<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠÎ´<span class="sgr90">â‰ˆ0</span>]
 |     with diagonal mass matrix [0, 0, 1, 1, 1, 1, 1, 1]
 â”œâ”€  2 outputs: [busbarâ‚Šu_r=1.0142, busbarâ‚Šu_i=-0.1798]
 â”œâ”€ 30 params:  [machineâ‚Švf_set<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠÏ„_m_set<span class="sgr90">â‰ˆ1</span>, machineâ‚ŠR_s=0, machineâ‚ŠX_d=2, machineâ‚ŠX_q=1.9, machineâ‚ŠXâ€²_d=0.6, machineâ‚ŠXâ€²_q=0.8, machineâ‚ŠXâ€³_d=0.4, machineâ‚ŠXâ€³_q=0.4, machineâ‚ŠX_ls=0.3, machineâ‚ŠTâ€²_d0=7, machineâ‚ŠTâ€³_d0=0.05, machineâ‚ŠTâ€²_q0=0.7, machineâ‚ŠTâ€³_q0=0.035, machineâ‚ŠH=5, machineâ‚ŠD=0, machineâ‚ŠS_b=100, machineâ‚ŠV_b=345, machineâ‚ŠÏ‰_b=376.99, machineâ‚ŠSn=10000, machineâ‚ŠVn=345, ZIPLoadâ‚ŠPset=-11.04, ZIPLoadâ‚ŠQset=-2.5, ZIPLoadâ‚ŠVset<span class="sgr90">â‰ˆ1</span>, ZIPLoadâ‚ŠKpZ=1, ZIPLoadâ‚ŠKqZ=1, ZIPLoadâ‚ŠKpI=0, ZIPLoadâ‚ŠKqI=0, ZIPLoadâ‚ŠKpC=0, ZIPLoadâ‚ŠKqC=0]
 â””â”€  1 add. init eq. from 1 constraint for [:ZIPLoadâ‚ŠVset, :busbarâ‚Šu_r, :busbarâ‚Šu_i]
<span class="sgr34"><span class="sgr1">Powerflow model </span></span>:pvbus with [pvâ‚ŠP=-1.04, pvâ‚ŠV=1.03]</code></pre><p>With this added constraint, the initialization process is solvable again, since we now have 11 equations for the 11 free variables.</p><pre><code class="language-julia hljs">initialize_component!(vm_constraint)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Apply positivity/negativity conserving variable transformation on [:machineâ‚Švf_set, :machineâ‚ŠÏ„_m_set] to satisfy bounds.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization problem is fully constrained. Created NonlinearLeastSquaresProblem for [:machineâ‚Šterminalâ‚Ši_i, :machineâ‚Šterminalâ‚Ši_r, :machineâ‚ŠÏˆâ€³_q, :machineâ‚ŠÏˆâ€³_d, :machineâ‚ŠEâ€²_d, :machineâ‚ŠEâ€²_q, :machineâ‚ŠÏ‰, :machineâ‚ŠÎ´, :machineâ‚Švf_set, :machineâ‚ŠÏ„_m_set, :ZIPLoadâ‚ŠVset]
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization successful with residual 1.3086704628040893e-15</code></pre><p>For this particular case, method (2) is the way to go. However there are cases where the constraint is more complex and cannot be expressed as a formula.</p><p>See NetworkDynamics docs on <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/initialization/#Advanced-Component-Initialization%3A-Formulas-and-Constraints">Advanced Component Initialization: Formulas and Constraints</a> and the PowerDynamics specific extension <a href="../../initialization/#Advanced-Component-Initialization">Advanced Component Initialization</a> for more information on method 2 and 3.</p><h2 id="initialize-all-components"><a class="docs-heading-anchor" href="#initialize-all-components">Automatic Initialization of Full Network</a><a id="initialize-all-components-1"></a><a class="docs-heading-anchor-permalink" href="#initialize-all-components" title="Permalink"></a></h2><p>Let&#39;s return from our excursion into individual component initialization and focus on the whole network again. As we&#39;ve just seen, we have structurally underconstrained components in the network. Let&#39;s define the init formulas for the two buses which have loads and machines:</p><pre><code class="language-julia hljs">formula = @initformula :ZIPLoadâ‚ŠVset = sqrt(:busbarâ‚Šu_r^2 + :busbarâ‚Šu_i^2)
set_initformula!(nw[VIndex(31)], formula)
set_initformula!(nw[VIndex(39)], formula)</code></pre><p>With that, the componentwise initialization of the whole network is possible:</p><pre><code class="language-julia hljs">initialize_componentwise!(nw; default_overrides=interf)</code></pre><p>Even shorter, we can just use <a href="../../API/#PowerDynamics.initialize_from_pf!"><code>initialize_from_pf!</code></a> to do everything from exporting the power flow model, finding the fixpoint and initializing all components:</p><pre><code class="language-julia hljs">s0 = initialize_from_pf!(nw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NWState{Vector{Float64}} of Network (39 vertices, 46 edges)
  â”œâ”€ VIndex(1, :busbarâ‚Šu_i)                      =&gt; -0.1537005168018229
  â”œâ”€ VIndex(1, :busbarâ‚Šu_r)                      =&gt; 1.0360171229045203
  â”œâ”€ VIndex(2, :busbarâ‚Šu_i)                      =&gt; -0.10513936683885863
  â”œâ”€ VIndex(2, :busbarâ‚Šu_r)                      =&gt; 1.0434526576051297
  â”œâ”€ VIndex(5, :busbarâ‚Šu_i)                      =&gt; -0.15053530762365022
  â”œâ”€ VIndex(5, :busbarâ‚Šu_r)                      =&gt; 0.993976368877831
  â”œâ”€ VIndex(6, :busbarâ‚Šu_i)                      =&gt; -0.1393645217247641
  â”œâ”€ VIndex(6, :busbarâ‚Šu_r)                      =&gt; 0.9979886162106123
  â‹®
  â”œâ”€ VIndex(39, :machineâ‚Šterminalâ‚Ši_i)           =&gt; -2.538683831099698
  â”œâ”€ VIndex(39, :machineâ‚Šterminalâ‚Ši_r)           =&gt; 9.410063917554226
  â”œâ”€ VIndex(39, :machineâ‚ŠÏˆâ€³_q)                   =&gt; -0.1505993365374145
  â”œâ”€ VIndex(39, :machineâ‚ŠÏˆâ€³_d)                   =&gt; 1.0219450150609855
  â”œâ”€ VIndex(39, :machineâ‚ŠEâ€²_d)                   =&gt; 0.10353704204613715
  â”œâ”€ VIndex(39, :machineâ‚ŠEâ€²_q)                   =&gt; 1.029534387321863
  â”œâ”€ VIndex(39, :machineâ‚ŠÏ‰)                      =&gt; 1.0
  â””â”€ VIndex(39, :machineâ‚ŠÎ´)                      =&gt; -0.0009449613162717396<span class="sgr90">
 p = NWParameter([-3.22, -0.024, 1.03017, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, -5.0  â€¦  0.97561, 1.0, 0.0, 0.0, 0.0, 0.0, 0.5, 1.0, 0.0, 0.0])
 t = nothing</span></code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ieee39_part1/">Â« IEEE39 Part I: Modeling</a><a class="docs-footer-nextpage" href="../ieee39_part3/">IEEE39 Part III: Simulation Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 16 September 2025 14:49">Tuesday 16 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
