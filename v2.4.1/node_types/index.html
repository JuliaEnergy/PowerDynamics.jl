<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Node Types · PowerDynamics.jl</title><link rel="canonical" href="https://juliaenergy.github.io/PowerDynamics.jl/stable/node_types/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PowerDynamics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">General</a></li><li><a class="toctext" href="../ARCHITECTURE/">Architecture</a></li><li><a class="toctext" href="../language_conventions/">Language &amp; Conventions</a></li><li><a class="toctext" href="../powergrid_model/">PowerGrid model</a></li><li class="current"><a class="toctext" href>Node Types</a><ul class="internal"><li><a class="toctext" href="#Detailed-Node-Type-Documentation-1">Detailed Node Type Documentation</a></li></ul></li><li><a class="toctext" href="../custom_node_types/">Custom Node Types</a></li><li><a class="toctext" href="../line_types/">Line Types</a></li><li><a class="toctext" href="../states_solutions/">States, Solutions &amp; Plotting</a></li><li><a class="toctext" href="../simulations/">Simulations or Fault Scenarios</a></li><li><a class="toctext" href="../error_types/">Error Types</a></li><li><a class="toctext" href="../import_export/">Import/export</a></li><li><a class="toctext" href="../fullindex/">Index</a></li><li><a class="toctext" href="../contact/">Contact</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Node Types</a></li></ul><a class="edit-page" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/master/docs/src/node_types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Node Types</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Node-Types-1" href="#Node-Types-1">Node Types</a></h1><p>The currently implemented node types are</p><div><ul><li><a href="#PowerDynamics.CSIMinimal"><code>CSIMinimal</code></a></li><li><a href="@ref PowerDynamics.CompositeNode"><code>CompositeNode</code></a></li><li><a href="#PowerDynamics.CurtailedPowerPlantWithInertia"><code>CurtailedPowerPlantWithInertia</code></a></li><li><a href="#PowerDynamics.ExponentialRecoveryLoad"><code>ExponentialRecoveryLoad</code></a></li><li><a href="#PowerDynamics.FourthOrderEq"><code>FourthOrderEq</code></a></li><li><a href="#PowerDynamics.FourthOrderEqGovernorExciterAVR"><code>FourthOrderEqGovernorExciterAVR</code></a></li><li><a href="#PowerDynamics.PQAlgebraic"><code>PQAlgebraic</code></a></li><li><a href="#PowerDynamics.PVAlgebraic"><code>PVAlgebraic</code></a></li><li><a href="#PowerDynamics.PVInverterWithFrequencyControl"><code>PVInverterWithFrequencyControl</code></a></li><li><a href="#PowerDynamics.RLCLoad"><code>RLCLoad</code></a></li><li><a href="#PowerDynamics.SlackAlgebraic"><code>SlackAlgebraic</code></a></li><li><a href="#PowerDynamics.SwingEq"><code>SwingEq</code></a></li><li><a href="#PowerDynamics.SwingEqLVS"><code>SwingEqLVS</code></a></li><li><a href="#PowerDynamics.VSIMinimal"><code>VSIMinimal</code></a></li><li><a href="#PowerDynamics.VSIVoltagePT1"><code>VSIVoltagePT1</code></a></li><li><a href="#PowerDynamics.VoltageDependentLoad"><code>VoltageDependentLoad</code></a></li><li><a href="@ref PowerDynamics.WindTurbineGenType4"><code>WindTurbineGenType4</code></a></li><li><a href="@ref PowerDynamics.WindTurbineGenType4_RotorControl"><code>WindTurbineGenType4_RotorControl</code></a></li></ul></div><h2><a class="nav-anchor" id="Detailed-Node-Type-Documentation-1" href="#Detailed-Node-Type-Documentation-1">Detailed Node Type Documentation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.AbstractNode" href="#PowerDynamics.AbstractNode"><code>PowerDynamics.AbstractNode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract base type for all nodes</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/5a95a3ba999f2e4fb8c1d28677f9ee10ac2eba5c/src/nodes/AbstractNode.jl#L1">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.CSIMinimal" href="#PowerDynamics.CSIMinimal"><code>PowerDynamics.CSIMinimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">CSIMinimal(;I_r)</code></pre><p>A node type that keeps the current fixed as a desired values <code>I_r</code>.</p><p><code>CSIMinimal</code> models an inverters as an ideal current source. This can be the most simple representation of an inverter in grid-feeding mode, according to Rocabert, Joan, et al. &quot;Control of power converters in AC microgrids.&quot; (2012). Here, additionally to <code>u</code>, there are no internal dynamic variables.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>I_r</code>: reference/ desired current</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>CSIMinimal</code> for node <span>$a$</span> gives:</p><div>\[0 = I_{r,a} - \left\|i_a\right\|\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.CurtailedPowerPlantWithInertia" href="#PowerDynamics.CurtailedPowerPlantWithInertia"><code>PowerDynamics.CurtailedPowerPlantWithInertia</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">CurtailedPowerPlantWithInertia(;)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.ExponentialRecoveryLoad" href="#PowerDynamics.ExponentialRecoveryLoad"><code>PowerDynamics.ExponentialRecoveryLoad</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">ExponentialRecoveryLoad(P0, Q0, Nps, Npt, Nqs, Nqt, Tp, Tq, V0)</code></pre><p>A node type that represents the exponential recovery load model. The exponential recovery load model aims to capture the load restoration characteristics with an exponential recovery process expressed as an input–output relationship between powers (real and reactive) and voltage.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>P0</code>: Active power load demand [pu]</li><li><code>Q0</code>: Reactive power load demand [pu]</li><li><code>Nps</code>: Steady-state load voltage dependence p-axis [pu]</li><li><code>Npt</code>: Transient load voltage dependence p-axis [pu]</li><li><code>Nqs</code>: Steady-state load voltage dependence q-axis [pu]</li><li><code>Nqt</code>: Transient load voltage dependence q-axis [ pu]</li><li><code>Tp</code>: Load recovery constant p-axis [s]</li><li><code>Tq</code>: Load recovery constant q-axis [s]</li><li><code>V0</code>: Reference grid voltage [pu]</li></ul><p><strong>Mathematical Representation</strong></p><div>\[	\dfrac{dx_p}{dt} = \dfrac{1}{T_p}(-x_p + P_0(\dfrac{|u|}{V_0})^{N_{ps}} - P_0(\dfrac{|u|}{V_0})^{N_{pt}}) \\
    \dfrac{dx_q}{dt} = \dfrac{1}{T_q}(-x_q + Q_0(\dfrac{|u|}{V_0})^{N_{qs}} - Q_0(\dfrac{|u|}{V_0})^{N_{qt}}) \\
    P = x_p + P_0(\dfrac{|u|}{V_0})^{N_{pt}} \\
    Q = x_q - Q_0(\dfrac{|u|}{V_0})^{N_{qt}} \\\]</div><p>IEEE TRANSACTIONS ON POWER SYSTEMS, VOL. 21, NO. 3, AUGUST 2006 Measurement-Based Dynamic Load Models: Derivation, Comparison, and Validation Byoung-Kon Choi, Member, IEEE, Hsiao-Dong Chiang, Fellow, IEEE, Yinhong Li, Hua Li, Member, IEEE, Yung-Tien Chen, Der-Hua Huang, and Mark G. Lauby</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.FourthOrderEq" href="#PowerDynamics.FourthOrderEq"><code>PowerDynamics.FourthOrderEq</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">FourthEq(H, P, D, Ω, E_f, T_d_dash ,T_q_dash ,X_q_dash ,X_d_dash,X_d, X_q)</code></pre><p>A node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics, which is implemented according to P. Sauer, &quot;Power System Dynamics and Stability&quot;. For an illustration of a synchronous machine schematic see P. Sauer, Fig. 3.1 on p. 25.</p><p>Usually the swing equation (<code>SwingEq</code>) is used for short time periods to analyze the transient behavior of generators in a power grid, the so-called first swing. The 4th-order model  also takes the back reaction of the power flow onto the voltage into account. This has the effect that the angle of the voltage as seen by the power grid, and the angle of the rotating mass are no longer the same but become dynamically coupled.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variables</p><ul><li><span>$ω$</span> representing the frequency of the rotator relative to the grid frequency <span>$Ω$</span>, i.e. the real frequency <span>$ω_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span> and</li><li><span>$θ$</span> representing the relative angle of the rotor with respect to the voltage angle <span>$ϕ$</span>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: shaft inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)</li><li><code>P</code>: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]</li><li><code>D</code>: damping coefficient (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal <code>Dω</code>)</li><li><code>Ω</code>: rated frequency of the power grid, often <span>$2π⋅50Hz$</span></li><li><code>T_d_dash</code>: time constant of d-axis, given in [s], see P. Sauer, chapter 3.7, p. 54 for a general explanation on time constants</li><li><code>T_q_dash</code>: time constant of q-axis, given in [s]</li><li><code>X_d_dash</code>: transient reactance of d-axis, given in [pu]</li><li><code>X_q_dash</code>: transient reactance of q-axis, given in [pu]</li><li><code>X_d</code>: reactance of d-, given in [pu]</li><li><code>X_d</code>: reactance of q-axis, given in [pu]</li><li><code>E_f</code>: scaled field voltage, which, if set equal to 1.0 pu, gives 1.0 pu open-circuit terminal voltage. The physical device that provides the value of <code>E_f</code> is called the exciter (according to P. Sauer, p. 65)</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>FourthEq</code> for node <span>$a$</span> applies the equations</p><div>\[    u = -je_c e^{j\theta} = -j(e_d + je_q)e^{j\theta}\\
    e_c= e_d + je_q = jue^{-j\theta}\\
    i  = -ji&#39;e^{j\theta} = -j(i_d+ j i_q )e^{j\theta} = Y^L \cdot u \\
    i_c= i_d + ji_q = jie^{-j\theta}\\
    p = \Re (i^* u)\]</div><p>where complex voltage and current are described in a co-rotating frame with axes labeled d and q.</p><p>The fourth-order equations read (according to P. Sauer, &quot;Power System Dynamics and Stability&quot;, p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)</p><div>\[    \frac{d\theta}{dt} = \omega \\
     \frac{d\omega}{dt} = (P-D\omega - p -(X&#39;_q-X&#39;_d)i_d i_q)Ω_H\\
    \frac{d e_q}{dt} = \frac{1}{T&#39;_d} (- e_q - (X_d - X&#39;_d) i_{d}+ E_f) \\
    \frac{d e_d}{dt} = \frac{1}{T&#39;_q} (- e_d + (X_q - X&#39;_q) i_{q})  \\\]</div><p>The equations for frequency and phase represent energy conservation and phase shift. The dynamic equations for the complex voltage show the relationship between the dynamicy of flux linkages and currents which must reflect a conservative coupling field.</p><p>With the PowerDynamics.jl naming conventions of <span>$i$</span> and <span>$u$</span> they read as</p><div>\[   \dot u = \frac{d}{dt}(-j e_c e^{j\theta})=-j(\dot e_d + j\dot e_q)e^{j\theta} + uj\omega\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.FourthOrderEqGovernorExciterAVR" href="#PowerDynamics.FourthOrderEqGovernorExciterAVR"><code>PowerDynamics.FourthOrderEqGovernorExciterAVR</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">FourthOrderEqGovernorExciterAVR(H, P, D, Ω, T_d_dash ,T_q_dash ,X_q_dash ,X_d_dash,X_d, X_q, T_e, T_a, T_f, K_e, K_a, K_f, V_ref, R_d, T_sv, T_ch)</code></pre><p>A node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics, including an Exciter, Automatic Voltage Regulator and Governor which is implemented according to P. Sauer, &quot;Power System Dynamics and Stability&quot;. For an illustration of a synchronous machine schematic see P. Sauer, Fig. 3.1 on p. 25.</p><p>Exciter and Automatic Voltage Regulator: The equations for the systems that balance the AC synchronous machine voltage level by increasing or decreasing the exciter DC voltage. Note, within this model, the transient reactance in the d-axis of the generator needs to be included into the nodal admittance matrix. As the bus of this generator node type is constructed to be an internal generator bus.</p><p>Governor: The prime mover provides the mechanism for controlling the synchronous machine speed and, hence, terminal voltage frequency.</p><p>Usually the swing equation (<code>SwingEq</code>) is used for short time periods to analyze the transient behavior of generators in a power grid, the so-called first swing. The 4th-order model  also takes the back reaction of the power flow onto the voltage into account. This has the effect that the angle of the voltage as seen by the power grid, and the angle of the rotating mass are no longer the same but become dynamically coupled.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variables</p><ul><li><span>$ω$</span> representing the frequency of the rotator relative to the grid frequency <span>$Ω$</span>, i.e. the real frequency <span>$ω_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span> and</li><li><span>$θ$</span> representing the relative angle of the rotor with respect to the voltage angle <span>$ϕ$</span>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>H</code>: shaft inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)</p></li><li><p><code>P</code>: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]</p></li><li><p><code>D</code>: damping coefficient (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal <code>Dω</code>)</p></li><li><p><code>Ω</code>: rated frequency of the power grid, often <span>$2π⋅50Hz$</span></p></li><li><p><code>T_d_dash</code>: time constant of d-axis, given in [s], see P. Sauer, chapter 3.7, p. 54 for a general explanation on time constants</p></li><li><p><code>T_q_dash</code>: time constant of q-axis, given in [s]</p></li><li><p><code>X_d_dash</code>: transient reactance of d-axis, given in [pu]</p></li><li><p><code>X_q_dash</code>: transient reactance of q-axis, given in [pu]</p></li><li><p><code>X_d</code>: reactance of d-, given in [pu]</p></li><li><p><code>X_d</code>: reactance of q-axis, given in [pu]</p></li><li><p><code>T_e</code> : Exciter time constant, integration rate associated with exciter control [s]</p></li><li><p><code>T_a</code> : Maximum voltage regulator output [s]</p></li><li><p><code>T_f</code> : Excitation control system stabilizer time constant [s]</p></li><li><p><code>K_e</code> : Exciter constant related to self-excited field [pu]</p></li><li><p><code>K_a</code> : Voltage Regulator gain [pu]</p></li><li><p><code>K_f</code> : Excitation control system stabilizer gains [pu]</p></li><li><p><code>V_ref</code> : Reference voltage for the AVR [pu]</p></li><li><p><code>R_d</code> : Speed regulation <span>$R_d=2π droop/Ω$</span> [s]</p></li><li><p><code>T_sv</code> : Steam Valve time constant [s]</p></li><li><p><code>T_ch</code> : Steam Chest time constant [s]</p></li></ul><p><strong>Mathematical Representation Synchronous Machine</strong></p><p>Using <code>FourthEq</code> for node <span>$a$</span> applies the equations</p><div>\[    u = -je_c e^{j\theta} = -j(e_d + je_q)e^{j\theta}\\
    e_c= e_d + je_q = jue^{-j\theta}\\
    i  = -ji&#39;e^{j\theta} = -j(i_d+ j i_q )e^{j\theta} = Y^L \cdot u \\
    i_c= i_d + ji_q = jie^{-j\theta}\\
    p = \Re (i^* u) \\\]</div><p>where complex voltage and current are described in a co-rotating frame with axes labeled d and q.</p><p>The fourth-order equations read (according to P. Sauer, &quot;Power System Dynamics and Stability&quot;, p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)</p><div>\[    \frac{d\theta}{dt} = \omega \\
    \frac{d\omega}{dt} = (P-D\omega - p -(X&#39;_q-X&#39;_d)i_d i_q)Ω_H\\
    \frac{d e_q}{dt} = \frac{1}{T&#39;_d} (- e_q - (X_d - X&#39;_d) i_{d}+ E_f) \\
    \frac{d e_d}{dt} = \frac{1}{T&#39;_q} (- e_d + (X_q - X&#39;_q) i_{q}) \\\]</div><p><strong>Exciter and AVR equations</strong></p><div>\[	u_{terminal} = e&#39;_c - j X&#39;_d i \\
	S_{e}(e_{fd}) = 0.098e^{0.55 e_{fd}} \text{(according to P. Sauer, p. 70)} \\
	\dfrac{dR_f}{dt} = \dfrac{1}{T_f} (-R_f + \dfrac{K_f}{T_f} e_f) \\
	\dfrac{dv_r}{dt} = \dfrac{1}{T_a} (-v_r + (K_a R_f) -\dfrac{K_a K_f}{T_f}e_{fd} + K_a (V_{ref} - |u_{terminal}|)) \\
	\dfrac{de_{fd}}{dt} = \dfrac{1}{T_e} (-K_e + S_{e}(e_{fd})e_{fd} + v_r) \\\]</div><p><strong>Governor equations</strong></p><div>\[    \dfrac{dP_m}{dt} = \dfrac{1}{T_{ch}} (-P_m + P_{sv}) \\
    \text{Assumption}: T_m = P_m \\
    \dfrac{dP_{sv}}{dt} = \dfrac{1}{T_{sv}} (-P_{sv} + P_c -\dfrac{1}{R_d} (\dfrac{\omega}{Ω} - 1)) \\\]</div><p>The equations for frequency and phase represent energy conservation and phase shift. The dynamic equations for the complex voltage show the relationship between the dynamicy of flux linkages and currents which must reflect a conservative coupling field.</p><p>With the PowerDynamics.jl naming conventions of <span>$i$</span> and <span>$u$</span> they read as</p><div>\[   \dot u = \frac{d}{dt}(-j e_c e^{j\theta})=-j(\dot e_d + j\dot e_q)e^{j\theta} + uj\omega \\\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.PQAlgebraic" href="#PowerDynamics.PQAlgebraic"><code>PowerDynamics.PQAlgebraic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">    PQAlgebraic(; P,Q)</code></pre><p>A node type that locally fixes the active (<span>$P$</span>) and reactive power (<span>$Q$</span>) output of the node.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>P</code>: active power set point</li><li><code>Q</code>: reactive power set point</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>PQAlgebraic</code> for node <span>$a$</span> applies the equation</p><div>\[0 = (P_a + Q_a*im) - u_a \cdot i_a^*.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.PVAlgebraic" href="#PowerDynamics.PVAlgebraic"><code>PowerDynamics.PVAlgebraic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">PVAlgebraic(;P,V)</code></pre><p>A node type that locally fixes the active power (<span>$P$</span>) and the voltage magnitude (<span>$V$</span>) of the node.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>P</code>: the active (real) power output</li><li><code>V</code>: voltage magnitude</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>PVAlgebraic</code> for node <span>$a$</span> applies the equations</p><div>\[0 = P_a - \Re\left(u_a \cdot i_a^*\right), \\
0 = V_a - \left\|u_a\right\|.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.PVInverterWithFrequencyControl" href="#PowerDynamics.PVInverterWithFrequencyControl"><code>PowerDynamics.PVInverterWithFrequencyControl</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">PVInverterWithFrequencyControl(;I_n,k_PLL,f,f_s,T_m,k_P,τ_ω)</code></pre><p>This implementation of a generic inverter model is built with standard components according to the report on &quot;Modelling of Inverter-Based Generation for Power System Dynamic Studies&quot; of the joint CIGRE working group.</p><p>Additionally to <span>$u$</span>, the global network-side voltage, it has the internal dynamic variables:</p><ul><li><code>θ_PLL</code>: phase determined by the PLL</li><li><code>v_xm</code>: x-component of measured grid-side voltage</li><li><code>v_ym</code>: y-component of measured grid-side voltage</li><li><code>P</code>: power infeed of power plant</li><li><code>ω</code>: frequeny deviation in rad/s.</li></ul><p><strong>Keyword arguments are:</strong></p><ul><li><code>I_n</code>: the nominal current of the PV plant</li><li><code>k_PLL</code>: the PLL constant,</li><li><code>f</code>: the nominal frequency (50Hz usually)</li><li><code>f_s</code>: the set point at which droop control is triggered</li><li><code>T_m</code>: the time constant of the low pass filter for measuring the voltage locally at the inverter</li><li><code>k_P</code>: the droop control constant</li><li><code>τ_ω</code> time constant of the frequeny filter</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>PVInverterWithFrequencyControl</code> applies the equations</p><div>\[    v_x = real(u)\\
    v_y = imag(u)\]</div><p>The network-side power is</p><div>\[p = real(u \cdot conj(i))\]</div><p>The nominal current of the PV inverter, <span>$I_n$</span>, is completely active current (we do not consider voltage regulation so far):</p><div>\[    I_{P,max} = I_n \\
    I_{Q,max} = 0\]</div><div>\[    \frac{dv_{xm}}{dt} = 1/T_m(v_x-v_{xm})\\
    \frac{dv_{ym}}{dt} = 1/T_m(v_y-v_{ym})\]</div><p>Since PowerDynamics is working with phasor units, this model has two d-q-systems (for the power plant and for the grid), <span>$I_p/v_d$</span> and <span>$I_q/v_q$</span> are the local coordinates and <span>$i_x/v_x$</span> and <span>$i_y/v_y$</span> are the global (grid) coordinates.</p><div>\[    u_dq = (v_{xm}+j v_{ym})e^{-j\theta_{PLL}}
    v_d = real(u_dq)\\
    v_q = imag(u_dq)\]</div><p>The local coordinates are chosen such that <span>$v_q=0$</span>:</p><div>\[    \dot{\theta}_{PLL} = v_q(k_{PLL})\]</div><p>The frequency deviation, <span>$\dot{\theta}_{PLL}$</span>,  is obtained thanks to the PLL controller of the units. Therefore, the measured frequency in Hz is given by</p><div>\[        f_m = (1+\dot{\theta}_{PLL})f.\]</div><p>An additional filter is added to avoid a too fast PV reaction leading to unwanted oscillations of the active current during a short-term fault:</p><div>\[    \frac{d\omega}{dt} = 1/\tau_\omega(-\omega + \dot{\theta}_{PLL}\cdot2\pi f)\]</div><p>With the active power determined by the droop control the current <code>I_P</code>equals:</p><div>\[    I_P=P/v_d\]</div><p>Implementing the frequency dead band for overfrequnency control with:</p><div>\[    \frac{dP}{dt} =-k_P \cdot d\omega \cdot P_{ext} \ , \text{if ($f_m&gt;f_s)$}\\
    \frac{dP}{dt}  = 0 \ , \text{else}\]</div><p>where <span>$f_s$</span> is the frequency at which the active power output starts decreasing and <span>$k_P$</span> is the droop control constant (in percentage of the rated power <span>$P_{ext}$</span>):</p><div>\[    P_{ext} = real(I_{P,max}\cdot(v_d+jv_q))= I_N v_d.\]</div><div>\[    0\cdot \dot{u} =i - (I_P+ j I_Q)e^{j\theta_{PLL}}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.RLCLoad" href="#PowerDynamics.RLCLoad"><code>PowerDynamics.RLCLoad</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">RLCLoad(R,L,C)</code></pre><p>EXPERIMENTAL A node type that represents the RLC load model according to &quot;Power Systems Electromagnetic Transients Simulation&quot;, Neville Watson and Jos Arrillaga, IET 2007, p.59, eq. (3.47)</p><p><strong>Keyword Arguments</strong></p><ul><li><code>R</code>: resistance in [?]</li><li><code>L</code>: inductance in [?]</li><li><code>C</code>: capacitance in [?]</li></ul><p><strong>Mathematical Representation</strong></p><div>\[	\dfrac{du_C}{dt} = \frac{1}{C}i_L(t)\\
    \dfrac{di_L}{dt} = -\frac{R}{L} i_L(t)+\frac{1}{L} u(t)\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.SlackAlgebraic" href="#PowerDynamics.SlackAlgebraic"><code>PowerDynamics.SlackAlgebraic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">SlackAlgebraic(;U)</code></pre><p>A node type that locally fixes the complex voltage (<span>$U$</span>) of the node.</p><p>As the complex voltage can be represented as <span>$U=Ve^{i\phi}$</span>, this is equivlant to fixing the voltage magnitude <span>$V$</span> and the angle <span>$\phi$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>U</code>: the complex voltage</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>SlackAlgebraic</code> for node <span>$a$</span> applies the equation</p><div>\[0 = U_a - u_a.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.SwingEq" href="#PowerDynamics.SwingEq"><code>PowerDynamics.SwingEq</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">SwingEq(;H, P, D, Ω)</code></pre><p>A node type that applies the swing equation to the frequency/angle dynamics and keeps the voltage magnitude as is. In the following, we followed the implementation of the 2nd-order Synchronous Machine Model according to  Sauer et. al. &quot;Power system dynamics and stability&quot;, 1998.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)</li><li><code>P</code>: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]</li><li><code>D</code>: damping coefficient, (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal <code>Dω</code>)</li><li><code>Ω</code>: rated frequency in [1/s] of the power grid, often <span>$2\pi⋅50$</span>Hz</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>SwingEq</code> for node <span>$a$</span> applies the equations</p><div>\[\frac{du_a}{dt} = i u_a  \omega_a, \\
\frac{2H}{\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div><p>which is equivalent to</p><div>\[\frac{d\phi_a}{dt} = \omega, \\
v = v(t=0) = \text{const.} \\
\frac{2H}{\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div><p>where <span>$H = \frac{1}{2}\frac{J\Omega^2}{S_b}$</span> for a two-pole machine accoding to Sauer et. al. eq. (3.60) on p. 33. <code>S_b</code> is the rated three-phase MVA of the power system.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.SwingEqLVS" href="#PowerDynamics.SwingEqLVS"><code>PowerDynamics.SwingEqLVS</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">SwingEqLVS(;H, P, D, Ω, Γ, V)</code></pre><p>A node type that applies the swing equation to the frequency/angle dynamics and has a linear voltage stability (LVS) term.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)</li><li><code>P</code>: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]</li><li><code>D</code>: damping coefficient, (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal <code>Dω</code>)</li><li><code>Ω</code>: rated frequency in [1/s] of the power grid, often <span>$2\pi⋅50$</span>Hz</li><li><code>Γ</code>: voltage stability coefficient</li><li><code>V</code>: set voltage, usually <code>1</code></li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>SwingEq</code> for node <span>$a$</span> applies the equations</p><div>\[\frac{du_a}{dt} = i u_a \omega - \frac{u}{\|u\|} Γ_a  (v_a - V_a), \\
\frac{2H}{\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div><p>which is equivalent to</p><div>\[\frac{d\phi_a}{dt} = \omega_a, \\
\frac{dv_a}{dt} = - Γ_a  (v_a - V_a) \\
\frac{2H}{\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.VSIMinimal" href="#PowerDynamics.VSIMinimal"><code>PowerDynamics.VSIMinimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">VSIMinimal(;τ_P,τ_Q,K_P,K_Q,E_r,P,Q)</code></pre><p>A node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics. Implemented according to  Schiffer et. al., &quot;Conditions for stability of droop-controlled inverter-based microgrids&quot;, Automatica, 2014.</p><p><code>VSIMinimal</code> models an inverters as AC voltage source which means the amplitude and frequency can defined by the designer (often called grid-forming inverter mode). The frequency and voltage regulation is assumed to be instantaneous. In addition simple proportional controllers are implemented for frequency and voltage such that the frequency <code>ω</code> and voltage amplitudes <code>v</code> of the inverters are modified depending on the deviations (with respect to a desired value) of the active and reactive powers, respectively. it is assumed that active and reactive power are measured via low pass filters with time constant <code>τ_P</code> and <code>τ_Q</code>, respectively. <code>VSIMinimal</code> can be derived from <code>VSIVoltagePT1</code> by assuming an instantaneous voltage regulation without delay.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$ω$</span> representing the frequency of the inverter frequency relative to the grid frequency <span>$Ω=2π50$</span>Hz, i.e. the real frequency <span>$ω_r$</span> of the inverter frequency is given as <span>$ω_r = Ω + ω$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>τ_p</code>: time constant active power measurement</li><li><code>τ_Q</code>: time constant reactive power measurement</li><li><code>K_P</code>: droop constant frequency droop</li><li><code>K_Q</code>: droop constant voltage droop</li><li><code>V_r</code>: reference/ desired voltage</li><li><code>P</code>: active (real) power infeed</li><li><code>Q</code>: reactive (imag) power infeed</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>VSIMinimal</code> for node <span>$a$</span> (according to J. Schiffer et. al., eq. (7)) gives the equations</p><div>\[\dot{\phi}_a=\omega_a\\
 \dot{\omega}_a=\frac{1}{\tau_{P,a}}[-\omega_a-K_{P,a} (\Re\left(u_a \cdot i_a^*\right)-P_{a})]\\
\tau_Q\dot{v}_a=-v_a+V_{r}-K_{Q,a} (\Im\left(u_a \cdot i_a^*\right)-Q_{a})\\
 \dot{u}_a=\dot{v_a}e^{j\phi}+j\omega_a u_a\]</div><p>```</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.VSIVoltagePT1" href="#PowerDynamics.VSIVoltagePT1"><code>PowerDynamics.VSIVoltagePT1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">VSIVoltagePT1(;τ_v,τ_P,τ_Q,K_P,K_Q,E_r,P,Q)</code></pre><p>A node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics. Implemented according to  Schiffer et. al., &quot;Conditions for stability of droop-controlled inverter-based microgrids&quot;, Automatica, 2014.</p><p><code>VSIVoltagePT1</code> models an inverters as AC voltage source which means the amplitude and frequency can defined by the designer (often called grid-forming inverter mode). The frequency regulation is assumed to be instantaneous, but the voltage control happens with a delay <code>τ_v</code> that is represented by a first order filter. In addition simple proportional controllers are implemented for frequency and voltage such that the frequency <code>ω</code> and voltage amplitudes <code>v</code> of the inverters are modified depending on the deviations (with respect to a desired value) of the active and reactive powers, respectively. ift is assumed that active and reactive power are measured via low pass fileters with time constant <code>τ_P</code> and <code>τ_Q</code>, respectively.</p><p>Hence, additionally to <code>u</code>, it has the internal dynamic variables</p><ul><li><code>ω</code> representing the frequency of the inverter relative to the grid frequency <span>$Ω=2π50$</span>Hz, i.e. the real frequency <span>$ω_r$</span> of the inverter is given as <span>$ω_r = Ω + ω$</span>.</li><li><code>q_m</code> is the measured reactive power at the grid connection point.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>τ_v</code>: time constant voltage control delay</li><li><code>τ_P</code>: time constant active power measurement</li><li><code>τ_Q</code>: time constant reactive power measurement</li><li><code>K_P</code>: droop constant frequency droop</li><li><code>K_Q</code>: droop constant voltage droop</li><li><code>V_r</code>: reference/ desired voltage</li><li><code>P</code>: active (real) power infeed</li><li><code>Q</code>: reactive (imag) power infeed</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>VSIVoltagePT1</code> for node <span>$a$</span> (according to J. Schiffer et. al., eq. (6)) gives the equations</p><div>\[\dot{\phi}_a=\omega_a\\
 \dot{\omega}_a=\frac{1}{\tau_{P,a}}[-\omega_a-K_{P,a} (\Re\left(u_a \cdot i_a^*\right)-P_{ref,a})]\\
 \tau_v\dot{v}_{a}=-v_a+V_{ref}-K_{Q,a}(q_{m,a}-Q_{ref,a})\\
 \tau_Q \dot{q}_{m,a}=-q_{m,a}+\Im\left(u_a \cdot i_a^*\right)\\
 \dot{u}_a=\dot{v_a}e^{j\phi}+j\omega_a u_a\\\]</div><p>In general <span>$τ_V ≪ τ_P$</span>, assuming <span>$τ_V = 0$</span> would then lead to <code>VSIMinimal</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynamics.VoltageDependentLoad" href="#PowerDynamics.VoltageDependentLoad"><code>PowerDynamics.VoltageDependentLoad</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">    VoltageDependentLoad(;P, Q, U, A, B)</code></pre><p>A node type that locally fixes the active (<span>$P$</span>) and reactive power (<span>$Q$</span>) output of the node.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>P</code>: active power demand</li><li><code>Q</code>: reactive power demand</li><li><code>U</code> : the voltage set point</li><li><code>A</code> : relative share of quadratic voltage dependence </li><li><code>B</code> : relative share of linear voltage dependence </li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>VoltageDependentLoad</code> for node <span>$a$</span> applies the equation</p><div>\[0 = S_a ( A * (u_a/U_a)^2 + B * (u_a/U_a) + 1 - A - B) - u_a \cdot i_a^*.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section><footer><hr/><a class="previous" href="../powergrid_model/"><span class="direction">Previous</span><span class="title">PowerGrid model</span></a><a class="next" href="../custom_node_types/"><span class="direction">Next</span><span class="title">Custom Node Types</span></a></footer></article></body></html>
