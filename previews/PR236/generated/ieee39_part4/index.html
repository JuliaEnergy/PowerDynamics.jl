<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>IEEE39 Part IV: Parameter Tuning ¬∑ PowerDynamics.jl</title><meta name="title" content="IEEE39 Part IV: Parameter Tuning ¬∑ PowerDynamics.jl"/><meta property="og:title" content="IEEE39 Part IV: Parameter Tuning ¬∑ PowerDynamics.jl"/><meta property="twitter:title" content="IEEE39 Part IV: Parameter Tuning ¬∑ PowerDynamics.jl"/><meta name="description" content="Documentation for PowerDynamics.jl."/><meta property="og:description" content="Documentation for PowerDynamics.jl."/><meta property="twitter:description" content="Documentation for PowerDynamics.jl."/><meta property="og:url" content="https://juliaenergy.github.io/PowerDynamics.jl/generated/ieee39_part4/"/><meta property="twitter:url" content="https://juliaenergy.github.io/PowerDynamics.jl/generated/ieee39_part4/"/><link rel="canonical" href="https://juliaenergy.github.io/PowerDynamics.jl/generated/ieee39_part4/"/><meta property="og:image" content="https://juliaenergy.github.io/PowerDynamics.jl/assets/preview.png"/><meta property="twitter:image" content="https://juliaenergy.github.io/PowerDynamics.jl/assets/preview.png"/><meta property="twitter:card" content="summary_large_image"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="PowerDynamics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="PowerDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PowerDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../ModelingConcepts/">Modeling Concepts</a></li><li><a class="tocitem" href="../../initialization/">Initialization</a></li><li><a class="tocitem" href="../../Library/">Component Library</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../julia_setup/">Julia Setup for New Users</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../typical_simulation_workflow/">Typical Simulation Workflow</a></li><li><a class="tocitem" href="../custom_bus/">Custom Generator Bus</a></li><li><a class="tocitem" href="../custom_line/">Custom Transmission Line</a></li></ul></li><li><span class="tocitem">Advanced Examples</span><ul><li><a class="tocitem" href="../ieee9bus/">IEEE 9-Bus Example</a></li><li><a class="tocitem" href="../ieee39_part1/">IEEE39 Part I: Modeling</a></li><li><a class="tocitem" href="../ieee39_part2/">IEEE39 Part II: Initialization</a></li><li><a class="tocitem" href="../ieee39_part3/">IEEE39 Part III: Simulation</a></li><li class="is-active"><a class="tocitem" href>IEEE39 Part IV: Parameter Tuning</a><ul class="internal"><li><a class="tocitem" href="#Integration-of-a-Droop-Controlled-Inverter"><span>Integration of a Droop-Controlled Inverter</span></a></li><li><a class="tocitem" href="#Parameter-Optimization"><span>Parameter Optimization</span></a></li></ul></li><li><a class="tocitem" href="../emt_toymodel/">EMT Toymodel</a></li></ul></li><li><a class="tocitem" href="../../API/">API</a></li><li><a class="tocitem" href="../../networkdynamics_forward/">üîó NetworkDynamics.jl Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Advanced Examples</a></li><li class="is-active"><a href>IEEE39 Part IV: Parameter Tuning</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>IEEE39 Part IV: Parameter Tuning</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaEnergy/PowerDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/main/docs/examples/ieee39_part4.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ieee39-part4"><a class="docs-heading-anchor" href="#ieee39-part4">IEEE39 Bus Tutorial - Part IV: Advanced Modeling &amp; Parameter Optimization</a><a id="ieee39-part4-1"></a><a class="docs-heading-anchor-permalink" href="#ieee39-part4" title="Permalink"></a></h1><p>This tutorial can be downloaded as a normal Julia script <a href="../ieee39_part4.jl">here</a>.</p><p>This is the fourth and final part of the IEEE 39-bus tutorial series:</p><ul><li><strong>Part I: Model Creation</strong> - Build the network structure with buses, lines, and components</li><li><strong>Part II: Initialization</strong> - Perform power flow calculations and dynamic initialization</li><li><strong>Part III: Dynamic Simulation</strong> - Run time-domain simulations and analyze system behavior</li><li><strong>Part IV: Advanced Modeling &amp; Parameter Optimization</strong> (this tutorial) - Create custom components and optimize system parameters</li></ul><p>In this tutorial, we&#39;ll demonstrate advanced PowerDynamics.jl capabilities by:</p><ol><li>Creating a custom droop-controlled inverter component</li><li>Integrating it into the IEEE 39-bus system</li><li>Optimizing its parameters to improve system performance</li></ol><p>This tutorial showcases custom component creation and the integration with Julia&#39;s optimization ecosystem for parameter tuning.</p><div class="admonition is-info" id="Note-f3304ea6e9213106"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f3304ea6e9213106" title="Permalink"></a></header><div class="admonition-body"><p>This tutorial is designed as a pedagogical example. It does not necessarily represent a realistic power system model and analysis, but rather serves to demonstrate the available tools while remaining relatively simple and concise.</p></div></div><pre><code class="language-julia hljs"># Loading required packages and setup
using PowerDynamics
using PowerDynamics.Library
using ModelingToolkit
using ModelingToolkit: D_nounits as Dt, t_nounits as t
using NetworkDynamics
using NetworkDynamics: SII
using OrdinaryDiffEqRosenbrock
using OrdinaryDiffEqNonlinearSolve
using SciMLSensitivity
using Optimization
using OptimizationOptimisers
using CairoMakie
using LinearAlgebra
using Graphs
using SparseConnectivityTracer
using Sparspak

# Load the network models from previous parts
EXAMPLEDIR = joinpath(pkgdir(PowerDynamics), &quot;docs&quot;, &quot;examples&quot;)
include(joinpath(EXAMPLEDIR, &quot;ieee39_part1.jl&quot;))  # Creates the basic network model
include(joinpath(EXAMPLEDIR, &quot;ieee39_part3.jl&quot;))  # Provides initialized network and reference solution</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"><span class="sgr1">‚îå Warning: </span></span>The `alias_u0` keyword argument is deprecated. Please use a NonlinearAliasSpecifier, e.g. `alias = NonlinearAliasSpecifier(alias_u0 = true)`.
<span class="sgr33"><span class="sgr1">‚îî </span></span><span class="sgr90">@ NonlinearSolveBase ~/.julia/packages/NonlinearSolveBase/2E600/src/solve.jl:57</span>
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Short circuit activated on line 5‚Üí8 at t = 0.1s
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Line 5‚Üí8 disconnected at t = 0.2s</code></pre><h2 id="Integration-of-a-Droop-Controlled-Inverter"><a class="docs-heading-anchor" href="#Integration-of-a-Droop-Controlled-Inverter">Integration of a Droop-Controlled Inverter</a><a id="Integration-of-a-Droop-Controlled-Inverter-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-of-a-Droop-Controlled-Inverter" title="Permalink"></a></h2><p>In this section, we&#39;ll modify our network by adding a droop-controlled inverter.</p><h3 id="Mathematical-Background"><a class="docs-heading-anchor" href="#Mathematical-Background">Mathematical Background</a><a id="Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background" title="Permalink"></a></h3><p>The droop-controlled inverter implements a decentralized control strategy commonly used in microgrids and renewable energy integration. It establishes the following relationships:</p><p><strong>Power Measurement:</strong></p><p class="math-container">\[\begin{aligned}
P_{meas} &amp;= u_r \cdot i_r + u_i \cdot i_i\\
Q_{meas} &amp;= u_i \cdot i_r - u_r \cdot i_i
\end{aligned}\]</p><p><strong>Power Filtering (Low-pass filtering for measurement noise reduction):</strong></p><p class="math-container">\[\begin{aligned}
\tau \cdot \frac{dP_{filt}}{dt} &amp;= P_{meas} - P_{filt} \\
\tau \cdot \frac{dQ_{filt}}{dt} &amp;= Q_{meas} - Q_{filt}
\end{aligned}\]</p><p><strong>Droop Control:</strong></p><p class="math-container">\[\begin{aligned}
\omega &amp;= \omega_0 - K_p \cdot (P_{filt} - P_{set}) \\
V &amp;= V_{set} - K_q \cdot (Q_{filt} - Q_{set})
\end{aligned}\]</p><p><strong>Voltage Angle Dynamics:</strong></p><p class="math-container">\[\frac{d\delta}{dt} = \omega - \omega_0\]</p><p><strong>Output Voltage:</strong></p><p class="math-container">\[\begin{aligned}
u_r &amp;= V \cdot \cos(\delta) \\
u_i &amp;= V \cdot \sin(\delta)
\end{aligned}\]</p><p>These equations implement:</p><ul><li><strong>Frequency-Active Power Coupling (f-P)</strong>: Frequency decreases when active power exceeds setpoint</li><li><strong>Voltage-Reactive Power Coupling (V-Q)</strong>: Voltage decreases when reactive power exceeds setpoint</li></ul><p>This mimics the natural behavior of synchronous generators and enables stable power sharing in islanded operation.</p><h3 id="Definition-of-the-Droop-Inverter-Component"><a class="docs-heading-anchor" href="#Definition-of-the-Droop-Inverter-Component">Definition of the Droop Inverter Component</a><a id="Definition-of-the-Droop-Inverter-Component-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-Droop-Inverter-Component" title="Permalink"></a></h3><p>Network components in PowerDynamics must follow the <a href="../../ModelingConcepts/#Injector-Interface">Injector Interface</a> - they connect to the network through a single <code>Terminal</code>:</p><pre><code class="nohighlight hljs">      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
(t)   ‚îÇ                          ‚îÇ
 o‚Üê‚îÄ‚îÄ‚îÄ‚î§ Droop Inverter Equations ‚îÇ
      ‚îÇ                          ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre><p>We can define the following MTKModel to represent the droop inverter:</p><pre><code class="language-julia hljs">@mtkmodel DroopInverter begin
    @components begin
        terminal = Terminal()
    end

    @parameters begin
        Pset, [description=&quot;Active power setpoint&quot;, guess=1]
        Qset, [description=&quot;Reactive power setpoint&quot;, guess=0]
        Vset, [description=&quot;Voltage magnitude setpoint&quot;, guess=1]
        œâ‚ÇÄ=1, [description=&quot;Nominal frequency&quot;]
        Kp=1, [description=&quot;Active power droop coefficient&quot;]
        Kq=0.1, [description=&quot;Reactive power droop coefficient&quot;]
        œÑ_p = 1, [description=&quot;Active Power filter time constant&quot;]
        œÑ_q = 1, [description=&quot;Reactive Power filter time constant&quot;]
    end

    @variables begin
        Pmeas(t), [description=&quot;Measured active power&quot;, guess=1]
        Qmeas(t), [description=&quot;Measured reactive power&quot;, guess=0]
        Pfilt(t), [description=&quot;Filtered active power&quot;, guess=1]
        Qfilt(t), [description=&quot;Filtered reactive power&quot;, guess=1]
        œâ(t), [description=&quot;Frequency&quot;]
        Œ¥(t), [description=&quot;Voltage angle&quot;, guess=0]
        V(t), [description=&quot;Voltage magnitude&quot;]
    end

    @equations begin
        # Power measurement from terminal quantities
        Pmeas ~ terminal.u_r*terminal.i_r + terminal.u_i*terminal.i_i
        Qmeas ~ terminal.u_i*terminal.i_r - terminal.u_r*terminal.i_i

        # First-order low-pass filtering
        œÑ_p * Dt(Pfilt) ~ Pmeas - Pfilt
        œÑ_q * Dt(Qfilt) ~ Qmeas - Qfilt

        # Droop control equations
        œâ ~ œâ‚ÇÄ - Kp * (Pfilt - Pset)  # Frequency decreases with excess power
        V ~ Vset - Kq * (Qfilt - Qset)  # Voltage decreases with excess reactive power

        # Voltage angle dynamics
        Dt(Œ¥) ~ œâ - œâ‚ÇÄ

        # Output voltage components
        terminal.u_r ~ V*cos(Œ¥)
        terminal.u_i ~ V*sin(Œ¥)
    end
end;</code></pre><h3 id="Creating-a-Bus-with-the-Droop-Inverter"><a class="docs-heading-anchor" href="#Creating-a-Bus-with-the-Droop-Inverter">Creating a Bus with the Droop Inverter</a><a id="Creating-a-Bus-with-the-Droop-Inverter-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Bus-with-the-Droop-Inverter" title="Permalink"></a></h3><p>Following the descriptions in <a href="../../ModelingConcepts/#Modeling-Concepts">Modeling Concepts</a>, we build an MTKBus using the droop as the single injector and then compile the bus model, similar to how we define the templates in <a href="../ieee39_part1/#ieee39-part1">part I</a>:</p><pre><code class="nohighlight hljs">           ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
           ‚ïë Droop (compiled)        ‚ïë
 Network   ‚ïë  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ïë
interface  ‚ïë  ‚îÇ MTKBus             ‚îÇ ‚ïë
 current ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚ïë
           ‚ïë  ‚îÇ‚îÇBusBar‚îúo‚î§Inverter‚îÇ ‚îÇ ‚ïë
 voltage ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚ïë
           ‚ïë  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚ïë
           ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù</code></pre><pre><code class="language-julia hljs">@named inverter = DroopInverter()
mtkbus = MTKBus(inverter)
droop_bus_template = compile_bus(mtkbus; name=:DroopInverter)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:DroopInverter</span> <span class="sgr94">NoFeedForward()</span>
 ‚îú‚îÄ 2 inputs:  [busbar‚Çäi_r, busbar‚Çäi_i]
 ‚îú‚îÄ 3 states:  [inverter‚ÇäŒ¥<span class="sgr90">‚âà0</span>, inverter‚ÇäQfilt<span class="sgr90">‚âà1</span>, inverter‚ÇäPfilt<span class="sgr90">‚âà1</span>]
 ‚îú‚îÄ 2 outputs: [busbar‚Çäu_r=1, busbar‚Çäu_i=0]
 ‚îî‚îÄ 8 params:  [inverter‚ÇäPset<span class="sgr90">‚âà1</span>, inverter‚ÇäQset<span class="sgr90">‚âà0</span>, inverter‚ÇäVset<span class="sgr90">‚âà1</span>, inverter‚Çäœâ‚ÇÄ=1, inverter‚ÇäKp=1, inverter‚ÇäKq=0.1, inverter‚ÇäœÑ_p=1, inverter‚ÇäœÑ_q=1]</code></pre><p>We see that the droop inverter has 3 free parameters (you can check <code>free_p(droop_bus_template)</code> or <code>dump_initial_state(droop_bus_template)</code>). Therefore, similar to what we did in <a href="../ieee39_part2/#ieee39-part2">Part II</a>, we need to help the initialization by attaching an additional initialization formula to the bus:</p><pre><code class="language-julia hljs">set_initformula!(
    droop_bus_template,
    @initformula(:inverter‚ÇäVset = sqrt(:busbar‚Çäu_r^2 + :busbar‚Çäu_i^2))
)</code></pre><h3 id="Network-Modification-with-Droop-Inverter"><a class="docs-heading-anchor" href="#Network-Modification-with-Droop-Inverter">Network Modification with Droop Inverter</a><a id="Network-Modification-with-Droop-Inverter-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Modification-with-Droop-Inverter" title="Permalink"></a></h3><p>We&#39;ll replace bus 32 (originally a controlled generator bus) with our new droop inverter bus.</p><pre><code class="language-julia hljs">DROOP_BUS_IDX = 32</code></pre><p>To do so, we first collect all the &quot;old&quot; vertex and edge models.</p><div class="admonition is-success" id="Tip-7141b08556fca9ae"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-7141b08556fca9ae" title="Permalink"></a></header><div class="admonition-body"><p>We copy the components, to create individual instances for the new network. Since all the metadata (like the default values, initialize values and so on) are stored in the component models, we would otherwise share metadata between the old and the new network, which can lead to unexpected results.</p></div></div><pre><code class="language-julia hljs">vertex_models = [copy(nw[VIndex(i)]) for i in 1:nv(nw)];
edge_models = [copy(nw[EIndex(i)]) for i in 1:ne(nw)];</code></pre><p>Now we need to replace the original bus model at index <code>DROOP_BUS_IDX</code> with our new droop inverter bus. However, we don&#39;t want to lose the original power flow model associated with this bus, so we need to attach it to the droop bus model:</p><pre><code class="language-julia hljs">original_pfmodel = get_pfmodel(vertex_models[DROOP_BUS_IDX])</code></pre><p>We can then use the <code>Bus</code> constructor to essentially copy the droop<em>bus</em>template and adjust some properties, like the powerflow model and the vertex index.</p><pre><code class="language-julia hljs">droop_bus = compile_bus(droop_bus_template; pf=original_pfmodel, vidx=DROOP_BUS_IDX)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:DroopInverter</span> <span class="sgr94">NoFeedForward()</span> @ Vertex 32
 ‚îú‚îÄ 2 inputs:  [busbar‚Çäi_r, busbar‚Çäi_i]
 ‚îú‚îÄ 3 states:  [inverter‚ÇäŒ¥<span class="sgr90">‚âà0</span>, inverter‚ÇäQfilt<span class="sgr90">‚âà1</span>, inverter‚ÇäPfilt<span class="sgr90">‚âà1</span>]
 ‚îú‚îÄ 2 outputs: [busbar‚Çäu_r=1, busbar‚Çäu_i=0]
 ‚îú‚îÄ 8 params:  [inverter‚ÇäPset<span class="sgr90">‚âà1</span>, inverter‚ÇäQset<span class="sgr90">‚âà0</span>, inverter‚ÇäVset<span class="sgr90">‚âà1</span>, inverter‚Çäœâ‚ÇÄ=1, inverter‚ÇäKp=1, inverter‚ÇäKq=0.1, inverter‚ÇäœÑ_p=1, inverter‚ÇäœÑ_q=1]
 ‚îî‚îÄ 1 add. init eq. from 1 formula setting [:inverter‚ÇäVset]
<span class="sgr34"><span class="sgr1">Powerflow model </span></span>:pvbus with [pv‚ÇäP=6.5, pv‚ÇäV=0.9831]</code></pre><p>We then replace the original bus model in the array with our droop bus and build a network again:</p><pre><code class="language-julia hljs">vertex_models[DROOP_BUS_IDX] = droop_bus
nw_droop = Network(vertex_models, edge_models)
set_jac_prototype!(nw_droop; remove_conditions=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Network with 189 states and 1272 parameters
 ‚îú‚îÄ 39 vertices (6 unique types)
 ‚îî‚îÄ 46 edges (1 unique type)
Edge-Aggregation using SequentialAggregator(+)
Jacobian prototype defined: <span class="sgr34">3.45% sparsity</span>
2 callback sets across 0 vertices and 1 edge</code></pre><p>Additionally, we&#39;ve set the jacobian prototype for performance gains during simulation and optimization, see NetworkDynamics docs on <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/sparsity_detection/">Sparsity Detection</a>.</p><h3 id="Network-Initialization-with-Droop-Inverter"><a class="docs-heading-anchor" href="#Network-Initialization-with-Droop-Inverter">Network Initialization with Droop Inverter</a><a id="Network-Initialization-with-Droop-Inverter-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Initialization-with-Droop-Inverter" title="Permalink"></a></h3><p>The modified network requires the same initialization steps as the original:</p><ol><li>Power flow solution</li><li>Dynamic component initialization</li></ol><p>This all happens within <a href="../../API/#PowerDynamics.initialize_from_pf!"><code>initialize_from_pf!</code></a>:</p><pre><code class="language-julia hljs">s0_droop = initialize_from_pf!(nw_droop; verbose=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"><span class="sgr1">‚îå Warning: </span></span>The `alias_u0` keyword argument is deprecated. Please use a NonlinearAliasSpecifier, e.g. `alias = NonlinearAliasSpecifier(alias_u0 = true)`.
<span class="sgr33"><span class="sgr1">‚îî </span></span><span class="sgr90">@ NonlinearSolveBase ~/.julia/packages/NonlinearSolveBase/2E600/src/solve.jl:57</span></code></pre><p>Let&#39;s examine the initialized state of our droop inverter:</p><pre><code class="language-julia hljs">dump_initial_state(nw_droop[VIndex(DROOP_BUS_IDX)]; obs=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">Inputs:</span>
  busbar‚Çäi_i            = <span class="sgr34"> 1.7883</span>
  busbar‚Çäi_r            = <span class="sgr34">-6.6986</span>
<span class="sgr1">States:</span>
  inverter‚ÇäPfilt        = <span class="sgr33"> 6.5</span>      (guess  1)
  inverter‚ÇäQfilt        = <span class="sgr33"> 2.0514</span>   (guess  1)
  inverter‚ÇäŒ¥            = <span class="sgr33"> 0.044837</span> (guess  0)
<span class="sgr1">Outputs:</span>
  busbar‚Çäu_i            = <span class="sgr34"> 0.044064</span>
  busbar‚Çäu_r            = <span class="sgr34"> 0.98211</span>
<span class="sgr1">Parameters:</span>
  inverter‚ÇäKp           = <span class="sgr34"> 1</span>
  inverter‚ÇäKq           = <span class="sgr34"> 0.1</span>
  inverter‚ÇäPset         = <span class="sgr33"> 6.5</span>      (guess  1)
  inverter‚ÇäQset         = <span class="sgr33"> 2.0514</span>   (guess  0)
  inverter‚ÇäVset         = <span class="sgr34"> 0.9831</span>   (guess  1)
  inverter‚ÇäœÑ_p          = <span class="sgr34"> 1</span>
  inverter‚ÇäœÑ_q          = <span class="sgr34"> 1</span>
  inverter‚Çäœâ‚ÇÄ           = <span class="sgr34"> 1</span></code></pre><p>We see that the filtered powers match the setpoints (steady state), and both <span>$P$</span> and <span>$V_\mathrm{set}$</span> are initialized according to the parameters of the PV powerflow model.</p><h3 id="Simulation-with-Droop-Inverter"><a class="docs-heading-anchor" href="#Simulation-with-Droop-Inverter">Simulation with Droop Inverter</a><a id="Simulation-with-Droop-Inverter-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-with-Droop-Inverter" title="Permalink"></a></h3><p>Now we&#39;ll simulate the modified network and compare it with the original system response:</p><pre><code class="language-julia hljs">prob_droop = ODEProblem(nw_droop, uflat(s0_droop), (0.0, 15.0), copy(pflat(s0_droop));
                       callback=get_callbacks(nw_droop))
sol_droop = solve(prob_droop, Rodas5P())
@assert SciMLBase.successful_retcode(sol_droop)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Short circuit activated on line 5‚Üí8 at t = 0.1s
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Line 5‚Üí8 disconnected at t = 0.2s</code></pre><h3 id="Comparison-of-System-Responses"><a class="docs-heading-anchor" href="#Comparison-of-System-Responses">Comparison of System Responses</a><a id="Comparison-of-System-Responses-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-System-Responses" title="Permalink"></a></h3><p>Let&#39;s compare how the droop inverter affects the system&#39;s response to the short circuit disturbance:</p><pre><code class="language-julia hljs">let fig = Figure(; size=(1000, 600))
    selected_buses = [3, 4, 25, DROOP_BUS_IDX]  # Representative buses including the droop bus
    ts = range(0, 10, length=1000)

    for (i, bus) in enumerate(selected_buses)
        row, col = divrem(i-1, 2) .+ (1, 1)
        ax = Axis(fig[row, col];
                  title=&quot;Voltage Magnitude at Bus $bus&quot; * (bus==DROOP_BUS_IDX ? &quot; (droop bus)&quot; : &quot;&quot;),
                  xlabel=&quot;Time [s]&quot;,
                  ylabel=&quot;Voltage [pu]&quot;)

        # Original system response
        lines!(ax, ts, sol(ts; idxs=VIndex(bus, :busbar‚Çäu_mag)).u;
               label=&quot;Original System&quot;, color=:blue, linewidth=2)

        # Droop inverter system response
        lines!(ax, ts, sol_droop(ts; idxs=VIndex(bus, :busbar‚Çäu_mag)).u;
               label=&quot;With Droop Inverter&quot;, color=:red, linewidth=2)

        ylims!(ax, 0.85, 1.15)
        i == 1 &amp;&amp; axislegend(ax; position=:rb)
    end

    fig
end</code></pre><img src="6b41d1b2.png" alt="Example block output"/><p>We see that the overall system reacts similarly but distinctly differently to the identical disturbance.</p><h2 id="Parameter-Optimization"><a class="docs-heading-anchor" href="#Parameter-Optimization">Parameter Optimization</a><a id="Parameter-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Optimization" title="Permalink"></a></h2><p>To showcase advanced capabilities of the SciML-ecosystem and the integration with PowerDynamics.jl, we now want to try to <em>tune</em> the droop inverter parameters so that the overall system behavior more closely resembles the original behavior, i.e., to reduce the difference between the system with generator and the system with droop inverter.</p><h3 id="Optimization-Problem-Formulation"><a class="docs-heading-anchor" href="#Optimization-Problem-Formulation">Optimization Problem Formulation</a><a id="Optimization-Problem-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Problem-Formulation" title="Permalink"></a></h3><p>We define a loss function that measures the deviation between the original system response and the modified system response:</p><p class="math-container">\[L(p) = \sum_{i,t} |x_{ref}(t)_i - x(t;p)_i|^2\]</p><p>Where we have</p><ul><li>Parameters <span>$p = [K_p, K_q, \tau]$</span> to be optimized</li><li>the reference solution <span>$x_{ref}(t)$</span> (original system)</li><li>the solution of the modified system <span>$x(t;p)$</span> with updated parameters <span>$p$</span></li></ul><p><strong>Goal:</strong> Find parameters <span>$p$</span> that minimize this loss function, making the droop inverter system behave as closely as possible to the original system.</p><h3 id="Setting-Up-the-Optimization"><a class="docs-heading-anchor" href="#Setting-Up-the-Optimization">Setting Up the Optimization</a><a id="Setting-Up-the-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Up-the-Optimization" title="Permalink"></a></h3><p>First, we define the reference solution and identify the tunable parameters.</p><p>We probe the original solution at fixed timepoints, exporting <code>u_r</code> and <code>u_i</code> for every bus:</p><pre><code class="language-julia hljs">opt_ref = sol(0.3:0.1:10, idxs=[VIndex(1:39, :busbar‚Çäu_r), VIndex(1:39, :busbar‚Çäu_i)])</code></pre><p>Next, we need to identify the &quot;tunable&quot; parameters. This is a bit tricky, because the overall <code>nw_droop</code> has 1271 parameters, so we need to find the indices of the parameters we want to tune in the flat parameter array. We can do so, by leveraging NetworkDynamics implementation of the <a href="https://github.com/SciML/SymbolicIndexingInterface.jl">SymbolicIndexingInterface</a>: tunable_parameters = [:inverter‚ÇäKp, :inverter‚ÇäKq, :inverter‚ÇäœÑ]</p><pre><code class="language-julia hljs">tunable_parameters = [:inverter‚ÇäKp, :inverter‚ÇäKq, :inverter‚ÇäœÑ_p, :inverter‚ÇäœÑ_q]
tp_idx = SII.parameter_index(sol_droop, VIndex(DROOP_BUS_IDX, tunable_parameters))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Int64}:
 503
 504
 505
 506</code></pre><p>We also get their initial values, which we use as the starting point for the optimization.</p><pre><code class="language-julia hljs">p0 = sol_droop(sol_droop.t[begin], idxs=collect(VIndex(DROOP_BUS_IDX, tunable_parameters)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 1.0
 0.1
 1.0
 1.0</code></pre><h3 id="Loss-Function-Implementation"><a class="docs-heading-anchor" href="#Loss-Function-Implementation">Loss Function Implementation</a><a id="Loss-Function-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Loss-Function-Implementation" title="Permalink"></a></h3><p>The loss function simulates the system with given parameters and compares the result to the reference:</p><pre><code class="language-julia hljs">function loss(p)
    # Create parameter vector for the full system
    # allp = similar(p, pdim(nw_droop)) # create a vector of the full length
    allp = similar(p, length(s0_droop.p)) # create a vector of the full length
    allp .= pflat(s0_droop.p) # copy all &quot;initial&quot; parameters to that vector
    allp[tp_idx] .= p  # Update only the tunable parameters with the parameters for the given optimization iteration

    # Solve the system with new parameters
    _sol = solve(prob_droop, Rodas5P(autodiff=true);
        p = allp,
        saveat = opt_ref.t,
        tspan=(0.0, opt_ref.t[end]),
        initializealg = SciMLBase.NoInit(),
        abstol=0.01,
        reltol=0.01
    )

    # Return infinite loss if simulation failed
    if !SciMLBase.successful_retcode(_sol)
        @warn &quot;Retcode $(_sol.retcode) indicates a failed simulation, returning Inf loss&quot;
        return Inf
    end

    # Extract solution at reference time points
    x = _sol(opt_ref.t; idxs=[VIndex(1:39, :busbar‚Çäu_r), VIndex(1:39, :busbar‚Çäu_i)])

    # Compute L2 norm of the difference
    res = opt_ref.u - x.u
    l2loss = sum(abs2, reduce(vcat, res))
end</code></pre><h3 id="Optimization-Execution"><a class="docs-heading-anchor" href="#Optimization-Execution">Optimization Execution</a><a id="Optimization-Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Execution" title="Permalink"></a></h3><p>We use the Optimization.jl ecosystem with the Adam optimizer:</p><pre><code class="language-julia hljs"># Create optimization function with automatic differentiation
optf = Optimization.OptimizationFunction((x, p) -&gt; loss(x), Optimization.AutoForwardDiff())</code></pre><p>To better monitor the optimization progress, we want to store the optimized parameters at every iteration of the optimizer. We can do so by defining a callback function for the optimizer:</p><pre><code class="language-julia hljs">optimization_states = Any[] # global variable to store the optimization parameters at each step
callback = function (state, l)
    push!(optimization_states, state)
    println(&quot;Iteration $(state.iter): loss = $l\t p = $(state.u)&quot;)
    return false  # Continue optimization
end</code></pre><p>That callback will snapshot the current parameter values at every step of the gradient descent.</p><p>With that, we can run the optimization:</p><pre><code class="language-julia hljs">optprob = Optimization.OptimizationProblem(optf, p0; callback)

@time optsol = Optimization.solve(optprob, Optimisers.Adam(0.06), maxiters = 50)

println(&quot;\nOptimization completed!&quot;)
println(&quot;Initial parameters: &quot;, p0)
println(&quot;Optimized parameters: &quot;, optsol.u)
println(&quot;Initial loss: &quot;, loss(p0))
println(&quot;Final loss: &quot;, loss(optsol.u))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iteration 1: loss = 452.08075188374306	 p = [1.0, 0.1, 1.0, 1.0]
Iteration 2: loss = 309.92291410422524	 p = [1.059999999999443, 0.15999999999971232, 0.9400000000065613, 0.9400000000258409]
Iteration 3: loss = 226.82839704704162	 p = [1.1194298999367127, 0.21256940171440722, 0.8799295250438611, 0.9478688916905107]
Iteration 4: loss = 175.6490386409297	 p = [1.1780147841755655, 0.2577764624083744, 0.8197515909382995, 0.9831253769802683]
Iteration 5: loss = 128.0715840756037	 p = [1.2355547875003001, 0.29636066108204306, 0.7593807157961713, 1.0282550822294174]
Iteration 6: loss = 89.87416214861355	 p = [1.2916704173826774, 0.32942652634741126, 0.6987841384665628, 1.0782158940049629]
Iteration 7: loss = 59.397358469302404	 p = [1.3459519376840572, 0.35796169723557486, 0.6380836254467048, 1.1306462126082761]
Iteration 8: loss = 35.55759331995369	 p = [1.3979563845396434, 0.3827887307862295, 0.5775666868256443, 1.183881934388158]
Iteration 9: loss = 19.289563385048215	 p = [1.447209590452652, 0.40457492739161593, 0.5176550372864499, 1.2364203745085687]
Iteration 10: loss = 9.482571511085062	 p = [1.493229627813813, 0.42385248170518464, 0.45910385915022384, 1.2868058666368618]
Iteration 11: loss = 6.306839966614896	 p = [1.5354844284539295, 0.441025316947179, 0.4034533495101584, 1.3336213443823333]
Iteration 12: loss = 9.408687458159175	 p = [1.573391732690586, 0.45638309761878365, 0.35382677084701164, 1.375590097654233]
Iteration 13: loss = 16.757691076174037	 p = [1.6063789993817605, 0.4701023513076332, 0.3152009134417312, 1.4118237116979608]
Iteration 14: loss = 24.66848727522636	 p = [1.6340650960724554, 0.48228264961349565, 0.29181187093783073, 1.4420159040780614]
Iteration 15: loss = 30.727188606416043	 p = [1.6563620561092953, 0.49300922576536, 0.28445441967011376, 1.4662888417578859]
Iteration 16: loss = 33.29000164234358	 p = [1.673434920289171, 0.5023901890653872, 0.29107508947377786, 1.4849613387926928]
Iteration 17: loss = 32.58296668437866	 p = [1.6856810514071066, 0.5105773032073904, 0.3086430800539049, 1.498405663201713]
Iteration 18: loss = 29.820751752176474	 p = [1.6936402483591935, 0.5177506940859506, 0.334406943447507, 1.5070068209520553]
Iteration 19: loss = 25.25340866084408	 p = [1.6979007290597412, 0.5240893569858973, 0.3661640810155403, 1.51118630314964]
Iteration 20: loss = 20.472909761912035	 p = [1.6991165205773444, 0.529759894767111, 0.40200025371230635, 1.5114530450842183]
Iteration 21: loss = 15.731935194522173	 p = [1.697920747111341, 0.5349021983685597, 0.4403412972750683, 1.508363944818234]
Iteration 22: loss = 12.296658526714566	 p = [1.6949633149642989, 0.5396144184085729, 0.47959651146418797, 1.5026307184201777]
Iteration 23: loss = 9.812180195918156	 p = [1.6907933538760467, 0.5439597841832307, 0.5184806740948318, 1.494951447210932]
Iteration 24: loss = 8.286578236479938	 p = [1.6858990707447417, 0.5479706221845844, 0.5559196154649838, 1.4860553495538549]
Iteration 25: loss = 7.513453830217857	 p = [1.680698049174724, 0.551657900817816, 0.5910911708607046, 1.4766589123476905]
Iteration 26: loss = 7.4774976502063435	 p = [1.6755315263582897, 0.5550205509677857, 0.623450360437228, 1.4674252698173444]
Iteration 27: loss = 7.831846838621225	 p = [1.6706693310039034, 0.558050918360413, 0.652630448681355, 1.458941765769379]
Iteration 28: loss = 8.384364186805982	 p = [1.6663191097187982, 0.5607400602709538, 0.6784238074887508, 1.4517034713986996]
Iteration 29: loss = 9.052317722854792	 p = [1.662650384230256, 0.5630792749932242, 0.7007259879687877, 1.4461371459316703]
Iteration 30: loss = 9.7312012430607	 p = [1.6597874180876093, 0.5650630598013152, 0.7195287435294693, 1.4425745830382974]
Iteration 31: loss = 10.448712117406004	 p = [1.6578099092768213, 0.5666960005106584, 0.7349004631895302, 1.4412123659358969]
Iteration 32: loss = 10.928094781900613	 p = [1.6567671597475333, 0.5679824323811589, 0.7469761748555436, 1.442194900344455]
Iteration 33: loss = 11.23427360506784	 p = [1.6566599346688946, 0.5689348845711387, 0.7559279926519681, 1.4455270974328505]
Iteration 34: loss = 11.365834194905679	 p = [1.657458067867248, 0.5695715642967112, 0.7619588285440315, 1.451123545064864]
Iteration 35: loss = 11.332204725226479	 p = [1.6591026957195334, 0.5699159161456222, 0.7652957480186506, 1.4588184603006449]
Iteration 36: loss = 11.155308118946866	 p = [1.661510382419204, 0.569995775772664, 0.7661844681565694, 1.4683807791642338]
Iteration 37: loss = 10.86657174010134	 p = [1.6645777228059275, 0.5698352836255819, 0.7648836168483291, 1.4795668961359898]
Iteration 38: loss = 10.50574336364486	 p = [1.6681856365984153, 0.5694688492195735, 0.7616619089504514, 1.4920567104169178]
Iteration 39: loss = 10.11050907559389	 p = [1.6722042324344724, 0.5689317320186521, 0.7567925708205194, 1.5055122089731667]
Iteration 40: loss = 9.71134115065926	 p = [1.6764974926891592, 0.5682587286870392, 0.7505490391131958, 1.5195917463960045]
Iteration 41: loss = 9.334920819201288	 p = [1.6809281649953, 0.567483000933413, 0.7432012155766882, 1.5339630154847974]
Iteration 42: loss = 9.004307468043258	 p = [1.6853618229672152, 0.5666351471214359, 0.7350130316971382, 1.5483133500408086]
Iteration 43: loss = 8.687302864164163	 p = [1.6896699199441547, 0.5657425141184825, 0.726240624773, 1.5623572355123807]
Iteration 44: loss = 8.5110199808066	 p = [1.6937095068470212, 0.564831965876985, 0.7171493953126574, 1.5757917453299037]
Iteration 45: loss = 8.404403188091539	 p = [1.6973701776536225, 0.5639227637885658, 0.7079754291734625, 1.5884019682526858]
Iteration 46: loss = 8.358933544578328	 p = [1.7005546752978375, 0.5630300755790092, 0.6989374839609984, 1.6000119811817697]
Iteration 47: loss = 8.361022956405279	 p = [1.7031808887730264, 0.5621651345995912, 0.6902331254061366, 1.6104858772574042]
Iteration 48: loss = 8.393893734681978	 p = [1.7051832972001018, 0.5613356020524336, 0.6820353246522831, 1.6197271409908087]
Iteration 49: loss = 8.439859924533696	 p = [1.706514083131659, 0.5605460579573774, 0.6744888642637578, 1.6276769266751678]
Iteration 50: loss = 8.483888835704784	 p = [1.7071438658396336, 0.5597985279104635, 0.6677067020597176, 1.6343116496506576]
Iteration 50: loss = 6.306839966614896	 p = [1.5354844284539295, 0.441025316947179, 0.4034533495101584, 1.3336213443823333]
 44.689807 seconds (47.05 M allocations: 3.293 GiB, 1.45% gc time, 52.05% compilation time)

Optimization completed!
Initial parameters: [1.0, 0.1, 1.0, 1.0]
Optimized parameters: [1.5354844284539295, 0.441025316947179, 0.4034533495101584, 1.3336213443823333]
Initial loss: 455.72825980863786
Final loss: 6.273945643822323</code></pre><h3 id="Optimization-Results-Analysis"><a class="docs-heading-anchor" href="#Optimization-Results-Analysis">Optimization Results Analysis</a><a id="Optimization-Results-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Results-Analysis" title="Permalink"></a></h3><p>Let&#39;s visualize how the optimization improved the system behavior:</p><pre><code class="language-julia hljs">function plot_optimization_comparison(p_initial, p_current)
    fig = Figure(; size=(1200, 800))
    selected_buses = [3, 4, 25, DROOP_BUS_IDX]
    ts = range(0, 10, length=1000)

    # Simulate with optimized parameters
    allp_opt = @lift let
        _p = copy(pflat(s0_droop))
        _p[tp_idx] .= $p_current
        _p
    end
    sol_opt = @lift solve(prob_droop, Rodas5P(); p=$allp_opt)


    for (i, bus) in enumerate(selected_buses)
        row, col = divrem(i-1, 2) .+ (1, 1)
        ax = Axis(fig[row, col];
                  title=&quot;Voltage Magnitude at Bus $bus&quot; * (bus==DROOP_BUS_IDX ? &quot; (droop bus)&quot; : &quot;&quot;),
                  xlabel=&quot;Time [s]&quot;,
                  ylabel=&quot;Voltage [pu]&quot;)

        # Reference (original system)
        lines!(ax, ts, sol(ts; idxs=VIndex(bus, :busbar‚Çäu_mag)).u;
               label=&quot;Reference&quot;, linestyle=:solid, color=:blue, linewidth=2)

        # Initial droop parameters
        lines!(ax, ts, sol_droop(ts; idxs=VIndex(bus, :busbar‚Çäu_mag)).u;
               label=&quot;Initial Droop&quot;, linestyle=:dash, color=:red, linewidth=2)

        # Optimized droop parameters
        dat = @lift $(sol_opt)(ts; idxs=VIndex(bus, :busbar‚Çäu_mag)).u
        lines!(ax, ts, dat; label=&quot;Optimized Droop&quot;, color=:green, linewidth=2)

        ylims!(ax, 0.85, 1.15)
        i == 1 &amp;&amp; axislegend(ax; position=:rb)
    end

    fig
end

pobs = Observable(p0)
comparison_fig = plot_optimization_comparison(p0, pobs)
record(comparison_fig, &quot;parameter_evolution.mp4&quot;, optimization_states; framerate=10) do s
    pobs[] = s.u
end</code></pre><p><video src="../parameter_evolution.mp4" controls="true" title="timeseries evolution animation"><a href="../parameter_evolution.mp4">timeseries evolution animation</a></video></p><h3 id="Parameter-Evolution-During-Optimization"><a class="docs-heading-anchor" href="#Parameter-Evolution-During-Optimization">Parameter Evolution During Optimization</a><a id="Parameter-Evolution-During-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Evolution-During-Optimization" title="Permalink"></a></h3><p>Let&#39;s see how each parameter changed during the optimization process:</p><pre><code class="language-julia hljs">let fig = Figure(; size=(1000, 800))
    param_names = [&quot;Kp&quot;, &quot;Kq&quot;, &quot;œÑ_p&quot;, &quot;œÑ_q&quot;]
    for (i, param_name) in enumerate(param_names)
        row = (i-1) √∑ 2 + 1
        col = (i-1) % 2 + 1
        ax = Axis(fig[row, col];
                  title=&quot;Parameter Evolution: $param_name&quot;,
                  xlabel=&quot;Iteration&quot;,
                  ylabel=&quot;Parameter Value&quot;)

        # Extract parameter values over iterations
        param_values = [state.u[i] for state in optimization_states[1:end-1]]
        iterations = [state.iter for state in optimization_states[1:end-1]]

        scatterlines!(ax, iterations, param_values; linewidth=3, markersize=6, color=:blue)

        # Mark initial and final values
        hlines!(ax, [p0[i]]; linestyle=:dash, color=:gray, alpha=0.7)
        text!(ax, 1, p0[i]; text=&quot;Initial: $(round(p0[i], digits=3))&quot;,
              fontsize=10, color=:gray)

        lossax = Axis(fig[row, col],
            yticklabelcolor=:black,
            yaxisposition = :right,
            ylabel=&quot;loss&quot;, yscale=log10,
            xgridvisible=false, ygridvisible=false
        )
        scatterlines!(
            lossax,
            iterations,
            [loss(s.u) for s in optimization_states[1:end-1]],
            color=:black, linewidth=1, markersize=3,
        )
    end
    fig
end</code></pre><img src="50779ef3.png" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ieee39_part3/">¬´ IEEE39 Part III: Simulation</a><a class="docs-footer-nextpage" href="../emt_toymodel/">EMT Toymodel ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 15 October 2025 02:23">Wednesday 15 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
