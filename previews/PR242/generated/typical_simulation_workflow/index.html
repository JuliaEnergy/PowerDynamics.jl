<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Typical Simulation Workflow Â· PowerDynamics.jl</title><meta name="title" content="Typical Simulation Workflow Â· PowerDynamics.jl"/><meta property="og:title" content="Typical Simulation Workflow Â· PowerDynamics.jl"/><meta property="twitter:title" content="Typical Simulation Workflow Â· PowerDynamics.jl"/><meta name="description" content="Documentation for PowerDynamics.jl."/><meta property="og:description" content="Documentation for PowerDynamics.jl."/><meta property="twitter:description" content="Documentation for PowerDynamics.jl."/><meta property="og:url" content="https://juliaenergy.github.io/PowerDynamics.jl/generated/typical_simulation_workflow/"/><meta property="twitter:url" content="https://juliaenergy.github.io/PowerDynamics.jl/generated/typical_simulation_workflow/"/><link rel="canonical" href="https://juliaenergy.github.io/PowerDynamics.jl/generated/typical_simulation_workflow/"/><meta property="og:image" content="https://juliaenergy.github.io/PowerDynamics.jl/assets/preview.png"/><meta property="twitter:image" content="https://juliaenergy.github.io/PowerDynamics.jl/assets/preview.png"/><meta property="twitter:card" content="summary_large_image"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="PowerDynamics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="PowerDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PowerDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../ModelingConcepts/">Modeling Concepts</a></li><li><a class="tocitem" href="../../initialization/">Initialization</a></li><li><a class="tocitem" href="../../Library/">Component Library</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../julia_setup/">Julia Setup for New Users</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Typical Simulation Workflow</a><ul class="internal"><li><a class="tocitem" href="#Stage-I:-Defining-Dynamical-Models"><span>Stage I: Defining Dynamical Models</span></a></li><li><a class="tocitem" href="#Stage-II:-Initialization"><span>Stage II: Initialization</span></a></li><li><a class="tocitem" href="#Stage-III:-Time-Domain-Simulation"><span>Stage III: Time Domain Simulation</span></a></li><li><a class="tocitem" href="#Stage-IV:-Postprocessing-and-Visualization"><span>Stage IV: Postprocessing and Visualization</span></a></li></ul></li><li><a class="tocitem" href="../custom_bus/">Custom Generator Bus</a></li><li><a class="tocitem" href="../custom_line/">Custom Transmission Line</a></li></ul></li><li><span class="tocitem">Advanced Examples</span><ul><li><a class="tocitem" href="../ieee9bus/">IEEE 9-Bus Example</a></li><li><a class="tocitem" href="../ieee39_part1/">IEEE39 Part I: Modeling</a></li><li><a class="tocitem" href="../ieee39_part2/">IEEE39 Part II: Initialization</a></li><li><a class="tocitem" href="../ieee39_part3/">IEEE39 Part III: Simulation</a></li><li><a class="tocitem" href="../ieee39_part4/">IEEE39 Part IV: Parameter Tuning</a></li><li><a class="tocitem" href="../emt_toymodel/">EMT Toymodel</a></li></ul></li><li><a class="tocitem" href="../../API/">API</a></li><li><a class="tocitem" href="../../networkdynamics_forward/">ğŸ”— NetworkDynamics.jl Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Typical Simulation Workflow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Typical Simulation Workflow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaEnergy/PowerDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/main/docs/tutorials/typical_simulation_workflow.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="typical-simulation-workflow"><a class="docs-heading-anchor" href="#typical-simulation-workflow">Typical Simulation Workflow</a><a id="typical-simulation-workflow-1"></a><a class="docs-heading-anchor-permalink" href="#typical-simulation-workflow" title="Permalink"></a></h1><p>The goal of this tutorial is to get you started with PowerDynamics.jl. We&#39;ll walk you through the different &quot;stages&quot; of a typical simulation workflow while introducing key terminology along the way.</p><p>This tutorial can be downloaded as a normal Julia script <a href="../typical_simulation_workflow.jl">here</a>.</p><p>The system to model is a simple 3 bus system:</p><ul><li>Bus 1: ideal droop inverter</li><li>Bus 2: a constant Y load</li><li>Bus 3: a second constant Y load</li></ul><p>All buses are connected with standard pi-model power lines.</p><pre><code class="language-asciiart hljs">    â•­â”€â”€â”€â”€â”€â”€â”€â•®
2 â”¯â”â”¿       â”¿â”â”¯ 3
  â†“ â”‚   â•­â”€â”€â”€â•¯ â†“
    â”·â”â”¯â”â”· 1
      â”‚
     (~)</code></pre><pre><code class="language-julia hljs">using PowerDynamics
using PowerDynamics: Library
using OrdinaryDiffEqRosenbrock
using OrdinaryDiffEqNonlinearSolve
using CairoMakie</code></pre><h2 id="Stage-I:-Defining-Dynamical-Models"><a class="docs-heading-anchor" href="#Stage-I:-Defining-Dynamical-Models">Stage I: Defining Dynamical Models</a><a id="Stage-I:-Defining-Dynamical-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-I:-Defining-Dynamical-Models" title="Permalink"></a></h2><p>The first phase of the workflow is typically to define your dynamical models. Models may either come from a library (like the <code>IdealDroopInverter</code> and <code>ConstantYLoad</code> below) or they can be defined by the user.</p><h3 id="Inverter-Model"><a class="docs-heading-anchor" href="#Inverter-Model">Inverter Model</a><a id="Inverter-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Inverter-Model" title="Permalink"></a></h3><p>In this case, we want the first bus to be an ideal droop inverter.</p><p>Often, model definition will be a multi step process:</p><p><strong>First</strong>: we define an <a href="../../ModelingConcepts/#Injector-Interface">&quot;injector model&quot;</a>, in this case our inverter:</p><pre><code class="language-asciiart hljs">(t) â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 oâ”€â”€â”¤ Droop Inverter â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><pre><code class="language-julia hljs">inverter_model = Library.IdealDroopInverter(; name=:droop, Vset=1)</code></pre><p>This model is an equation-based/symbolic model representing the dynamics. It is based on the great <a href="https://mtk.sciml.ai/stable/">ModelingToolkit.jl Library</a>.</p><p><strong>Second</strong>: we build a <a href="../../ModelingConcepts/#MTKBus-Interface">&quot;Bus Model&quot;</a>, which connects the injector to a Busbar. This model still lives in the equation-based/symbolic domain.</p><pre><code class="language-asciiart hljs">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚BusModel                       â”‚
â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚â”‚ BusBar â”œâ”€oâ”€â”¤ Droop inverter â”‚â”‚
â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><pre><code class="language-julia hljs">bus_model = MTKBus(inverter_model; name=:invbus)</code></pre><p><strong>Third</strong>: we compile the symbolic model into a julia function for numeric simulation. Doing so, we get a <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.VertexModel-Tuple%7B%7D"><code>VertexModel</code></a>, which is an object from our backend <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/">NetworkDynamics.jl</a></p><pre><code class="language-asciiart hljs">           â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 Network   â•‘ VertexModel (compiled)         â•‘
interface  â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘
           â•‘  â”‚BusModel                   â”‚ â•‘
 current â”€â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â•‘
           â•‘  â”‚â”‚BusBarâ”œoâ”¤ Droop inverter â”‚â”‚ â•‘
 voltage â†â”€â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â•‘
           â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘
           â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</code></pre><pre><code class="language-julia hljs">bus1 = compile_bus(MTKBus(inverter_model); vidx=1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:bus</span> <span class="sgr94">NoFeedForward()</span> @ Vertex 1
 â”œâ”€ 2 inputs:  [busbarâ‚Ši_r, busbarâ‚Ši_i]
 â”œâ”€ 3 states:  [droopâ‚ŠÎ´<span class="sgr90">â‰ˆ0</span>, droopâ‚ŠQfilt<span class="sgr90">â‰ˆ1</span>, droopâ‚ŠPfilt<span class="sgr90">â‰ˆ1</span>]
 â”œâ”€ 2 outputs: [busbarâ‚Šu_r=1, busbarâ‚Šu_i=0]
 â””â”€ 8 params:  [droopâ‚ŠPset<span class="sgr90">â‰ˆ1</span>, droopâ‚ŠQset<span class="sgr90">â‰ˆ0</span>, droopâ‚ŠVset=1, droopâ‚ŠÏ‰â‚€=1, droopâ‚ŠKp=1, droopâ‚ŠKq=0.1, droopâ‚ŠÏ„_p=1, droopâ‚ŠÏ„_q=1]</code></pre><p>Note that this model is <strong>no longer symbolic</strong>. The equations have been reduced and transformed into a nonlinear descriptor model. For more information on the different model types, see the <a href="../../ModelingConcepts/#Modeling-Concepts">Modeling Concepts</a> docs. You can check out the NetworkDynamics.jl doc on the underlying <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/mathematical_model/#Mathematical-Model">mathematical model</a>.</p><p>In the printout above, you can see that we consider different types of variables in our models:</p><ul><li>the <strong>input</strong> is always the current flowing from the attached power lines into the bus,</li><li>the <strong>output</strong> is always the voltage at the busbar,</li><li>the <strong>states</strong> are dynamical or algebraic states in the sense of a Differential-Algebraic-Equation (DAE) model,</li><li>and <strong>parameters</strong> are static values that stay mostly constant during simulation and define the system behavior.</li></ul><p>There is a 5th class of states not shown above: <strong>observables</strong>. Observables are time dependent values, which are not states in the sense of a DAE but can be reconstructed from the states, inputs, outputs and parameters. Thus, they don&#39;t need to be &quot;solved&quot; for numerically, but they can be reconstructed in post-processing. A simple example of an &quot;observed&quot; state would be a voltage angle or the active and reactive power at some bus.</p><h3 id="Load-Models"><a class="docs-heading-anchor" href="#Load-Models">Load Models</a><a id="Load-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Load-Models" title="Permalink"></a></h3><p>For the two loads, we use the predefined <code>ConstantYLoad</code> model from the Library and compile them:</p><pre><code class="language-julia hljs">load_model = Library.ConstantYLoad(; name=:load)
bus2 = compile_bus(MTKBus(load_model); name=:loadbus, vidx=2)
bus3 = compile_bus(MTKBus(load_model); name=:loadbus, vidx=3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:loadbus</span> <span class="sgr94">PureStateMap()</span> @ Vertex 3
 â”œâ”€ 2 inputs:  [busbarâ‚Ši_r, busbarâ‚Ši_i]
 â”œâ”€ 2 states:  [busbarâ‚Šu_r=1, busbarâ‚Šu_i=0]
 |    with diagonal mass matrix [0, 0]
 â”œâ”€ 2 outputs: [busbarâ‚Šu_r=1, busbarâ‚Šu_i=0]
 â””â”€ 2 params:  [loadâ‚ŠB<span class="sgr90">â‰ˆ1</span>, loadâ‚ŠG<span class="sgr90">â‰ˆ1</span>]</code></pre><h3 id="Power-Line-Models"><a class="docs-heading-anchor" href="#Power-Line-Models">Power Line Models</a><a id="Power-Line-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Line-Models" title="Permalink"></a></h3><p>Lastly, we need to define three power lines. The workflow is similar to the bus models:</p><pre><code class="language-julia hljs">l = MTKLine(Library.PiLine(; name=:piline))
line12 = compile_line(l; src=1, dst=2, pilineâ‚ŠR=0.01)
line13 = compile_line(l; src=1, dst=3, pilineâ‚ŠR=0.01)
line23 = compile_line(l; src=2, dst=3, pilineâ‚ŠR=0.01)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EdgeModel <span class="sgr1">:line</span> <span class="sgr94">PureFeedForward()</span> @ Edge 2=&gt;3
 â”œâ”€ 2/2 inputs:  src=[srcâ‚Šu_r, srcâ‚Šu_i] dst=[dstâ‚Šu_r, dstâ‚Šu_i]
 â”œâ”€   0 states:  []  
 â”œâ”€ 2/2 outputs: src=[srcâ‚Ši_r, srcâ‚Ši_i] dst=[dstâ‚Ši_r, dstâ‚Ši_i]
 â””â”€   9 params:  [pilineâ‚ŠR=0.01, pilineâ‚ŠX=0.1, pilineâ‚ŠG_src=0, pilineâ‚ŠB_src=0, pilineâ‚ŠG_dst=0, pilineâ‚ŠB_dst=0, pilineâ‚Šr_src=1, pilineâ‚Šr_dst=1, pilineâ‚Šactive=1]</code></pre><p>Now we&#39;re all set for the next stage.</p><h2 id="Stage-II:-Initialization"><a class="docs-heading-anchor" href="#Stage-II:-Initialization">Stage II: Initialization</a><a id="Stage-II:-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-II:-Initialization" title="Permalink"></a></h2><p>When simulating power systems (or any large dynamical system for that matter), it is quite typical to start from a steady state/equilibrium point. In general, it is not trivial to find such a point for a large nonlinear system. In power systems specifically, it is common to solve a simpler system first â€“ the so-called &quot;power flow&quot; problem.</p><p>In the power flow problem, we neglect all the node dynamics and consider only 4 variables at each bus:</p><ul><li>the active power <span>$P$</span>,</li><li>the reactive power <span>$Q$</span>,</li><li>the voltage magnitude <span>$V$</span> and</li><li>the voltage angle <span>$\theta$</span>.</li></ul><p>In the simplest power flow, each bus can then be classified into one of three types:</p><ul><li><strong>Slack Bus</strong>: The voltage magnitude and angle are fixed (typically used for one bus in the system), <span>$P$</span> and <span>$Q$</span> is considered free.</li><li><strong>PV Bus</strong> <span>$P$</span> and <span>$V$</span> are fixed, <span>$Q$</span> and <span>$\theta$</span> are free. Often used for generator buses or any buses with active voltage control.</li><li><strong>PQ Bus</strong> <span>$P$</span> and <span>$Q$</span> are fixed, <span>$V$</span> and <span>$\theta$</span> are free. Typically used for load buses.</li></ul><p>So each component essentially introduces two algebraic equations and two free variables â€“ the system is then solved for the free variables such that all equations are satisfied.</p><h3 id="Attaching-Power-Flow-Models"><a class="docs-heading-anchor" href="#Attaching-Power-Flow-Models">Attaching Power Flow Models</a><a id="Attaching-Power-Flow-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Attaching-Power-Flow-Models" title="Permalink"></a></h3><p>In PowerDynamics.jl, we can attach the power flow models to the dynamic bus models using the <a href="../../API/#PowerDynamics.set_pfmodel!"><code>set_pfmodel!</code></a> function.</p><pre><code class="language-julia hljs">set_pfmodel!(bus1, pfSlack(V=1))
set_pfmodel!(bus2, pfPQ(P=-0.4, Q=-0.3))
set_pfmodel!(bus3, pfPQ(P=-0.6, Q=-0.2))</code></pre><h3 id="Building-the-Network"><a class="docs-heading-anchor" href="#Building-the-Network">Building the Network</a><a id="Building-the-Network-1"></a><a class="docs-heading-anchor-permalink" href="#Building-the-Network" title="Permalink"></a></h3><p>Now we can build the network using the <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.Network"><code>Network</code></a> constructor from NetworkDynamics.jl This constructor takes a list of VertexModels (the buses) and a list of EdgeModels (the powerlines) and connects them to a network. In general, we also need to define the topology of the undelying graph. In this case however, this is not necessary because we told each component at the compile step where it is placed in the network (see the <code>vidx</code>, <code>src</code> and <code>dst</code> arguments above)</p><pre><code class="language-julia hljs">nw = Network([bus1, bus2, bus3], [line12, line13, line23])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Network with 7 states and 39 parameters
 â”œâ”€ 3 vertices (2 unique types)
 â””â”€ 3 edges (1 unique type)
Edge-Aggregation using SequentialAggregator(+)</code></pre><p>The Network object tells us that we&#39;ve just defined a system with 7 States and 39 parameters. We have 3 vertices of 2 unique types (the inverter bus and the load bus) and 3 edges of a single unique type (all power lines are the same pi-line type).</p><p>The &quot;states&quot; and &quot;parameters&quot; already hint at a very important property of PowerDynamics/NetworkDynamics: in the end, the whole network is just a big DAE system of the form</p><p class="math-container">\[\mathbf{M}\,\dot{\mathbf{x}} = f(\mathbf{x}, \mathbf{p}, t)\]</p><p>where <span>$\mathbf{x}$</span> are the states and <span>$\mathbf{p}$</span> the parameters. This is very important to keep in mind, because it allows us to integrate seamlessly with the whole SciML ecosystem and, most importantly, <a href="https://diffeq.sciml.ai/stable/">DifferentialEquations.jl</a>.</p><p>The 7 states are essentially just the states of our models stacked on top of eachother. Look at the representation of our Vertex and EdgeModels above to see their contribution:</p><ul><li>Bus 1: 3 states, 8 parameters</li><li>Bus 2 &amp; 3: 2 states, 2 parameters each</li><li>Lines 1,2 and 3: 0 states, 9 parameters each</li></ul><p>In sum, we get the 7 states and 39 parameters.</p><div class="admonition is-success" id="Advanced:-State-and-Parameter-Ordering-d3470527567a9c60"><header class="admonition-header">Advanced: State and Parameter Ordering<a class="admonition-anchor" href="#Advanced:-State-and-Parameter-Ordering-d3470527567a9c60" title="Permalink"></a></header><div class="admonition-body"><p>Even though the states and parameters are essential &quot;just stacked&quot; on top of eachother, the ordering is not trivial due to performance reasons. Never rely on the ordering of states or parameters in the full system! PowerDynamics and NetworkDynamics provides lots of helper functions for so-called &quot;SymbolicIndexing&quot; to circumvent this.</p></div></div><h3 id="Initializing-the-System-via-Power-Flow"><a class="docs-heading-anchor" href="#Initializing-the-System-via-Power-Flow">Initializing the System via Power Flow</a><a id="Initializing-the-System-via-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Initializing-the-System-via-Power-Flow" title="Permalink"></a></h3><p>With the network constructed, we can finally find our equilibrium point. We do so using <a href="../../API/#PowerDynamics.initialize_from_pf"><code>initialize_from_pf</code></a>:</p><pre><code class="language-julia hljs">s0 = initialize_from_pf(nw; verbose=true, subverbose=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Initializing vertex 1...
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization problem is fully constrained. Created NonlinearLeastSquaresProblem for [:droopâ‚ŠÎ´, :droopâ‚ŠQfilt, :droopâ‚ŠPfilt, :droopâ‚ŠPset, :droopâ‚ŠQset]
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization successful with residual 6.126462320543899e-17

Initializing vertex 2...
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization problem is overconstrained (2 vars for 4 equations). Create NonlinearLeastSquaresProblem for [:loadâ‚ŠB, :loadâ‚ŠG].
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization successful with residual 1.7399681585579255e-13

Initializing vertex 3...
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization problem is overconstrained (2 vars for 4 equations). Create NonlinearLeastSquaresProblem for [:loadâ‚ŠB, :loadâ‚ŠG].
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Initialization successful with residual 4.85722573273506e-17

Initializing edge 1...
<span class="sgr36"><span class="sgr1">[ Info: </span></span>No free variables! Residual 0.0

Initializing edge 2...
<span class="sgr36"><span class="sgr1">[ Info: </span></span>No free variables! Residual 0.0

Initializing edge 3...
<span class="sgr36"><span class="sgr1">[ Info: </span></span>No free variables! Residual 0.0

Initialized network with residual 1.7402763534895576e-13!</code></pre><p>This function actually does quite a lot.</p><ol><li>It extracts the powerflow model for each component constructing the powerflow problem.</li><li>It solves the powerflow problem.</li><li>From the solution, we know the voltages and powers at each bus. Consequently, we also know the currents at each bus. This means we can directly &quot;map&quot; the powerflow solution to the inputs and outputs of each dynamic model.</li><li>For each dynamic model, we &quot;fix&quot; the inputs and outputs and try to find values for the states (and potentially parameters) such that the component model is in equilibrium. This is done using a nonlinear solver.</li></ol><p>In the log statements, we see which variables/parameters were considered free during the initialization of each component. This behavior can be fine-tuned in a lot of ways, which are beyond the scope of this tutorial. However, here we see that, for example, the complex parameter <span>$Y = B + j\,G$</span> of the constant Y-load was initially left free but then initialized from the powerflow solution. This means that <span>$Y$</span> is now set in a way that it draws the correct amount of power at the given voltage.</p><p>Similarly, we see that the inverter bus had the parameters <span>$P_{set}$</span> and <span>$Q_{set}$</span> free, which were also initialized from the powerflow solution. This is important, because we need to achieve power balance in the system, and due to the losses in the lines it&#39;s not possible to know the exact power injections a priori.</p><p>The return value of the <code>initialize_from_pf</code> function is a so-called <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.NWState"><code>NWState</code></a> object, which wraps flat <span>$x$</span> and <span>$p$</span> vectors and provides a lot of helper functions to access and modify states (including observables) and parameters.</p><p>Lets inspect this object further:</p><pre><code class="language-julia hljs">s0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NWState{Vector{Float64}} of Network (3 vertices, 3 edges)
  â”œâ”€ VIndex(1, :droopâ‚ŠÎ´)     =&gt; -6.126462320543899e-17
  â”œâ”€ VIndex(1, :droopâ‚ŠQfilt) =&gt; 0.567646497521268
  â”œâ”€ VIndex(1, :droopâ‚ŠPfilt) =&gt; 1.0067646497521268
  â”œâ”€ VIndex(2, :busbarâ‚Šu_r)  =&gt; 0.9654281128037676
  â”œâ”€ VIndex(2, :busbarâ‚Šu_i)  =&gt; -0.04388282011689339
  â”œâ”€ VIndex(3, :busbarâ‚Šu_r)  =&gt; 0.9677395909465843
  â””â”€ VIndex(3, :busbarâ‚Šu_i)  =&gt; -0.051117179883106614<span class="sgr90">
 p = NWParameter([1.00676, 0.567646, 1.0, 1.0, 1.0, 0.1, 1.0, 1.0, -0.321207, 0.428276  â€¦  1.0, 0.01, 0.1, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0])
 t = nothing</span></code></pre><p>At the highest level, we see the values of the 7 states in the network and their symbolic indices. Those indices can be used to access values directly:</p><pre><code class="language-julia hljs">s0[VIndex(1, :droopâ‚ŠPfilt)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0067646497521268</code></pre><div class="admonition is-success" id="Tip-8ccf0184b9217c72"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-8ccf0184b9217c72" title="Permalink"></a></header><div class="admonition-body"><p>In most julia dev environments you can type <code>\_+&lt;TAB&gt;</code> to autocomplete the MTK namespace separator <code>â‚Š</code>.</p></div></div><p>Often, you want to access observables or parameters instead of states. There is a whole filtering and access mechanism you can use for that. For example, in PD.jl, each bus has the states <code>:busbarâ‚ŠP</code> and <code>:busbarâ‚ŠQ</code>. We can inspect them on all vertices using:</p><pre><code class="language-julia hljs">s0.v(:, [:busbarâ‚ŠP, :busbarâ‚ŠQ])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FilteringProxy</span> for NWState()
  Component filter: VIndex(Colon())
  State filter:     [:busbarâ‚ŠP, :busbarâ‚ŠQ]
  Types:<span class="sgr92"><span class="sgr1">  states âœ“</span></span><span class="sgr1"><span class="sgr93">  parameters âœ“</span><span class="sgr95">  inputs âœ“</span><span class="sgr94">  outputs âœ“</span><span class="sgr96">  observables âœ“</span></span>
<span class="sgr1">Matching Indices:</span>
  â•­ VIndex(1, <span class="sgr96">:busbarâ‚ŠP</span>)   1.0067646  :bus
  â•° VIndex(1, <span class="sgr96">:busbarâ‚ŠQ</span>)   0.5676465  
  â•­ VIndex(2, <span class="sgr96">:busbarâ‚ŠP</span>)  -0.4        :loadbus
  â•° VIndex(2, <span class="sgr96">:busbarâ‚ŠQ</span>)  -0.3        
  â•­ VIndex(3, <span class="sgr96">:busbarâ‚ŠP</span>)  -0.6        :loadbus
  â•° VIndex(3, <span class="sgr96">:busbarâ‚ŠQ</span>)  -0.2        </code></pre><p>In the output, we clearly see how the load buses draw exactly the amount of power we specified in the power flow models. On the inverter bus, however, we inject slightly more power than the loads demand to compensate for the line losses.</p><p>Similarly, we can access all node parameters at initial state using</p><pre><code class="language-julia hljs">s0.v.p</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FilteringProxy</span> for NWState()
  Component filter: AllVertices()<span class="sgr90"> &lt;- filter further by obj[1], obj[&quot;name&quot;], ...</span>
  State filter:     <span class="sgr90">none</span>
  Types:<span class="sgr90">  states âœ—</span><span class="sgr93"><span class="sgr1">  parameters âœ“</span></span><span class="sgr90">  inputs âœ—  outputs âœ—  observables âœ—</span>
<span class="sgr1">Matching Indices:</span>
  â•­ VIndex(1, <span class="sgr93">:droopâ‚ŠPset</span>)   1.0067646   :bus
  â”‚ VIndex(1, <span class="sgr93">:droopâ‚ŠQset</span>)   0.5676465   
  â”‚ VIndex(1, <span class="sgr93">:droopâ‚ŠVset</span>)   1           
  â”‚ VIndex(1, <span class="sgr93">:droopâ‚ŠÏ‰â‚€</span>)     1           
  â”‚ VIndex(1, <span class="sgr93">:droopâ‚ŠKp</span>)     1           
  â”‚ VIndex(1, <span class="sgr93">:droopâ‚ŠKq</span>)     0.1         
  â”‚ VIndex(1, <span class="sgr93">:droopâ‚ŠÏ„_p</span>)    1           
  â•° VIndex(1, <span class="sgr93">:droopâ‚ŠÏ„_q</span>)    1           
  â•­ VIndex(2, <span class="sgr93">:loadâ‚ŠB</span>)      -0.321207    :loadbus
  â•° VIndex(2, <span class="sgr93">:loadâ‚ŠG</span>)       0.42827601  
  â•­ VIndex(3, <span class="sgr93">:loadâ‚ŠB</span>)      -0.21296241  :loadbus
  â•° VIndex(3, <span class="sgr93">:loadâ‚ŠG</span>)       0.63888722  </code></pre><p>Here we see how <span>$P_{set}$</span> and <span>$Q_{set}$</span> of the inverter were initialized in a way, that they match the powerflow solution.</p><p>There is a lot more functionality in the <code>NWState</code> objects, see the <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/symbolic_indexing/#Symbolic-Indexing">Symbolic Indexing docs of ND.jl</a> and especially the <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#NetworkDynamics.FilteringProxy"><code>FilteringProxy</code></a> for more details.</p><h2 id="Stage-III:-Time-Domain-Simulation"><a class="docs-heading-anchor" href="#Stage-III:-Time-Domain-Simulation">Stage III: Time Domain Simulation</a><a id="Stage-III:-Time-Domain-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-III:-Time-Domain-Simulation" title="Permalink"></a></h2><p>With the initialized state, we can finally simulate the system in time domain.</p><h3 id="Perturbing-the-System"><a class="docs-heading-anchor" href="#Perturbing-the-System">Perturbing the System</a><a id="Perturbing-the-System-1"></a><a class="docs-heading-anchor-permalink" href="#Perturbing-the-System" title="Permalink"></a></h3><p>Since we start from an equilibrium point, we expect the system to stay there if we don&#39;t perturb it. Therefore, to get interesting results, we need to perturb the system.</p><p>The simplest way to perturb the system is to change a parameter. For example, let&#39;s increase the admittance at bus 2 by 10% after 0.1 seconds.</p><p>For that, we define a so-called &quot;callback function&quot;, more specifically a preset time callback, which is triggered at a specific simulation time and modifies the parameters. The simulation then continues. General information on callbacks in Differential Equations can be found in the <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/#callbacks">DiffEq.jl docs</a>. Specific extensions for NetworkDynamics.jl can be found in the <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/callbacks/#Callbacks">NetworkDynamics.jl callback docs</a>.</p><p>We define the callback and attach it to bus 2 (our first load) like this:</p><pre><code class="language-julia hljs">affect = ComponentAffect([], [:loadâ‚ŠG, :loadâ‚ŠB]) do u, p, ctx
    @info &quot;Increase load admittance Y by 10% at t=$(ctx.t)&quot;
    p[:loadâ‚ŠG] = p[:loadâ‚ŠG] * 1.1
    p[:loadâ‚ŠB] = p[:loadâ‚ŠB] * 1.1
end
cb = PresetTimeComponentCallback(0.1, affect)
set_callback!(bus2, cb)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:loadbus</span> <span class="sgr94">PureStateMap()</span> @ Vertex 2
 â”œâ”€ 2 inputs:   [busbarâ‚Ši_r, busbarâ‚Ši_i]
 â”œâ”€ 2 states:   [busbarâ‚Šu_r=1, busbarâ‚Šu_i=0]
 |    with diagonal mass matrix [0, 0]
 â”œâ”€ 2 outputs:  [busbarâ‚Šu_r=1, busbarâ‚Šu_i=0]
 â”œâ”€ 2 params:   [loadâ‚ŠB<span class="sgr90">â‰ˆ1</span>, loadâ‚ŠG<span class="sgr90">â‰ˆ1</span>]
 â””â”€ 1 callback: (:loadâ‚ŠG, :loadâ‚ŠB) affected at t=0.1
<span class="sgr34"><span class="sgr1">Powerflow model </span></span>:pqbus with [pqâ‚ŠP=-0.4, pqâ‚ŠQ=-0.3]</code></pre><p>With the callback defined, we can finally create and solve the <a href="https://juliadynamics.github.io/NetworkDynamics.jl/stable/API/#SciMLBase.ODEProblem-Tuple%7BNetwork%2C%20NWState%2C%20Any%7D"><code>ODEProblem</code></a>:</p><pre><code class="language-julia hljs">prob = ODEProblem(nw, s0, (0.0, 5.0))
sol = solve(prob, Rodas5P());</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Increase load admittance Y by 10% at t=0.1</code></pre><h2 id="Stage-IV:-Postprocessing-and-Visualization"><a class="docs-heading-anchor" href="#Stage-IV:-Postprocessing-and-Visualization">Stage IV: Postprocessing and Visualization</a><a id="Stage-IV:-Postprocessing-and-Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-IV:-Postprocessing-and-Visualization" title="Permalink"></a></h2><p>Once we have the solution object, we can use it like any other solution from DifferentialEquations.jl. Most importantly, we can use symbolic indices to access states, parameters and observables.</p><h3 id="Plotting-Results"><a class="docs-heading-anchor" href="#Plotting-Results">Plotting Results</a><a id="Plotting-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-Results" title="Permalink"></a></h3><p>For example, we can quickly plot the frequency response of the droop using</p><pre><code class="language-julia hljs">lines(sol, idxs=VIndex(1, :droopâ‚ŠÏ‰); axis=(;xlabel=&quot;Time [s]&quot;, ylabel=&quot;Frequency Ï‰ [pu]&quot;))</code></pre><img src="2957ec93.png" alt="Example block output"/><p>We clearly see how the increased active power leads to a drop in frequency. This drop is then compensated by the droop control (i.e., we stabilize at a lower frequency).</p><p>Of course, we can also create more complex plots, such as this one showing the active and reactive power at each bus:</p><pre><code class="language-julia hljs">let
    fig = Figure(size=(1000,600))
    ax = Axis(fig[1, 1]; xlabel=&quot;Time [s]&quot;, ylabel=&quot;Active Power Load [pu]&quot;)
    for i in 2:3
        lines!(ax, sol, idxs=VIndex(i, :busbarâ‚ŠP), color=Cycled(i))
    end
    axislegend(ax)
    ax = Axis(fig[1,2]; xlabel=&quot;Time [s]&quot;, ylabel=&quot;Reactive Power Load [pu]&quot;)
    for i in 2:3
        lines!(ax, sol, idxs=VIndex(i, :busbarâ‚ŠQ), color=Cycled(i))
    end
    axislegend(ax)
    ax = Axis(fig[2,1]; xlabel=&quot;Time [s]&quot;, ylabel=&quot;Active Power Injection [pu]&quot;)
    lines!(ax, sol, idxs=VIndex(1, :busbarâ‚ŠP))
    axislegend(ax)
    ax = Axis(fig[2,2]; xlabel=&quot;Time [s]&quot;, ylabel=&quot;Reactive Power Injection [pu]&quot;)
    lines!(ax, sol, idxs=VIndex(1, :busbarâ‚ŠQ))
    axislegend(ax)
    fig
end</code></pre><img src="5271c12a.png" alt="Example block output"/><p>Here we see that the active and reactive power demand shoots up in the beginning after we increase Y. The power demand then slowly decreases again. This is probably due to a drop in voltage, which leads to lower power demand on constant Y loads.</p><p>Let&#39;s plot the voltage to verify this:</p><pre><code class="language-julia hljs">let
    fig = Figure()
    ax = Axis(fig[1, 1]; xlabel=&quot;Time [s]&quot;, ylabel=&quot;Voltage [pu]&quot;)
    for i in 1:3
        lines!(ax, sol, idxs=VIndex(i, :busbarâ‚Šu_mag), color=Cycled(i))
    end
    axislegend(ax; position=:rc)
    fig
end</code></pre><img src="7cf77c14.png" alt="Example block output"/><h3 id="Programmatic-Access-to-Variables"><a class="docs-heading-anchor" href="#Programmatic-Access-to-Variables">Programmatic Access to Variables</a><a id="Programmatic-Access-to-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Programmatic-Access-to-Variables" title="Permalink"></a></h3><p>Instead of plotting, we can also always use the solution interpolation to access values programmatically. For example</p><pre><code class="language-julia hljs">sol(1.0, idxs=VIndex(1,:droopâ‚ŠÏ‰))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9796177657887593</code></pre><p>gives us the frequency of the droop inverter at time t=1.0s.</p><p>Similarly, we can extract time series by passing a vector of time points rather than a single point:</p><pre><code class="language-julia hljs">sol([0.1,0.2,0.3], idxs=VIndex(1:3, :busbarâ‚Šu_mag))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">t: 3-element Vector{Float64}:
 0.1
 0.2
 0.3
u: 3-element Vector{Vector{Float64}}:
 [1.0000000000000007, 0.9664249287416306, 0.9690886863258026]
 [0.9996829425894866, 0.963758247336889, 0.9675903419318874]
 [0.9993994847401563, 0.963484975411273, 0.9673159834227099]</code></pre><p>This code gives us the voltage magnitude at all three buses at the time points 0.1s, 0.2s, and 0.3s.</p><p>To deeply inspect a single point, we can also construct a <code>NWState</code> object from the solution for a specific time:</p><pre><code class="language-julia hljs">s095 = NWState(sol, 0.95)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NWState{Vector{Float64}} of Network (3 vertices, 3 edges)
  â”œâ”€ VIndex(1, :droopâ‚ŠÎ´)     =&gt; -0.009782234715488626
  â”œâ”€ VIndex(1, :droopâ‚ŠQfilt) =&gt; 0.5860197401082406
  â”œâ”€ VIndex(1, :droopâ‚ŠPfilt) =&gt; 1.0264978211890774
  â”œâ”€ VIndex(2, :busbarâ‚Šu_r)  =&gt; 0.9606923355541416
  â”œâ”€ VIndex(2, :busbarâ‚Šu_i)  =&gt; -0.05547322393118105
  â”œâ”€ VIndex(3, :busbarâ‚Šu_r)  =&gt; 0.9641569090056149
  â””â”€ VIndex(3, :busbarâ‚Šu_i)  =&gt; -0.06153953104316798<span class="sgr90">
 p = NWParameter([1.00676, 0.567646, 1.0, 1.0, 1.0, 0.1, 1.0, 1.0, -0.353328, 0.471104  â€¦  1.0, 0.01, 0.1, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0])
 t = 0.95</span></code></pre><p>gives us the state at t=0.95s. We can use the state object for inspection as we did before. For example, we can inspect the power at the destination end of all lines at this point in time:</p><pre><code class="language-julia hljs">s095.e(:, :dstâ‚ŠP)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FilteringProxy</span> for NWState()
  Component filter: EIndex(Colon())
  State filter:     :dstâ‚ŠP
  Types:<span class="sgr92"><span class="sgr1">  states âœ“</span></span><span class="sgr1"><span class="sgr93">  parameters âœ“</span><span class="sgr95">  inputs âœ“</span><span class="sgr94">  outputs âœ“</span><span class="sgr96">  observables âœ“</span></span>
<span class="sgr1">Matching Indices:</span>
  â— EIndex(1, <span class="sgr96">:dstâ‚ŠP</span>)   0.48841531  :line
  â— EIndex(2, <span class="sgr96">:dstâ‚ŠP</span>)   0.54420649  :line
  â— EIndex(3, <span class="sgr96">:dstâ‚ŠP</span>)   0.05212171  :line</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">Â« Getting Started</a><a class="docs-footer-nextpage" href="../custom_bus/">Custom Generator Bus Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 7 November 2025 02:41">Friday 7 November 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
