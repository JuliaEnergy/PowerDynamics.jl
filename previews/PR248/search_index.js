var documenterSearchIndex = {"docs":
[{"location":"networkdynamics_forward/","page":"ğŸ”— NetworkDynamics.jl Docs","title":"ğŸ”— NetworkDynamics.jl Docs","text":"    <meta http-equiv=\"refresh\" content=\"0; url=https://juliadynamics.github.io/NetworkDynamics.jl/stable/\">\n    <script type=\"text/javascript\">\n        window.location.href = \"https://juliadynamics.github.io/NetworkDynamics.jl/stable/\"\n    </script>\n    If you are not redirected automatically, follow this <a href='https://juliadynamics.github.io/NetworkDynamics.jl/stable/'>link to the documentation of NetworkDynamics.jl</a>.","category":"section"},{"location":"generated/getting_started/#getting-started","page":"Getting Started","title":"Getting Started with PowerDynamics.jl","text":"This tutorial introduces the core ideas behind PowerDynamics.jl and its relationship to the SciML ecosystem.\n\nThis tutorial can be downloaded as a normal Julia script here.\n\nPowerDynamics.jl is a tool for modeling and simulating dynamic powergrid models. Its main idea is to build equation-based, symbolic models for various dynamic components. Different components, such as shunts, generators or controllers are then connected to form dynamic models representing entire Buses or Lines. The dynamic Bus and Line models are then interconnected to form powergrids.\n\nThe most important distinction in contrast to other tools is that PowerDynamics.jl is a modeling framework rather than a simulation tool. At its core, a dynamic powergrid model is just a set of differential-algebraic equations (DAEs) that describe the evolution of the system over time. PowerDynamics.jl helps you to build these DAE models in a modular way, and then simulate them using the powerful solvers from the SciML ecosystem.\n\nPowerDynamics.jl gives you direct access to the underlying DAE structure and purposely exposes you to the \"raw\" commands from the SciML Ecosystem, most importantly DifferentialEquations.jl. While this can be a bit overwhelming at first, it really pays off to learn the API of the underlying packages directly rather than wrapping them all up in a PowerDynamics-specific API.\n\nThis tight integration means, that it is much easier to transfer advanced SciML methods and concepts to systems defined with PowerDynamics.jl.\n\nIn this tutorial, we will model the same physical system, a Single-Machine-Infinite-Bus (SMIB), in two different ways. First, we'll build it as a \"plain\" ModelingToolkit model using pure SciML packages. Then, we'll model the same system using PowerDynamics' component-based approach. This side-by-side comparison highlights the parallels in nomenclature and workflow between the two approaches.\n\nThe workflow for both approaches looks like this:\n\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Pure MTK Model         â”‚ â”‚ PowerDynamics.jl Model     â”‚\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡\nâ”‚ Equation-based model   â”‚ â”‚ Composite Model consisting â”‚\nâ”‚ of the entire system.  â”‚ â”‚ of equation-based MTK      â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â•¯ â”‚ models for Buses and Lines â”‚\n                      â”‚    â”‚         â•­â”€â”€â”€â”€â”€â”€â”€â•®          â”‚\n                      â”‚    â”‚     2 â”¯â”â”¿       â”¿â”â”¯ 3      â”‚\n                      â”‚    â”‚       â†“ â”‚   â•­â”€â”€â”€â•¯ â†“        â”‚\n                      â”‚    â”‚         â”·â”â”¯â”â”· 1            â”‚\n                      â”‚    â”‚          (~)               â”‚\n                      â”‚    â•°â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n  ModelingToolkit.jl  â”‚           â”‚  PowerDynamics.jl\n           generates  â–¾           â–¾  generates\n                  â•­â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â•®\n                  â”‚ DAE System        â”‚\n                  â”‚ M Ì‡x = f(x, p, t)  â”‚\n                  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nRHS function + Mass Matrix  â–¾\n      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n      â”‚ SciML-ODEProblem                          â”‚\n      â”‚ Data structure for time-domain simulation â”‚\n      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n  OrdinaryDiffEq.jl solver  â–¾\n     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n     â”‚ SciML-ODESolution                           â”‚\n     â”‚ Solution object containing the time series  â”‚\n     â”‚ for all components                          â”‚\n     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n         Symbolic Indexing  â–¾\n â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\n â”‚ Time-series Inspection                              â”‚\n â”‚ Symbolic indexing allows for easy access to all     â”‚\n â”‚ states of all subcomponents for detailed analysis.  â”‚\n â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\ninfo: Short description of used Packages and their relation\nTop-level Packages:PowerDynamics.jl: The main package for building powergrid models. It provides a library and modeling tools specific to power systems, such as powerflow models and component libraries.\nNetworkDynamics.jl: Our backend package that provides most of the core functionality. It is general-purpose and can model any kind of networked dynamical system.SciML Packages:ModelingToolkit.jl (MTK): A symbolic modeling framework for defining and manipulating differential equations. The key word here is symbolically â€“ you write equations, not numerical code. MTK automatically performs simplifications and generates efficient numerical code for simulation.\nDifferentialEquations.jl: Umbrella package for everything related to differential equations, including stochastic and delay differential equations. Since it's large, we typically import specific subpackages, i.e.:\nOrdinaryDiffEq.jl: Solvers for ordinary differential equations (ODEs and DAEs). You can reduce load time even further by only importing specific solver packages like OrdinaryDiffEqRosenbrock.jl or OrdinaryDiffEqTsit5.jl.\nNonlinearSolve.jl: Solvers for nonlinear systems of equations, used for powerflow calculations and DAE initialization.Other Packages:Makie.jl: A powerful plotting package for visualizing results with its backends CairoMakie.jl for vector graphic output and GLMakie.jl/WGLMakie.jl for interactive visualizations.","category":"section"},{"location":"generated/getting_started/#Simple-ModelingToolkit-System","page":"Getting Started","title":"Simple ModelingToolkit System","text":"In this section we'll model the simplest Single-Machine-Infinite-Bus System (SMIB): a Swing equation connected to a slack bus.\n\n                    Ï‰,Î¸\n                     â¤º\nTurbine Power  Pâ‚˜  ğŸ­ƒâ–„â–„â–„ğŸ­  Pâ‚‘  Electrical Power\n               â”€â†’  ğŸ­”â–€â–€â–€ğŸ­Ÿ  â”€â†’\n                     H\n\n\nThe equations of the rotor connected to the infinite bus can be written as:\n\nbeginaligned\ndottheta = omega\nMdotomega = P_mathrmm - P_mathrme - DomegatextSwing Equation with\nP_mathrme = frac1Xsinthetatextconnection to infinite bus with Î´=0\nendaligned\n\nwhere M is the inertia, omega_s is the synchronous speed, P_m is the mechanical power input, and P_e is the electrical power output. The state is described by the rotor angle theta and the angular velocity omega (deviation from synchronous speed). The ideal rotor is connected to a slack bus via a lossless transmission line with reactance X.\n\nTo simulate this system, we first need to import some packages...\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as Dt\nusing OrdinaryDiffEqRosenbrock\nusing CairoMakie\nnothing #hide","category":"section"},{"location":"generated/getting_started/#MTK:-Model-Definition-and-Simulation","page":"Getting Started","title":"MTK: Model Definition & Simulation","text":"tip: Unicode Symbols\nJulia allows you to use unicode characters in variable names. In most Julia development environments you can insert them with LaTeX-like syntax: \\alpha<TAB> â‡’ Î±, \\_e<TAB> â‡’ â‚‘ and \\_+ â‡’ â‚Š. Especially â‚Š is important as it is used as a separator in MTK.\n\nAfter importing the packages, we can define the symbolic system using the @mtkmodel macro:\n\n@mtkmodel SwingInfiniteBus begin\n    @parameters begin\n        M  = 1   # machine inertia\n        D  = 1   # machine damping\n        Pâ‚˜ = 1   # mechanical power\n        X  = 0.1 # reactance of powerline\n    end\n    @variables begin\n        Î¸(t)  # rotor angle\n        Ï‰(t)  # angular velocity (rel to sync. speed)\n        Pâ‚‘(t) # electrical power (connection to IB)\n    end\n    @equations begin\n        Pâ‚‘ ~ 1/X * sin(Î¸)\n        Dt(Î¸) ~ Ï‰\n        M * Dt(Ï‰) ~ Pâ‚˜ - Pâ‚‘ - D*Ï‰\n    end\nend\nnothing #hide\n\nThe definition of the system is quite straightforward. Note how we defined 3 states, including one for the electrical power P_mathrme. We can instantiate the system by calling its constructor SwingInfiniteBus():\n\n@named symbolic_system = SwingInfiniteBus()\nfull_equations(symbolic_system) # show all equations\n\nIn order to simulate the system, we need to call mtkcompile, which will essentially perform a symbolic simplification of the system:\n\ncompiled_system = mtkcompile(symbolic_system)\nfull_equations(compiled_system) # show all equations\n\nYou can see that the \"compiled\" system only consists of two states, theta and omega. This is because P_mathrme is not really a state of the system, but rather an intermediate variable, so it was thrown out. While trivial in this case, this is the symbolic simplification at work.\n\nTo simulate the system, we need to define initial conditions for the states theta and omega. Also, we need to define a time span for the simulation.\n\nu0 = [\n    compiled_system.Î¸ => 0.0,\n    compiled_system.Ï‰ => 0.0,\n]\ntspan = (0.0, 10.0)\nnothing #hide\n\nCombining the compiled system, initial conditions, and time span, we can define a so-called ODEProblem.\n\nprob = ODEProblem(compiled_system, u0, tspan)\n\nThe ODEProblem contains all the information needed to simulate the system. We can simulate the system using any of the solvers from OrdinaryDiffEq.jl. In this case, we decided to use the Rodas5P solver from OrdinaryDiffEqRosenbrock.jl.\n\nsol = solve(prob, Rodas5P())\nnothing #hide","category":"section"},{"location":"generated/getting_started/#MTK:-Solution-Handling","page":"Getting Started","title":"MTK: Solution Handling","text":"The solution object we get contains all the time series in the system. For low-level access, we can look at\n\nsol.t\n\nto get an array of all the points in time the solver stepped to. While\n\nsol.u\n\ngives the full state of the system for each of the time points.\n\nHowever, this is far from all we can do with the solution object! First off, since we use dense output by default, we can interpolate the solution at any point in time:\n\nsol(2.5) # interpolate at t=2.5s (better than linear interpolation)\n\nThe output, however, is still not very user friendly, since we only get a vector of values. This is where symbolic indexing comes to our help! Using the syntax\n\nsol(1.0, idxs=compiled_system.Î¸) # get Î¸ at t=1.0s\n\nwe can extract a specific state at a specific time point. This syntax has lots of variants; for example, we can efficiently interpolate multiple states at multiple time points:\n\nsol([0.0, 1.0], idxs=[compiled_system.Î¸, compiled_system.Ï‰]) # get Î¸ and Ï‰ at t=0.0s and t=1.0s\n\nSince ModelingToolkit keeps track of all of its simplifications, we can also extract so-called \"observed\" states, i.e., states that were part of the original symbolic system but got eliminated during compilation. For this example, we can get the electrical power P_mathrme at any time point even though it is not part of the solution itself:\n\nsol(0.5, idxs=compiled_system.Pâ‚‘) # get Pe at t=0.5s\n\nFinally, we can use the same symbolic indexing syntax in plotting commands. The example below uses Makie.jl; however, the commands are very similar in Plots.jl.\n\nlet\n    fig = Figure()\n    ax = Axis(fig[1,1], xlabel=\"Time (s)\", ylabel=\"States\")\n    lines!(sol, idxs=compiled_system.Î¸, color=:darkred)\n    lines!(sol, idxs=compiled_system.Ï‰, color=:darkblue)\n    lines!(sol, idxs=compiled_system.Pâ‚‘, color=:darkgreen)\n    axislegend(ax; position=:rt)\n    fig\nend","category":"section"},{"location":"generated/getting_started/#Simple-PowerDynamics-System","page":"Getting Started","title":"Simple PowerDynamics System","text":"Now, we're going to model the same physical system but this time using the component based approach of PowerDynamics.jl\n\nThis means, we'll define two buses with a pi-line (zero shunts) connecting them.\n\n        bus 1          bus 2\n          â•»              â•»\n  (â•)â•¶â”€â”€â”€â”€â•‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•‚â”€â”€â”€â•´(~)\nswing-eqs â•¹   pi-line    â•¹ slack/infinite bus\n\nFirst, we need to load the PowerDynamics.jl package:\n\nusing PowerDynamics\nusing PowerDynamics: Library\n\nWe start by loading a Swing model generator from the library.\n\n@named symbolic_swing = Library.Swing(V=1)\nfull_equations(symbolic_swing) # show all equations\n\nThe equations represent a classic swing equation with no voltage dynamics. We passed the keyword argument V=1 to set the voltage magnitude to 1 p.u. So far, this is a \"pure\" MTK model, similar to the symbolic_system from above. The equations are structurally identical to the ones we defined manually above only differing in some conventions.\n\nWe can then compile the model to get rid of intermediate variables and make it ready for simulation. We do so by calling compile_bus. The additional call to MTKBus can be ignored for now and is explained in further tutorials and the Modeling Concepts docs. Additionally, we give the bus model an index using the vidx keyword (short for vertex index).\n\nbus1 = compile_bus(MTKBus(symbolic_swing); vidx=1, name=:swing)\n\nThis object is a so-called VertexModel. VertexModels (and EdgeModels) are the building blocks of systems in PowerDynamics.jl and NetworkDynamics.jl. From the printout you can already see that it has different variables/parameters with some default values and so on.\n\nFor the second bus, we use a slack bus (also called infinite bus), which maintains constant voltage magnitude and angle:\n\n@named symbolic_slack = Library.VÎ´Constraint(; V=1, Î´=0)\nbus2 = compile_bus(MTKBus(symbolic_slack); vidx=2, name=:slack)\n\nThe VÎ´Constraint enforces V=1 p.u. and delta=0 at all times, which is the mathematical definition of a slack/infinite bus.\n\nAnd a powerline connecting the two:\n\n@named symbolic_piline = Library.PiLine()\nline = compile_line(MTKLine(symbolic_piline); src=1, dst=2)\n\nThe powerline got the src and dst keywords. This means our line is defined from bus 1 to bus 2.\n\nHaving defined all the components, we can now connect them to a network model.\n\nnw = Network([bus1, bus2], line)\n\nThe nw object is somewhat similar to the compiled_system from above: it is a fully defined DAE system (ODE system in this case) that can be simulated. Similar to the compiled_system, it not only contains the right-hand-side function but also contains information necessary for symbolic indexing, i.e., which component has which states/parameters under which names and so on.","category":"section"},{"location":"generated/getting_started/#PD:-Symbolic-Indexing","page":"Getting Started","title":"PD: Symbolic Indexing","text":"In contrast to the MTK example above, our symbolic indices are \"hierarchical\", i.e., we have to specify the component first and then the state/parameter name.\n\nVIndex objects are used to reference states/parameters of vertex-entities (buses, shunts, generators, loads, etc.),\n\nVIndex(  1,    :symbolic_swingâ‚ŠÏ‰)\nVIndex(:swing, :symbolic_swingâ‚ŠÎ¸)\n       â•¶â”€â”¬â”€â”€â•´  â•¶â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â•´\n         â•µ             â”‚\nIndex/name of vertex   â”‚\n                       â•µ\n         Name of parameter/state\n\nwhile EIndex objects are used to reference states/parameters of edge-entities (lines, transformers, etc.),\n\nEIndex(        1,             :srcâ‚ŠP       )\nEIndex(     :edge,            :srcâ‚ŠQ       )\nEIndex(     1 => 2,           :srcâ‚ŠQ       )\nEIndex(:swing => :slack, :symbolic_pilineâ‚ŠR)\n       â•¶â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â•´  â•¶â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â•´\n              â•µ                  â”‚\n Index/name or src-dst pair      â”‚\n                                 â•µ\n                      Name of parameter/state","category":"section"},{"location":"generated/getting_started/#PD:-Manual-Definition-of-Initial-Conditions","page":"Getting Started","title":"PD: Manual Definition of Initial Conditions","text":"For large systems with possibly thousands of states and parameters, finding a suitable initial state is a hard problem which is covered in depth in later tutorials.\n\nFor now, our system is quite simple and we can find a suitable initial state by hand. We can create a \"default\" state by calling NWState on the network object:\n\n@assert dim(nw) == 2 # hide\ns0 = NWState(nw)\n\nThis creates a state and parameter object, which is prefilled with all of the default values stored in the Network. The undefined states/parameters are set to NaN.\n\n!!! note Automatic State Reduction In the printout of s0 you see only two \"real\" states: omega and theta of the swing equation, everything else was simplified away, just like in the MTK example above.\n\nUsing the symbolic indexing syntax described above, we can now set the initial conditions for all states and parameters that are not already defined.\n\nSimilar to the example above, we start at 0 angle and a frequency of 1 p.u. (in contrast to the MTK example above, the swing model from the library is defined in terms of PU frequency not frequency deviation):\n\ns0[VIndex(1, :symbolic_swingâ‚ŠÎ¸)] = 0.0\ns0[VIndex(:swing, :symbolic_swingâ‚ŠÏ‰)] = 1 # alternatively, reference vertex by unique name\nnothing #hide\n\nInstead of using the symbolic indices explicitly, NWState supports a more user-friendly syntax for accessing states. We set the mechanical power input, the inertia, and the damping of the machine at bus 1:\n\ns0.v[1][:symbolic_swingâ‚ŠPm] =  1\ns0.v[1][:symbolic_swingâ‚ŠM] = 1\ns0.v[:swing][:symbolic_swingâ‚ŠD] = 1\nnothing #hide\n\nIt is important to understand that at its core, NWState objects are just \"wrappers\" around flat arrays. Similar to the pure-MTK example above, where our state vector u was just a vector of 2 plain values, the NWState object contains a flat vector of all states and a flat vector of all parameters. The flat vectors can be accessed using the uflat and pflat functions:\n\nuflat(s0)\n\npflat(s0)\n\nBy wrapping those flat vectors in a NWState object we make them \"human readable\" by providing symbolic indexing.\n\nThere are lots of things you can do with NWState objects. For example, once again it is possible to inspect \"observed\" statesâ€”states which are not actually part of the state vector but rather intermediate variables. For example, we can inspect the active power at both src and destination end.\n\ns0.e[1=>2]([:srcâ‚ŠP, :dstâ‚ŠP])\n\nUnsurprisingly, since we start at an angle of 0 with both slack and swing, there is no active power flow.","category":"section"},{"location":"generated/getting_started/#PD:-Simulation-of-the-System","page":"Getting Started","title":"PD: Simulation of the System","text":"Similar to before, we take our model and use it to define an ODEProblem. We can then solve it using the Rodas5P solver again.\n\nThe only notable difference here is, that we need to pass both flat vectors: states and parameters.\n\nprob = ODEProblem(nw, s0, (0.0, 10.0))\nsol = solve(prob, Rodas5P())\nnothing #hide","category":"section"},{"location":"generated/getting_started/#PD:-Solution-Handling","page":"Getting Started","title":"PD: Solution Handling","text":"The solution handling is analogous to the pure-MTK example above.\n\nsol(1.0, idxs=VIndex(1, :symbolic_swingâ‚ŠÎ¸)) # get Î¸ of bus 1 at t=1.0s\n\nFor generating lists of symbolic indices at once, NetworkDynamics.jl provides the auxiliary functions vidxs and eidxs:\n\nvidxs(nw, :, :busbarâ‚Šu_arg) # create lists of VIndex objects\n\nsol(1.0, idxs=vidxs(nw, :, :busbarâ‚Šu_arg)) # use vidxs get voltage angle of all buses at t=1.0s\n\ntip: Tip\nCertain electrical \"bus\" states, such as :busbarâ‚Šu_arg or :busbarâ‚Šu_mag, are available at every bus regardless of the models attached to that bus. The full list of avialable symbols can be checked interatively using s0.v[1]/s0.e[1=>2].\n\nSometimes, you want to get the full NWState at a specific time point.\n\ns10 = NWState(sol, 1.0) # get full NWState at t=1.0s\n\nwhich you can then inspect as before:\n\ns10.e[1=>2]([:srcâ‚ŠP, :dstâ‚ŠP]) # get active power at line 1=>2 at t=1.0s\n\nWe can do some plotting as before:\n\nlet\n    fig = Figure()\n    ax = Axis(fig[1,1], xlabel=\"Time (s)\", ylabel=\"Voltage Angles\")\n    lines!(sol, idxs=VIndex(1, :symbolic_swingâ‚ŠÎ¸), color=:darkred)\n    lines!(sol, idxs=VIndex(2, :busbarâ‚Šu_arg), color=:darkblue)\n    axislegend(ax; position=:rt)\n    ax = Axis(fig[2,1], xlabel=\"Time (s)\", ylabel=\"Frequency at Swing\")\n    lines!(sol, idxs=VIndex(1, :symbolic_swingâ‚ŠÏ‰), color=:darkred)\n    axislegend(ax; position=:rt)\n    ax = Axis(fig[3,1], xlabel=\"Time (s)\", ylabel=\"Active Power in Line\")\n    lines!(sol, idxs=EIndex(1=>2, :srcâ‚ŠP), color=:darkgreen, label=\"P injected towards bus 1\")\n    lines!(sol, idxs=EIndex(1=>2, :dstâ‚ŠP), color=:lightgreen, label=\"P injected towards bus 2\")\n    axislegend(ax; position=:rt)\n    fig\nend\n\nWe observe the expected behavior:\n\nas in the pure MTK example, the swing node accelerates and oscillates around until it settles at a new steady state, where the angle difference between bus 1 and the slack bus (with delta=0) leads to a power flow of P_mathrme = P_mathrmm = 1 p.u.\nin steady state, the active power injected at bus 1 is equal to the active power extracted at bus 2 (lossless line)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/custom_line/#custom-line","page":"Custom Transmission Line","title":"Tutorial on custom Transmission Line Models","text":"This tutorial can be downloaded as a normal Julia script here.\n\nIn this tutorial we'll implement a custom transmission line model:\n\nwe start by defining a PI-branch component with optional fault admittance,\nwe combine two PI-branch components into one MTKLine, to essentially model a dual-branch transmission line.\n\nTo make it more interesting, we add protection logic to the branches:\n\neach branch continuously checks the current magnitude against a limit,\nif the current exceeds the limit, the branch is switched off after a delay time.\n\nusing PowerDynamics\nusing ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\nusing NetworkDynamics\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\nusing Graphs","category":"section"},{"location":"generated/custom_line/#Basic-PI-Branch-Model","page":"Custom Transmission Line","title":"Basic PI-Branch Model","text":"We start by defining a basic PI-branch model, which is similar to the one in PiLine_fault.jl as an MTKModel. This model should fulfill the Branch Interface, i.e. it needs to have two Terminal, one called :src the other called :dst:\n\n      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n(src) â”‚           â”‚ (dst)\n  oâ†â”€â”€â”¤  Branch   â”œâ”€â”€â†’o\n      â”‚           â”‚\n      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe PI-branch we want to describe looks like this. We have:\n\ntwo terminals :src and :dst with their\nvoltages V_mathrmsrc and V_mathrmdst,\ncurrents i_mathrmsrc and i_mathrmdst,\ntwo shunt admittances Y_mathrmsrc and Y_mathrmdst,\nan impedance Z, which is split into two parts Z_a and Z_b by the fault position mathrmpos.\n\n              i_src  Vâ‚   i_a   Vâ‚˜   i_b   Vâ‚‚  i_dst\n     V_src oâ”€â”€â”€â”€â†â”€â”€â”€â”€oâ”€â”€â”€Z_aâ”€â†’â”€â”€oâ”€â”€â”€Z_bâ”€â†’â”€â”€oâ”€â”€â”€â”€â†’â”€â”€â”€â”€o V_dst\n              r_src  â”‚          â”‚          â”‚   r_dst\n                     â†“ iâ‚       â†“ i_f   iâ‚‚ â†“\n                     â”´          â”´          â”´\nY_src = G_src+jB_src â”¬          â”¬ Y_f      â”¬  Y_dst = G_dst+jB_dst\n                     â”‚          â”‚          â”‚\n                     âš          âš          âš\n                   (fault enabled by breaker)\n\nThe fault admittance Y_f = G_f + jB_f can represent any fault impedance.\n\nTo model this, we introduce the internal voltages V_1, V_2 and V_mathrmm. We consider the equations of the PI-branch in quasi-static-state. Therefore, we can use complex variables to describe the voltages and the currents. What we need in the end are equations for the currents at the terminals, i.e. i_mathrmsrc and i_mathrmdst as a function of all the parameters and the given node voltages. Lets start writing down the equations:\n\nFirst, we \"split\" the impedance Z into two parts Z_a and Z_b:\n\nbeginaligned\nZ_mathrma = Z  mathrmpos\nZ_mathrmb = Z  (1-mathrmpos)\nendaligned\n\nNext, we can define the internal voltages V_1 and V_2 in terms of the terminal voltages and the transformation ratios:\n\nbeginaligned\nV_1 = r_mathrmsrc  V_mathrmsrc\nV_2 = r_mathrmdst  V_mathrmdst\nendaligned\n\nOnce we have the shunt voltages, we can directly calculate the shunt currents\n\nbeginaligned\ni_1 = Y_mathrmsrc  V_1\ni_2 = Y_mathrmdst  V_2\nendaligned\n\nTo calculate the middle voltage V_mathrmm, we need to consider the fault admittance Y_f. The fault admittance is defined as:\n\nY_f = G_f + jB_f\n\nThe effective fault admittance is controlled by the shortcircuit parameter:\n\nY_ftexteff = mathrmshortcircuit cdot Y_f\n\nWhen the fault is active, we apply Kirchhoff's current law at the middle node: i_mathrma = i_mathrmb + i_f, which leads to the middle voltage:\n\nV_mathrmm = fracV_1  (1-mathrmpos) + V_2  mathrmpos1 + Y_ftexteff  Z  mathrmpos  (1-mathrmpos)\n\nOnce we have the middle voltage defined, we can calculate the currents i_mathrma, i_mathrmb, and i_f:\n\nbeginaligned\ni_mathrma = fracV_1 - V_mathrmmZ_a\ni_mathrmb = fracV_mathrmm - V_2Z_b\ni_f = Y_ftexteff  V_mathrmm\nendaligned\n\nFinally, we can calculate the terminal currents using Kirchhoff law and the transformation ratios:\n\nbeginaligned\ni_mathrmsrc = (-i_mathrma - i_1)  r_mathrmsrc\ni_mathrmdst = (i_mathrmb - i_2)  r_mathrmdst\nendaligned","category":"section"},{"location":"generated/custom_line/#Implement-the-CustomPiBranch-MTKModel","page":"Custom Transmission Line","title":"Implement the CustomPiBranch MTKModel","text":"<details class=\"admonition is-details\">\n<summary class=\"admonition-header\">Excursion: Complex Variables in MTK Models</summary>\n<div class=\"admonition-body\">\n\nwarning: Complex variables are not supported in MTK Models (at least not in PowerDynamics.jl)\nIn the end, all parameters and variables of NetworkDynamic models are real-valued, therefore, we cannot use complex parameters or states in our MTK Models.\n\nHowever, there is a \"hack\" to prevent this issue. Lets say we want to model the complex equation\n\nU = Z cdot I\n\nWe could expand everything in real and imaginary parts and rewrite the equations. However, we can also use ModelingToolkits capability to have complex terms even without having complex variables.\n\n@variables u_r u_i i_r i_i\n@parameters R, X\nIc = i_r + im * i_i\n\nZ = R + im * X\n\nHere, Ic and Z are not a symbolic variables, they are julia variables which points to a complex term/expression.\n\nUsing Symboics/ModelingToolkit, we can also multiply complex terms:\n\nUc = Z * Ic\n\nBy applying real and imag to the complex term, we can extract the real and imaginary parts to form separate equations for real and imaginary part:\n\neqs = [\n    u_r ~ real(Uc),\n    u_i ~ imag(Uc)\n]\n\nThis trick can be used inside @mtkmodel as well, by just defining those complex terms in a begin...end block.\n\n</div>\n</details>\n\nWith the equations and the knowledge on how to use complex terms within MTK Models the definition is relatively straight forward:\n\n@mtkmodel CustomPiBranch begin\n    @parameters begin\n        R, [description=\"Resistance of branch in pu\"]\n        X, [description=\"Reactance of branch in pu\"]\n        G_src, [description=\"Conductance of src shunt\"]\n        B_src, [description=\"Susceptance of src shunt\"]\n        G_dst, [description=\"Conductance of dst shunt\"]\n        B_dst, [description=\"Susceptance of dst shunt\"]\n        r_src=1, [description=\"src end transformation ratio\"]\n        r_dst=1, [description=\"dst end transformation ratio\"]\n        # fault parameters\n        pos=0.5, [description=\"Fault Position (from src, percent of the line)\"]\n        G_f=1, [description=\"Fault conductance in pu\"]\n        B_f=0, [description=\"Fault susceptance in pu\"]\n        shortcircuit=0, [description=\"shortcircuit on line\"]\n        # parameter to \"switch off\" the line\n        active=1, [description=\"Line active or switched off\"]\n    end\n    @components begin\n        src = Terminal()\n        dst = Terminal()\n    end\n    begin\n        # define complex variables\n        Z = R + im*X\n        Ysrc = G_src + im*B_src\n        Ydst = G_dst + im*B_dst\n        Yf = G_f + im*B_f\n        Vsrc = src.u_r + im*src.u_i\n        Vdst = dst.u_r + im*dst.u_i\n        # define Z_a and Z_b in terms of Z\n        Z_a = Z * pos\n        Z_b = Z * (1-pos)\n        # define internal voltages using the\n        Vâ‚ = r_src * Vsrc\n        Vâ‚‚ = r_dst * Vdst\n        # currents through the shunt admittances\n        iâ‚ = Ysrc * Vâ‚\n        iâ‚‚ = Ydst * Vâ‚‚\n        # effective fault admittance (controlled by shortcircuit)\n        Yf_eff = shortcircuit * Yf\n        # middle voltage with fault admittance effect\n        V_m = (Vâ‚*(1-pos) + Vâ‚‚*pos) / (1 + Yf_eff * Z * pos * (1-pos))\n        # fault current to ground\n        i_f = Yf_eff * V_m\n        # current through the two Z parts\n        i_a = (Vâ‚ - V_m) / Z_a\n        i_b = (V_m - Vâ‚‚) / Z_b\n        # terminal currents\n        isrc = (-i_a - iâ‚)*r_src\n        idst = (i_b - iâ‚‚)*r_dst\n    end\n    @equations begin\n        src.i_r ~ active * real(isrc)\n        src.i_i ~ active * imag(isrc)\n        dst.i_r ~ active * real(idst)\n        dst.i_i ~ active * imag(idst)\n    end\nend\nnothing #hide\n\nAdditionally to the equations defined above, we multiply the currents by active. This is equivalent of opening two ideal breakers on both ends of the branch when active=false.\n\nLastly lets ensure that our model satisfies the Branch Interface:\n\n@named pibranch = CustomPiBranch()\nisbranchmodel(pibranch)","category":"section"},{"location":"generated/custom_line/#Extending-the-model-for-dynamic-over-current-Protection","page":"Custom Transmission Line","title":"Extending the model for dynamic over-current Protection","text":"Now that we have a working basic PI-branch model, let's extend it with dynamic protection capabilities.\n\nIn order to implement the overcurrent protection, we need to make a plan in terms of callbacks. Callbacks are a neat feature of DifferentialEquations.jl, which allow you to stop the solver under certain conditions and trigger a user-defined affect function to change the state of the system. Their general capability is extended in NetworkDynamics.\n\nWe want to implement the following behavior:\n\nContinuously monitor the current magnitude and compare to the maximal current threshold.\nIf the maximum current is reached at time t, mark the line as to be switched off at time t_mathrmcutoff = t + Delta t.\nContinuously monitor time of the simulation and switch off the line at t_mathrmcutoff.\n\nThe way to implement this is by introducing 3 new parameters:\n\nI_max, the maximum current magnitude,\nt_cutoff=Inf, the time when the line should be switched off, which defaults to infinity and\nt_delay, the delay time after which the line should be switched off.\n\nFor robust overcurrent protection, we need to implement multiple complementary callbacks:\n\nA continuous callback that detects smooth threshold crossings using root-finding\nA discrete callback that catches instantaneous jumps above the threshold\nA cutoff callback that switches off the line at the scheduled time\n\nThis dual detection approach is necessary because discrete events (like short circuits) can cause the current to jump above the threshold without crossing it smoothly, which continuous callbacks might miss. Both overcurrent callbacks share the same affect function that schedules the line cutoff, while the cutoff callback actually switches off the line.\n\nnote: Note\nNetworkDynamics currently does not support Events defined in MTK models. So we need to split the implementation: The new parameters need to be introduced to the MTKModel (extending CustomPiBranch), the callbacks need to be defined for the compiled EdgeModel.","category":"section"},{"location":"generated/custom_line/#Extension-of-the-CustomPiBranch-MTKModel","page":"Custom Transmission Line","title":"Extension of the CustomPiBranch MTKModel","text":"Let's add the new parameters to the CustomPiBranch model by extending the model. Extend means that we essentially copy-paste the whole model definitions and are able to add new parameters, equations, variables and so on.\n\nWe add an additional \"observed\" state I_mag, which always contains the current magnitude at the src or dst terminal (whatever is higher).\n\n@mtkmodel ProtectedPiBranch begin\n    @extend CustomPiBranch()\n    @parameters begin\n        I_max=Inf, [description=\"Maximum current magnitude\"]\n        t_cutoff=Inf, [description=\"Time when the line should be switched off\"]\n        t_delay=0.1, [description=\"Delay time after which the line should be switched off\"]\n    end\n    @variables begin\n        I_mag(t), [description=\"Current magnitude at src or dst terminal\"]\n    end\n    @equations begin\n        I_mag ~ max(sqrt(src.i_r^2 + src.i_i^2), sqrt(dst.i_r^2 + dst.i_i^2))\n    end\nend\nnothing #hide\n\nOnce the model is defined, we can go through the building hierarchy outlined in Modeling Concepts. First, we need to form something satisfying the MTKLine Interface.","category":"section"},{"location":"generated/custom_line/#Creating-the-Dual-Branch-MTKLine","page":"Custom Transmission Line","title":"Creating the Dual-Branch MTKLine","text":"Here we implement our dual-branch architecture by creating two separate ProtectedPiBranch instances and combining them into a single MTKLine. This creates a transmission line model with two parallel branches:\n\n â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n â”‚MTKLine   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚\n â”‚         â”Œâ”¤ ProtectedPiBranch A â”œâ”         â”‚\n â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚\n â”‚â”‚LineEndâ”œo                       oâ”¤LineEndâ”‚â”‚\n â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚\n â”‚  :src   â””â”¤ ProtectedPiBranch B â”œâ”˜  :dst   â”‚\n â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚\n â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe end terminals of both branches are connected to the same physical line end. However, the branches operate independently:\n\nEach branch monitors its own current magnitude (pibranchAâ‚ŠI_mag, pibranchBâ‚ŠI_mag)\nEach has independent protection parameters (I_max, t_delay, t_cutoff)\nEach can be individually switched off (pibranchAâ‚Šactive, pibranchBâ‚Šactive)\nElectrical parameters are adjusted so that parallel combination matches the original single-branch behavior\n\nbranchA = ProtectedPiBranch(; name=:pibranchA)\nbranchB = ProtectedPiBranch(; name=:pibranchB)\nmtkline = MTKLine(branchA, branchB)\nnothing #hide\n\nThen, we take the mtkline and put it into a compiled EdgeModel by calling the compile_line constructor\n\n\n       â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n       â•‘ EdgeModel (compiled)                          â•‘\n       â•‘ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘\n   src â•‘ â”‚MTKLine   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â•‘ dst\nvertex â•‘ â”‚         â”Œâ”¤ ProtectedPiBranch A â”œâ”         â”‚ â•‘ vertex\n   u â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â†â”€â”€â”€ u\n       â•‘ â”‚â”‚LineEndâ”œo                       oâ”¤LineEndâ”‚â”‚ â•‘\n   i â†â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”€â”€â”€â†’ i\n       â•‘ â”‚  :src   â””â”¤ ProtectedPiBranch B â”œâ”˜  :dst   â”‚ â•‘\n       â•‘ â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â•‘\n       â•‘ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘\n       â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nprotected_template = compile_line(mtkline; name=:protected_piline)\n\ntip: Reduced complexity of compiled Model\nNote, that the compiled model still has no states, i.e. it directly calculates the terminal currents from the terminal voltages and the parameters. This is a perfect showcase of why equation based modeling matters: we still can access all of the internal variables, like the currents per branch. However those are all just \"observed\" and don't add to the numeric dimensionality of our model. (Even though the complexity of calculating the output currents is slightly higher than that of the simple PI-Line model).","category":"section"},{"location":"generated/custom_line/#Definition-of-the-Callbacks","page":"Custom Transmission Line","title":"Definition of the Callbacks","text":"We implement the callbacks as outlined in the NetworkDynamic docs on Callbacks.\n\nFor robust overcurrent protection, we need two complementary callbacks:\n\nA continuous callback that detects smooth threshold crossings using root-finding\nA discrete callback that catches instantaneous jumps above the threshold\n\nThis dual approach is necessary because discrete events (like short circuits) can cause the current to jump above the threshold without crossing it smoothly, which continuous callbacks might miss.","category":"section"},{"location":"generated/custom_line/#Overcurrent-Detection-Callbacks","page":"Custom Transmission Line","title":"Overcurrent Detection Callbacks","text":"For ComponentCondition, we need to specify which symbols to monitor. We've explicitly added I_mag as an observed state to our ProtectedPiBranch model, which contains the maximum current magnitude between the src and dst terminals for each branch.\n\nSince our dual-branch transmission line has two independent branches (:pibranchA and :pibranchB), we define callback functions that take the branch name as a parameter. This allows us to automatically create identical callbacks for both branches without code duplication.\n\nCondition Definitions:\n\nThe continuous condition uses root-finding, returning the difference between limit and current magnitude (zero when the limit is reached):\n\nfunction continuous_overcurrent_condition(branchname)\n    I_mag = Symbol(branchname, \"â‚Š\", :I_mag) # pilineXâ‚ŠI_mag\n    I_max = Symbol(branchname, \"â‚Š\", :I_max) # pilineXâ‚ŠI_max\n    t_cutoff = Symbol(branchname, \"â‚Š\", :t_cutoff) # pilineXâ‚Št_cutoff\n\n    ComponentCondition([I_mag], [I_max, t_cutoff]) do u, p, t\n        p[t_cutoff] != Inf && return Inf # return Inf if cutoff already scheduled\n        p[I_max] - u[I_mag]\n    end\nend\nnothing #hide\n\nThe discrete condition uses a boolean check that triggers whenever the current exceeds the threshold:\n\nfunction discrete_overcurrent_condition(branchname)\n    I_mag = Symbol(branchname, \"â‚Š\", :I_mag) # pilineXâ‚ŠI_mag\n    I_max = Symbol(branchname, \"â‚Š\", :I_max) # pilineXâ‚ŠI_max\n    t_cutoff = Symbol(branchname, \"â‚Š\", :t_cutoff) # pilineXâ‚Št_cutoff\n\n    ComponentCondition([I_mag], [I_max, t_cutoff]) do u, p, t\n        p[t_cutoff] != Inf && return false # return false if cutoff already scheduled\n        u[I_mag] â‰¥ p[I_max]\n    end\nend\nnothing #hide\n\nShared Affect Function:\n\nBoth callbacks use the same affect function. When triggered, it schedules the line cutoff by setting t_cutoff and tells the integrator to step to that time:\n\nfunction overcurrent_affect(branchname)\n    t_cutoff = Symbol(branchname, \"â‚Š\", :t_cutoff) # pilineXâ‚Št_cutoff\n    t_delay = Symbol(branchname, \"â‚Š\", :t_delay)   # pilineXâ‚Št_delay\n\n    ComponentAffect([], [t_cutoff, t_delay]) do u, p, ctx\n        p[t_cutoff] != Inf && return # return early if already scheduled for cutoff\n        tcutoff = ctx.t + p[t_delay]\n        println(\"$branchname of line $(ctx.src)â†’$(ctx.dst) overcurrent at t=$(ctx.t), scheduling cutoff at t=$tcutoff\")\n        # update the parameter of the edge to store the cutoff time\n        p[t_cutoff] = tcutoff\n        # tell the integrator to explicitly step to the cutoff time\n        add_tstop!(ctx.integrator, tcutoff)\n    end\nend\nnothing #hide","category":"section"},{"location":"generated/custom_line/#Line-Cutoff-Callback","page":"Custom Transmission Line","title":"Line Cutoff Callback","text":"The cutoff callback switches off the line when the scheduled cutoff time is reached. Since we expect the solver to explicitly hit the cutoff time (via add_tstop!), we only need a discrete callback:\n\nfunction cutoff_condition(branchname)\n    t_cutoff = Symbol(branchname, \"â‚Š\", :t_cutoff) # pilineXâ‚Št_cutoff\n    ComponentCondition([], [t_cutoff]) do u, p, t\n        t == p[t_cutoff]\n    end\nend\nfunction cutoff_affect(branchname)\n    active = Symbol(branchname, \"â‚Š\", :active) # pilineXâ‚Šactive\n    ComponentAffect([], [active]) do u, p, ctx\n        println(\"$branchname of line $(ctx.src)â†’$(ctx.dst) cutoff at t=$(ctx.t)\")\n        p[active] = 0 # switch off the line\n    end\nend\nfunction cutoff_callback(branchname)\n    DiscreteComponentCallback(cutoff_condition(branchname), cutoff_affect(branchname))\nend\nnothing #hide","category":"section"},{"location":"generated/custom_line/#Adding-Callbacks-to-Template","page":"Custom Transmission Line","title":"Adding Callbacks to Template","text":"We build both callbacks by combining their respective conditions and affects. Finally, we add all three callbacks to the protected template:\n\nfunction branch_callbacks(branchname)\n    oc_affect = overcurrent_affect(branchname)\n    oc1 = ContinuousComponentCallback(\n        continuous_overcurrent_condition(branchname),\n        oc_affect\n    )\n    oc2 = DiscreteComponentCallback(\n        discrete_overcurrent_condition(branchname),\n        oc_affect\n    )\n    cut = DiscreteComponentCallback(\n        cutoff_condition(branchname),\n        cutoff_affect(branchname)\n    )\n    (oc1, oc2, cut)\nend\nset_callback!(protected_template, branch_callbacks(:pibranchA))\nadd_callback!(protected_template, branch_callbacks(:pibranchB))\nprotected_template #hide","category":"section"},{"location":"generated/custom_line/#Simulate-the-IEEE39-Grid-with-the-ProtectedLine","page":"Custom Transmission Line","title":"Simulate the IEEE39 Grid with the ProtectedLine","text":"In the last part of this tutorial, we want to see our protected transmission line in action. The third part of the IEEE39 Grid Tutorial simulates a short circuit on a line. To do so, it uses two callbacks: one to enable the short circuit and one to disable the line. We can do this much more elegantly now by just using the ProtectedPiBranch model.\n\nLets load the first part of that tutorial to get the IEEE39 Grid model. Also, we initialize the model (the quintessence of part II).\n\nEXAMPLEDIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\")\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part1.jl\"))\nformula = @initformula :ZIPLoadâ‚ŠVset = sqrt(:busbarâ‚Šu_r^2 + :busbarâ‚Šu_i^2)\nset_initformula!(nw[VIndex(31)], formula)\nset_initformula!(nw[VIndex(39)], formula)\ns0 = initialize_from_pf!(nw; verbose=false)\nnothing #hide\n\nNow, we should have a fully initialized network available as nw:\n\nnw","category":"section"},{"location":"generated/custom_line/#Derive-Network-with-Protected-Line-Models","page":"Custom Transmission Line","title":"Derive Network with Protected Line Models","text":"Now we'll demonstrate the protected line model in action by applying it to the IEEE39 test system.\n\nWe need to build our own network model by replacing the transmission line models with our ProtectedPiBranch. For that, we create a helper function that takes an edge model from the old network and creates a protected transmission line model with equivalent electrical parameters.\n\nOur protected transmission line model uses two parallel branches (A and B), so we need to adjust the parameters. For two parallel branches to behave like the original single branch:\n\nImpedances (R, X): 2Ã— original (parallel combination gives original)\nShunt admittances (G, B): 0.5Ã— original (parallel combination gives original)\nTransformation ratios (r): same as original\n\nfunction protected_line_from_line(e::EdgeModel)\n    new = copy(protected_template)\n    # copy src and destination information\n    src_dst = get_graphelement(e)\n    set_graphelement!(new, src_dst)\n    for branch in [:pibranchA, :pibranchB]\n        # Impedances: double them (2Ã— original)\n        set_default!(new, Symbol(branch, \"â‚Š\", :R), 2 * get_default(e, :pilineâ‚ŠR))\n        set_default!(new, Symbol(branch, \"â‚Š\", :X), 2 * get_default(e, :pilineâ‚ŠX))\n        # Shunt admittances: halve them (0.5Ã— original)\n        set_default!(new, Symbol(branch, \"â‚Š\", :G_src), 0.5 * get_default(e, :pilineâ‚ŠG_src))\n        set_default!(new, Symbol(branch, \"â‚Š\", :B_src), 0.5 * get_default(e, :pilineâ‚ŠB_src))\n        set_default!(new, Symbol(branch, \"â‚Š\", :G_dst), 0.5 * get_default(e, :pilineâ‚ŠG_dst))\n        set_default!(new, Symbol(branch, \"â‚Š\", :B_dst), 0.5 * get_default(e, :pilineâ‚ŠB_dst))\n        # Transformation ratios: keep same\n        set_default!(new, Symbol(branch, \"â‚Š\", :r_src), get_default(e, :pilineâ‚Šr_src))\n        set_default!(new, Symbol(branch, \"â‚Š\", :r_dst), get_default(e, :pilineâ‚Šr_dst))\n    end\n    new\nend\nold_edgemodels = [nw[EIndex(i)] for i in 1:ne(nw)];\nvertexmodels = [nw[VIndex(i)] for i in 1:nv(nw)];\nnew_edgemodels = protected_line_from_line.(old_edgemodels);\nnothing #hide\n\nWe can then build a new Network with those modified edgemodels:\n\nnw_protected = Network(vertexmodels, new_edgemodels)\n\n... and initialize it!\n\ns0_protected = initialize_from_pf!(nw_protected; verbose=false)\n\nAs a short sanity check, lets compare the initialized values of both networks: we do so by extracting the interface_values for both solutions (a dictionary of all currents and voltages (inputs and outputs of the models))) Then we compare their values.\n\n@assert collect(values(interface_values(s0))) â‰ˆ collect(values(interface_values(s0_protected))) #hide\ncollect(values(interface_values(s0))) â‰ˆ collect(values(interface_values(s0_protected)))\n\nThey are identical! If we would have made an error in our transmission line model, the steady state would be most certainly different.","category":"section"},{"location":"generated/custom_line/#Simulate-with-the-Protected-Line-Models","page":"Custom Transmission Line","title":"Simulate with the Protected Line Models","text":"Now that we have our protected transmission line models ready, we need to configure them for the simulation. First, we set the current threshold I_max for overcurrent protection.\n\nWe set the threshold to 130% of the power flow solution:\n\nAFFECTED_LINE = 24\n\nfor i in 1:46\n    i_at_steadys = s0_protected[EIndex(i, :pibranchAâ‚ŠI_mag)]\n    s0_protected[EIndex(i, :pibranchAâ‚ŠI_max)] = 1.3*i_at_steadys\n    i_at_steadys = s0_protected[EIndex(i, :pibranchBâ‚ŠI_mag)]\n    s0_protected[EIndex(i, :pibranchBâ‚ŠI_max)] = 1.3*i_at_steadys\nend\nnothing #hide\n\nNext, we need to introduce a perturbation to test our protection system. We'll introduce a shortcircuit with Y_mathrmfault=1mathrmpu on branch A of line 24. Notably, we only need to start the short circuit, as the protection is now \"baked into\" the transmission line model.\n\n_enable_short = ComponentAffect([], [:pibranchAâ‚Šshortcircuit]) do u, p, ctx\n    @info \"Short circuit activated on branch A of line $(ctx.src)â†’$(ctx.dst) at t = $(ctx.t)s\"\n    p[:pibranchAâ‚Šshortcircuit] = 1\nend\nshortcircuit_cb = PresetTimeComponentCallback(0.1, _enable_short)\nknown_cbs = filter(cb -> !(cb isa PresetTimeComponentCallback), get_callbacks(nw_protected[EIndex(AFFECTED_LINE)]))\nset_callback!(nw_protected, EIndex(AFFECTED_LINE), (shortcircuit_cb, known_cbs...))\nnw_protected[EIndex(AFFECTED_LINE)] #hide\n\nWith all those callbacks set, we can go ahead simulating the system.\n\nprob = ODEProblem(\n    nw_protected,\n    s0_protected,\n    (0.0, 15);\n    dtmax=0.01,\n)\nsol = solve(prob, Rodas5P());\nnothing #hide\n\nWhen we run this simulation, the console output will show that the short circuit on Branch A activates at t=0.1s and leads to a line shutdown at t=0.2s (after the 0.1s delay), which clears the fault. However, due to the introduced dynamics in the system, branch B of the affected line also experiences a current magnitude exceeding the threshold, which leads to a shutdown of the line at around 1.5 seconds.\n\nLet's look at the current magnitude evolution during the simulation:\n\nfig = let fig = Figure()\n    ax = Axis(fig[1, 1];\n        title=\"Current Magnitude Across All Lines\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Current Magnitude (reltive to steady state)\")\n\n    # Full simulation time range\n    ts = range(sol.t[begin], sol.t[end], length=3000)\n\n    # Plot current magnitude for but the failing line\n    for i in 1:46\n        i == AFFECTED_LINE && continue\n        # Factor of 2: total transmission line current is double the branch current\n        # since we have two identical parallel branches (A and B)\n        current = 2*sol(ts, idxs=EIndex(i, :pibranchAâ‚ŠI_mag)).u\n        current = current ./ current[begin]\n        lines!(ax, ts, current)\n    end\n\n    A_current = sol(ts, idxs=EIndex(AFFECTED_LINE, :pibranchAâ‚ŠI_mag)).u\n    B_current = sol(ts, idxs=EIndex(AFFECTED_LINE, :pibranchBâ‚ŠI_mag)).u\n    A_current = A_current ./ A_current[begin]\n    B_current = B_current ./ B_current[begin]\n\n    lines!(ax, ts, A_current; linewidth=2, color=:blue, label=\"Branch A\")\n    lines!(ax, ts, B_current; linewidth=2, color=:red, label=\"Branch B\")\n\n    hlines!(ax, [1.3]; color=:black, linestyle=:dot)\n    xlims!(ax, ts[begin], ts[end])\n    axislegend(ax; pos=:tr)\n    fig\nend\n\nWe can also zoom into the time range around the short circuit to see how the current of branch B crosses the threshold and the branch is disabled shortly after.\n\nxlims!(0, 2)\nylims!(0.8, 1.5)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/ieee39_part2/#ieee39-part2","page":"IEEE39 Part II: Initialization","title":"IEEE39 Bus Tutorial - Part II: Initialization","text":"This tutorial can be downloaded as a normal Julia script here.\n\nThis is the second part of a four-part tutorial series for the IEEE 39-bus test system:\n\nPart I: Model Creation - Build the network structure with buses, lines, and components\nPart II: Initialization (this tutorial) - Perform power flow calculations and dynamic initialization\nPart III: Dynamic Simulation - Run time-domain simulations and analyze system behavior\nPart IV: Advanced Modeling & Parameter Optimization - Create custom components and optimize system parameters\n\nThe goal of this tutorial is to get an understanding of the initialization process in PowerDynamics.jl.\n\nFor comprehensive documentation on initialization, see:\n\nNetworkDynamics.jl initialization docs\nPowerDynamics.jl initialization docs\n\ntip: Quick Start\nIf you're looking for the practical initialization approach without diving into implementation details, jump directly to the Initialize all Components section at the end.\n\nThis tutorial goes deep into the initialization internals for educational purposes. In practice, you'll typically use the high-level functions shown at the end rather than the detailed step-by-step process demonstrated here.\n\nAs a prerequisite, we load part I of the tutorial, which contains the network model:\n\nusing PowerDynamics\nEXAMPLEDIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\")\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part1.jl\"))\nnw # nw object now available\n\nThe initialization process in PowerDynamics.jl is a two-step process: first we solve the power flow, then we use the power flow results to initialize the individual network components.\n\nThere are shortcut functions to do this (as shown later), but we will go through the steps in detail for educational purposes.","category":"section"},{"location":"generated/ieee39_part2/#Power-Flow","page":"IEEE39 Part II: Initialization","title":"Power Flow","text":"To solve the power flow, we first need to get the power flow model. We can use the function powerflow_model.\n\npfnw = powerflow_model(nw)\n\nThe power flow model is a Network object like the original network. It is built from the original network, by calling powerflow_model on the individual components. For example, we have this rather complex dynamic model at bus 30:\n\nnw[VIndex(30)]\n\nFrom the printout, we can see that a power flow model :pvbus is attached to the generator model.\n\nWe can extract the attached PV power flow model by calling powerflow_model\n\npowerflow_model(nw[VIndex(30)])\n\nThe function powerflow_model checks if there is a power flow model attached (it checks the :pfmodel metadata).\n\nPer component, the powerflow_model function will do the following:\n\nIf the model has the :pfmodel metadata set (see Metadata), it will return the VertexModel stored in the metadata. In Part I we set the :pfmodel metadata using the pf keyword to the [compile_bus].\nIf the model does not have the :pfmodel metadata set, PowerDynamics will check if the model itself is a valid power flow model. If so, it'll just use the dynamic model as the power flow model.\n\nWhat is a valid power flow model?: A valid power flow model is a model that has no internal dynamics, i.e. it either has dim(model) == 0 OR it has a zero mass matrix (i.e. only constraints).\n\nFor example, the PiLine models are completely static:\n\nnw[EIndex(1)]\n\nThis model has no internal states and no :pfmodel metadata.\n\n@assert ispfmodel(nw[EIndex(1)]) # is pf model itself\npowerflow_model(nw[EIndex(1)]) === nw[EIndex(1)]\n\nAs a result, when we call powerflow_model(nw), we get a completely static network, i.e. only constraints, no dynamics.\n\nall(iszero, pfnw.mass_matrix)\n\nThe fully static network has the form\n\ndotx = 0 = f_mathrmnw(x p t)\n\nWhere x are the network states (mainly voltages u_r and u_i at the buses) and p are all the parameters such as P, V and Q values for bus models and line parameters for branch models.\n\nTo solve this root-finding problem, we first need to find an initial guess. The initial guess is prefilled with all the default values from the components. In our case, all parameters and states have default values attached, so the initial state is fully determined.\n\npfs0 = NWState(pfnw)\n\nWith the default state, we can call find_fixpoint, which keeps p constant and tries to find an x such that the root-finding problem stated above is fulfilled:\n\npfs = find_fixpoint(pfnw, pfs0)\n\nAs a result, we get a NWState object which contains the full state for the power flow model.\n\nSince power flow model and dynamic model share the same topology and the same network interface (i.e. nodes create voltages, edges create currents), we can extract the interface values from the power flow model state and apply them to the dynamic model:\n\ninterf = interface_values(pfs)\n\nThe interface values give us the inputs and outputs for every component in the network, i.e. for all buses we get values for\n\nbusbarâ‚Ši_r and busbarâ‚Ši_i: current input\nbusbarâ‚Šu_r and busbarâ‚Šu_i: voltage output\n\nFor all branches we get:\n\nsrcâ‚Šu_r and srcâ‚Šu_i: source side voltage input\ndstâ‚Šu_r and dstâ‚Šu_i: destination side voltage input\nsrcâ‚Ši_r and srcâ‚Ši_i: source side current output\ndstâ‚Ši_r and dstâ‚Ši_i: destination side current output\n\nWith those interface values fixed, we can go over to the second step of the initialization process: the initialization of the dynamic component.","category":"section"},{"location":"generated/ieee39_part2/#Initialization-of-Dynamic-Components","page":"IEEE39 Part II: Initialization","title":"Initialization of Dynamic Components","text":"Initialization of a bus model means, we want to find a steady state of the dynamics given the interface values from the power flow model.\n\nTherefore, the equations for the bus models (recall from Modeling Concepts) become\n\nbeginaligned\nM_mathrm vfracmathrmdmathrmdtx_mathrm v = colorred0 = f^mathrm vleft(x^mathrm v colorredsum_kbeginbmatrixi^k_r i^k_iendbmatrix p_mathrm v tright)\ncolorredbeginbmatrixu_r u_iendbmatrix = g^mathrm v(x^mathrmvp_mathrm v t)\nendaligned\n\nwhere red symbols are fixed by either the power flow solution or our steady state condition (i.e. dotx=0). This leaves us with a system of N=mathrmdim(x) + mathrmdim(u) equations â€“ we can solve for N unknowns.\n\ndetails: Edge Initialization Equations\nbeginaligned\nM_mathrm efracmathrmdmathrmdtx_mathrm e = colorred0 = f_mathrm eleft(x_mathrm e colorredbeginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix colorredbeginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrixp_mathrme tright)\ncolorredbeginbmatrixi_r^mathrmsrci_i^mathrmsrcendbmatrix = g^mathrmsrc_mathrm eleft(x_mathrm ecolorred beginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix colorredbeginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrix p_mathrme tright)\ncolorredbeginbmatrixi_r^mathrmdsti_i^mathrmdstendbmatrix = g^mathrmdst_mathrm eleft(x_mathrm e colorredbeginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix colorredbeginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrix p_mathrme tright)\nendaligned\n\nNotably, the unknowns can come from either the set of states or the set of parameters. We divide the set of symbols into two sets:\n\nfixed symbols have a default metadata set. They are considered fixed in the solution of the nonlinear system.\nfree symbols only have a guess metadata set. They are considered free in the solution of the nonlinear system.\n\nLet's take a look at the bus model at bus 30:\n\ngen = nw[VIndex(30)]\n\nWe have a system with 15 States and 42 parameters. Of those, most are fixed, i.e. have a default metadata set. In the VertexModel printout, defaults are shown with = while guesses are shown with â‰ˆ. We can use dump_initial_state to get an overview of the free and set states:\n\ndump_initial_state(gen; obs=false)\n\nRight now, we have 2 free parameters, 2 free inputs, 2 free outputs and 15 free states. We can use initialize_component to find values for the free symbols:\n\ntry #hide\ninitialize_component(gen)\ncatch e #hide\n    @error e.msg #hide\nend #hide\n\nWait! The initialization failed! Why? Well, we need to apply additional defaults, so called default_overwrites for the inputs/outputs to make the system solvable.\n\ninterf_v30 = Dict( # manually define interface values for demonstration\n    :busbarâ‚Šu_r => 1.04573,\n    :busbarâ‚Šu_i => -0.0609188,\n    :busbarâ‚Ši_i => 1.53174,\n    :busbarâ‚Ši_r => -2.30145,\n)\ninitialize_component(gen; default_overrides=interf_v30)\nnothing #hide\n\nnote: Mutating vs non-mutating Initialization\nThe non mutating initialize_component returns a dictionary containing a full initialized component state. That can be useful for certain purposes, often it is easier to work with the mutating version of initialization function, which will write the initialized values back to the component metadata (i.e setting the :init property for the symbols).\n\nLet's call the mutating initialize_component! function to write the initialized values back to the component and inspect the initial state using dump_initial_state:\n\ninitialize_component!(gen; default_overrides=interf_v30)\ndump_initial_state(gen; obs=false)\n\nIn the state dump we see how the initialization successfully set all the previously unknown values, including the control parameters avrâ‚Švref and govâ‚Šp_ref. We have our first initialized component!\n\nHowever, in practice it's not always so easy.","category":"section"},{"location":"generated/ieee39_part2/#Handling-Structurally-Underconstrained-Components","page":"IEEE39 Part II: Initialization","title":"Handling Structurally Underconstrained Components","text":"Recalling from Part 1, we have an uncontrolled machine together with a load on bus 39.\n\n            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n            â•‘ Unctr. Ma. Load Bus (compiled) â•‘\n            â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â•‘\n  Network   â•‘  â”‚MTKBus      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â•‘\n interface  â•‘  â”‚          â”Œâ”€â”¤ Machine â”‚ â”‚    â•‘\n  current â”€â”€â”€â”€â†’â”‚ â”Œâ”€â”€â”€â”€â”€â”€â” â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â•‘\n            â•‘  â”‚ â”‚BusBarâ”œâ”€o             â”‚    â•‘\n  voltage â†â”€â”€â”€â”€â”‚ â””â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”    â”‚    â•‘\n            â•‘  â”‚          â””â”€â”¤ Load â”‚    â”‚    â•‘\n            â•‘  â”‚            â””â”€â”€â”€â”€â”€â”€â”˜    â”‚    â•‘\n            â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â•‘\n            â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nIf we try to initialize this component as before, we run into a problem:\n\ninterf_v39 = Dict(\n  :busbarâ‚Šu_r => 1.01419,\n  :busbarâ‚Šu_i => -0.179795,\n  :busbarâ‚Ši_i => -1.72223,\n  :busbarâ‚Ši_r => 0.720135,\n)\ntry #hide\ninitialize_component!(nw[VIndex(39)]; default_overrides=interf_v39)\ncatch e #hide\n    @error e.msg #hide\nend #hide\n\nEven though we set the interface values, the problem is still underconstrained! Let's check the free symbols:\n\nprintln(\"free u: \", free_u(nw[VIndex(39)]))\nprintln(\"free p: \", free_p(nw[VIndex(39)]))\nnothing #hide\n\nWe see 8 free states and 3 free parameters, however we only have 8 state + 2 output equations:\n\nnw[VIndex(39)] #hide\n\nEven though we have enough set parameters to initialize machine and load on its own, we cannot do it simultaneously. Intuitively speaking, it's just not clear for the solver which of the two components provides how much power.\n\nTo solve this, we have essentially 3 methods:","category":"section"},{"location":"generated/ieee39_part2/#Method-1:-Manual-setting-of-defaults","page":"IEEE39 Part II: Initialization","title":"Method 1: Manual setting of defaults","text":"The simplest solution is to manually set more defaults. For example, we know that we want to initialize the ZIP load around the initialization point, i.e. V_mathrmset should be the same as the bus voltage magnitude.\n\nvm_manual = copy(nw[VIndex(39)])\nu_r = get_initial_state(vm_manual, :busbarâ‚Šu_r)\nu_i = get_initial_state(vm_manual, :busbarâ‚Šu_i)\nset_default!(vm_manual, :ZIPLoadâ‚ŠVset, sqrt(u_r^2 + u_i^2))\ninitialize_component!(vm_manual)\nnothing #hide\n\nThe initialization succeeded now!\n\nnote: No more default_overrides\nNote how we can skip the default_overrides keyword argument, since the first (failing) call of initialize_component! already \"burned in\" the default overrides! Mutating state is a powerful tool, but it needs care!","category":"section"},{"location":"generated/ieee39_part2/#Method-2:-Adding-an-init_formula","page":"IEEE39 Part II: Initialization","title":"Method 2: Adding an init_formula","text":"The problem with the previous method is that it is quite manual. In reality, we would never go through this very manual initialization process. The fact that the model is structurally underconstrained is a property of the model and should therefore be handled by the model. To do so, NetworkDynamics.jl provides the InitFormula mechanism.\n\nAn InitFormula is a symbolic formula that is evaluated during the initialization process. It is attached to the VertexModel so it can be evaluated automatically during the initialization process. The \"formula\" we want to apply is simply the equation\n\nV_mathrmset = sqrtu_r^2 + u_i^2\n\nvm_formula = copy(nw[VIndex(39)])\nformula = @initformula :ZIPLoadâ‚ŠVset = sqrt(:busbarâ‚Šu_r^2 + :busbarâ‚Šu_i^2)\nset_initformula!(vm_formula, formula)\nvm_formula #hide\n\nThe printout shows 1 additional initialization equation was attached to the model.\n\nThe initialization works now:\n\ninitialize_component!(vm_formula)\nnothing #hide\n\nThe init formula is applied early in the initialization process, essentially writing a new default for ZIPLoadâ‚ŠVset based on the other defaults.\n\nThis reduced the number of free variables to 10, thus the system was solvable.","category":"section"},{"location":"generated/ieee39_part2/#Method-3:-Using-an-InitConstraint","page":"IEEE39 Part II: Initialization","title":"Method 3: Using an InitConstraint","text":"Sometimes, your additional initialization needs are more complicated. Similar to defining a formula, which is evaluated before the actual initialization, NetworkDynamics provides a mechanism for injecting additional constraints into the initialization process.\n\nIn contrast to the formula, the constraint does not need to be explicitly solvable, as it defines a residual equation\n\n0 = c(x) = V_mathrmset - sqrtu_r^2 + u_i^2\n\nvm_constraint = copy(nw[VIndex(39)])\nconstraint = @initconstraint begin\n  :ZIPLoadâ‚ŠVset - sqrt(:busbarâ‚Šu_r^2 + :busbarâ‚Šu_i^2)\nend\nset_initconstraint!(vm_constraint, constraint)\nvm_constraint #hide\n\nWith this added constraint, the initialization process is solvable again, since we now have 11 equations for the 11 free variables.\n\ninitialize_component!(vm_constraint)\nnothing #hide\n\nFor this particular case, method (2) is the way to go. However there are cases where the constraint is more complex and cannot be expressed as a formula.\n\nSee NetworkDynamics docs on Advanced Component Initialization: Formulas and Constraints and the PowerDynamics specific extension Advanced Component Initialization for more information on method 2 and 3.","category":"section"},{"location":"generated/ieee39_part2/#initialize-all-components","page":"IEEE39 Part II: Initialization","title":"Automatic Initialization of Full Network","text":"Let's return from our excursion into individual component initialization and focus on the whole network again. As we've just seen, we have structurally underconstrained components in the network. Let's define the init formulas for the two buses which have loads and machines:\n\nformula = @initformula :ZIPLoadâ‚ŠVset = sqrt(:busbarâ‚Šu_r^2 + :busbarâ‚Šu_i^2)\nset_initformula!(nw[VIndex(31)], formula)\nset_initformula!(nw[VIndex(39)], formula)\nnothing #hide\n\nWith that, the componentwise initialization of the whole network is possible:\n\ninitialize_componentwise!(nw; default_overrides=interf)\nnothing #hide\n\nEven shorter, we can just use initialize_from_pf! to do everything from exporting the power flow model, finding the fixpoint and initializing all components:\n\ns0 = initialize_from_pf!(nw)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"julia_setup/#julia-setup","page":"Julia Setup for New Users","title":"Julia Setup for PowerDynamics","text":"In this document we'll provide a very brief overview on how to set up your development environment with Julia. The goal of this document is to get you ready to follow our examples in this documentation.\n\nIf you've worked with Julia before, you can probably skip this part and jump to the getting started tutorial.\n\nWe recommend checking out further resources, like the excellent\n\ncommunity provided Modern Julia Workflows blog and the\nofficial Julia documentation.","category":"section"},{"location":"julia_setup/#Install-Julia","page":"Julia Setup for New Users","title":"Install Julia","text":"First you need to install Julia. Check out the install instructions on the official Julia homepage. It is recommended to install Julia using juliaup.\n\nnote: Note\njuliaup is a Julia version multiplexer, you can use it to manage different Julia versions on the same system using commands like juliaup update (update installed versions), juliaup add 1.11 (add a new version), juliaup default 1.11 (tell your computer which version to start when you invoke the julia command).\n\nIn general, Julia can be installed and run without any administrator privileges.","category":"section"},{"location":"julia_setup/#Windows","page":"Julia Setup for New Users","title":"Windows","text":"You can install Julia on Windows using the Microsoft Store. Instead of searching manually, you can invoke this installation in the terminal. Search for powershell in the start menu and execute\n\nwinget install --name Julia --id 9NJNWW8PVKMN -e -s msstore","category":"section"},{"location":"julia_setup/#Linux/Mac","page":"Julia Setup for New Users","title":"Linux/Mac","text":"Execute the following code in your terminal:\n\ncurl -fsSL https://install.julialang.org | sh\n\nThe installer will ask you some questions, you won't need to change any defaults.","category":"section"},{"location":"julia_setup/#Verify-installation","page":"Julia Setup for New Users","title":"Verify installation","text":"After the installation, run the julia command in your terminal. You should get an output like this:\n\n(Image: image)\n\ntip: Stick to Julia 1.11 for now\nBy default, juliaup will install the latest stable version of Julia. As of 10/2025, that is 1.12. However there are some minor problems in 1.12 which might make it less stable. For now, I'd advise you to stay at Julia 1.11. To do so, runjuliaup add 1.11\njuliaup default 1.11after which your julia command should point to Julia 1.11 by default.","category":"section"},{"location":"julia_setup/#The-Julia-REPL","page":"Julia Setup for New Users","title":"The Julia-REPL","text":"Julia's main interface is the REPL (read-eval-print-loop). It is similar to ipython or the Matlab command window. You can execute code in the REPL by typing it. Try julia> println(\"hello world\")<RETURN> to run your first Julia command. Exit the REPL by pressing CTRL + d or typing exit()<RETURN>.\n\ntip: Tip\nThe REPL has lots of great features. For example:hit ] to enter package manager mode (see Environment Basics below)\nhit ? to enter help mode: search for functions or concepts to get documentation\nscroll through history using arrow up and arrow down.","category":"section"},{"location":"julia_setup/#Install-VSCode-with-the-Julia-extension","page":"Julia Setup for New Users","title":"Install VSCode with the Julia extension","text":"The REPL is great, but we also need an editor for writing code. The best editor for most people will be Visual Studio Code. Please download and install it.\n\nWithin VSCode, you need to install the julia-extension. You should be able to click the \"install\" link in any browser, it'll open VSCode and install the extension. Alternatively, you can search for \"Julia\" in the VSCode extension store.","category":"section"},{"location":"julia_setup/#env-basics","page":"Julia Setup for New Users","title":"Environment and Package Manager Basics","text":"Julia has a built-in package manager. It lets you install, update and manage dependencies across your projects. Often, different projects require different dependencies and different versions.\n\nnote: Example\nLet's say you have a research project A using PowerDynamics at version v1.0.0 and it's working great. However, you want to start a new project B, which requires a new feature introduced in version v2.2.0! Environments help you to set up two different folders, one of which uses v1.0.0 and one uses v2.2.0. This approach helps you to try out new stuff in B without the fear of breaking your already working project A due to incompatible updates.\n\nTo create your first environment, create a new folder somewhere (for example /home/Documents/powerdynamics_playground). You can open this (empty) folder in VSCode and create a new file for your first script:\n\n(Image: image)\n\nOpen the newly created file, hit CTRL + SHIFT + P to bring up the VSCode \"command palette\", search for \"Start REPL\" and launch your Julia REPL.\n\nIn the REPL, you can execute pwd() (print working directory) to see the directory where your REPL was launched. Hit ] to launch the package manager. Your REPL changes:\n\n(@v1.11) pkg>\n\nThis output means your active environment is the global environment for Julia v1.11. If you were to add packages here, you would add them globally. Normally, that's not what we want. So instead we activate the current folder (.) as our working environment:\n\n(@v1.11) pkg> activate .\n\nAfter activation, we can add PowerDynamics to our newly created environment using\n\n(powerdynamics_playground) pkg> add PowerDynamics\n\nThis will install PowerDynamics and all its dependencies. It will also precompile all of that. This may take a while...\n\n(Image: image)\n\nOnce you've added a package, you'll see that two new files appeared: Project.toml and Manifest.toml. The Project.toml lists all of your dependencies. This is the file you change when adding new packages. It is relatively short and human readable. It only lists the top level dependencies, in this case just PowerDynamics. The Manifest.toml on the other hand lists all packages in the current environment. It is a full snapshot containing all versions of every dependency and also the dependencies of your dependencies. Never edit it by hand!\n\nProjectRoot\nâ”œâ•´example_script.jl\nâ”œâ•´Project.toml\nâ•°â•´Manifest.toml\n\nThe existence of a Project.toml file marks a folder as a project. You can activate such a folder. When executing code in a file using the Julia VSCode extension, it will automatically activate the environment for you.","category":"section"},{"location":"julia_setup/#Executing-Code-in-VSCode","page":"Julia Setup for New Users","title":"Executing Code in VSCode","text":"Working with Julia is much like working in a notebook (Jupyter, Google Colab or similar), due to the persistent REPL. Because of how Julia works internally, everything you do will take much more time the first time you do it. Therefore, it is always preferred to have a persistent REPL over relaunching Julia. That is:\n\nopening a REPL,\nexecuting a script in REPL,\nchanging script and\nrun script again in same REPL\n\nis much preferred to\n\nexecuting a script by calling julia myscript.jl\nchanging the script\nexecuting it again by calling julia myscript.jl\n\nin which case you'd pay the startup costs on every new run.\n\nBesides executing an entire script (play button up top), you can execute single lines and code blocks in VSCode:\n\nPut the VSCode cursor on a line and hit SHIFT + RETURN to \"send\" that line of code to the REPL. If the line is part of a multiline expression (like a function), it'll \"send\" the entire block.\nSelect multiple lines and hit SHIFT + RETURN to \"send\" all selected lines.\nHit ALT + RETURN (or CMD + RETURN) to execute an entire code cell, where a code cell is everything between lines starting with ##.\n\nnote: Execute your first Script\nInstall ModelingToolkit in addition to PowerDynamics in your environment and copy the following code to your script:using PowerDynamics\nusing ModelingToolkit\nusing PowerDynamics: Library\n\n@named swing = Library.Swing(V=1)\nbusmodel = MTKBus(swing)\nswingbus = compile_bus(busmodel)Execute it line by line using SHIFT + RETURN and enjoy your first bus model!(Image: image)","category":"section"},{"location":"julia_setup/#Running-PowerDynamics-Examples","page":"Julia Setup for New Users","title":"Running PowerDynamics Examples","text":"Now you know everything you need to know to run our examples locally.\n\nAt the beginning of each example, there is a link:\n\nThis tutorial can be downloaded as a normal Julia script here.\n\nGo to the getting started tutorial, download the script, put it in your directory and go through it, executing it block by block.\n\ntip: Tip\nFor the script to work you need to install additional packages. You can install multiple packages at once:julia> ] add OrdinaryDiffEqRosenbrock, CairoMakie","category":"section"},{"location":"julia_setup/#Defining-Functions-and-Revise.jl","page":"Julia Setup for New Users","title":"Defining Functions and Revise.jl","text":"Eventually, you'll grow out of putting everything into a script. The obvious next step is to put parts of your code in functions. You could put those functions in the script, however if you change the code you need to evaluate them again. Alternatively, you can create a new file, for example myfunctions.jl:\n\n# contents of myfunctions.jl\nfunction foo()\n    println(\"Hello World\")\nend\n\nThen, you can use Revise.jl to track changes in that file. In your main script, write\n\nRevise.includet(\"myfunctions.jl\") # <- execute this line SHIFT+RETURN\n\nfoo() # <- prints \"hello world\"\n\nThen, you can update your myfunctions.jl file\n\n# contents of myfunctions.jl\nfunction foo()\n    println(\"Hello World, but different.\")\nend\n\nand save it. If you evaluate foo() again (either in REPL directly or in your script), it'll print \"Hello World, but different.\" â€“ Revise automatically updates the function definition.\n\nAt some point, you might want to put your project in a Julia Package, but that's beyond the scope of this tutorial. Consult the documentation and your favorite Chatbot for help. Especially check out ] dev MyPackage in contrast to ] add MyPackage.","category":"section"},{"location":"julia_setup/#Additional-Remarks-and-Tips","page":"Julia Setup for New Users","title":"Additional Remarks & Tips","text":"Embrace the interactivity of the REPL: it really is (one of) Julia's superpowers. Play around with objects, make use of the help mode and use functions like propertynames() to explore structures.\nGet to know the package manager. It is really good! However, package management is not a trivial problem so package managers tend to be non-trivial. Read the docs and try to understand it. Just using it by trial and error will lead to major frustration down the road. Especially the option to ] dev packages and define local sources are very powerful tools.\nSeek help. The julia discourse and the Julia Slack and the Julia Zulip are great platforms to post your problems and get help from the community.","category":"section"},{"location":"generated/typical_simulation_workflow/#typical-simulation-workflow","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"The goal of this tutorial is to get you started with PowerDynamics.jl. We'll walk you through the different \"stages\" of a typical simulation workflow while introducing key terminology along the way.\n\nThis tutorial can be downloaded as a normal Julia script here.\n\nThe system to model is a simple 3 bus system:\n\nBus 1: ideal droop inverter\nBus 2: a constant Y load\nBus 3: a second constant Y load\n\nAll buses are connected with standard pi-model power lines.\n\n    â•­â”€â”€â”€â”€â”€â”€â”€â•®\n2 â”¯â”â”¿       â”¿â”â”¯ 3\n  â†“ â”‚   â•­â”€â”€â”€â•¯ â†“\n    â”·â”â”¯â”â”· 1\n      â”‚\n     (~)\n\nusing PowerDynamics\nusing PowerDynamics: Library\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie","category":"section"},{"location":"generated/typical_simulation_workflow/#Stage-I:-Defining-Dynamical-Models","page":"Typical Simulation Workflow","title":"Stage I: Defining Dynamical Models","text":"The first phase of the workflow is typically to define your dynamical models. Models may either come from a library (like the IdealDroopInverter and ConstantYLoad below) or they can be defined by the user.","category":"section"},{"location":"generated/typical_simulation_workflow/#Inverter-Model","page":"Typical Simulation Workflow","title":"Inverter Model","text":"In this case, we want the first bus to be an ideal droop inverter.\n\nOften, model definition will be a multi step process:\n\nFirst: we define an \"injector model\", in this case our inverter:\n\n(t) â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n oâ”€â”€â”¤ Droop Inverter â”‚\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\ninverter_model = Library.IdealDroopInverter(; name=:droop, Vset=1)\nnothing #hide\n\nThis model is an equation-based/symbolic model representing the dynamics. It is based on the great ModelingToolkit.jl Library.\n\nSecond: we build a \"Bus Model\", which connects the injector to a Busbar. This model still lives in the equation-based/symbolic domain.\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚BusModel                       â”‚\nâ”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚\nâ”‚â”‚ BusBar â”œâ”€oâ”€â”¤ Droop inverter â”‚â”‚\nâ”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nbus_model = MTKBus(inverter_model; name=:invbus)\nnothing #hide\n\nThird: we compile the symbolic model into a julia function for numeric simulation. Doing so, we get a VertexModel, which is an object from our backend NetworkDynamics.jl\n\n           â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n Network   â•‘ VertexModel (compiled)         â•‘\ninterface  â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘\n           â•‘  â”‚BusModel                   â”‚ â•‘\n current â”€â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â•‘\n           â•‘  â”‚â”‚BusBarâ”œoâ”¤ Droop inverter â”‚â”‚ â•‘\n voltage â†â”€â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â•‘\n           â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘\n           â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nbus1 = compile_bus(MTKBus(inverter_model); vidx=1)\n\nNote that this model is no longer symbolic. The equations have been reduced and transformed into a nonlinear descriptor model. For more information on the different model types, see the Modeling Concepts docs. You can check out the NetworkDynamics.jl doc on the underlying mathematical model.\n\nIn the printout above, you can see that we consider different types of variables in our models:\n\nthe input is always the current flowing from the attached power lines into the bus,\nthe output is always the voltage at the busbar,\nthe states are dynamical or algebraic states in the sense of a Differential-Algebraic-Equation (DAE) model,\nand parameters are static values that stay mostly constant during simulation and define the system behavior.\n\nThere is a 5th class of states not shown above: observables. Observables are time dependent values, which are not states in the sense of a DAE but can be reconstructed from the states, inputs, outputs and parameters. Thus, they don't need to be \"solved\" for numerically, but they can be reconstructed in post-processing. A simple example of an \"observed\" state would be a voltage angle or the active and reactive power at some bus.","category":"section"},{"location":"generated/typical_simulation_workflow/#Load-Models","page":"Typical Simulation Workflow","title":"Load Models","text":"For the two loads, we use the predefined ConstantYLoad model from the Library and compile them:\n\nload_model = Library.ConstantYLoad(; name=:load)\nbus2 = compile_bus(MTKBus(load_model); name=:loadbus, vidx=2)\nbus3 = compile_bus(MTKBus(load_model); name=:loadbus, vidx=3)","category":"section"},{"location":"generated/typical_simulation_workflow/#Power-Line-Models","page":"Typical Simulation Workflow","title":"Power Line Models","text":"Lastly, we need to define three power lines. The workflow is similar to the bus models:\n\nl = MTKLine(Library.PiLine(; name=:piline))\nline12 = compile_line(l; src=1, dst=2, pilineâ‚ŠR=0.01)\nline13 = compile_line(l; src=1, dst=3, pilineâ‚ŠR=0.01)\nline23 = compile_line(l; src=2, dst=3, pilineâ‚ŠR=0.01)\n\nNow we're all set for the next stage.","category":"section"},{"location":"generated/typical_simulation_workflow/#Stage-II:-Initialization","page":"Typical Simulation Workflow","title":"Stage II: Initialization","text":"When simulating power systems (or any large dynamical system for that matter), it is quite typical to start from a steady state/equilibrium point. In general, it is not trivial to find such a point for a large nonlinear system. In power systems specifically, it is common to solve a simpler system first â€“ the so-called \"power flow\" problem.\n\nIn the power flow problem, we neglect all the node dynamics and consider only 4 variables at each bus:\n\nthe active power P,\nthe reactive power Q,\nthe voltage magnitude V and\nthe voltage angle theta.\n\nIn the simplest power flow, each bus can then be classified into one of three types:\n\nSlack Bus: The voltage magnitude and angle are fixed (typically used for one bus in the system), P and Q is considered free.\nPV Bus P and V are fixed, Q and theta are free. Often used for generator buses or any buses with active voltage control.\nPQ Bus P and Q are fixed, V and theta are free. Typically used for load buses.\n\nSo each component essentially introduces two algebraic equations and two free variables â€“ the system is then solved for the free variables such that all equations are satisfied.","category":"section"},{"location":"generated/typical_simulation_workflow/#Attaching-Power-Flow-Models","page":"Typical Simulation Workflow","title":"Attaching Power Flow Models","text":"In PowerDynamics.jl, we can attach the power flow models to the dynamic bus models using the set_pfmodel! function.\n\nset_pfmodel!(bus1, pfSlack(V=1))\nset_pfmodel!(bus2, pfPQ(P=-0.4, Q=-0.3))\nset_pfmodel!(bus3, pfPQ(P=-0.6, Q=-0.2))\nnothing #hide","category":"section"},{"location":"generated/typical_simulation_workflow/#Building-the-Network","page":"Typical Simulation Workflow","title":"Building the Network","text":"Now we can build the network using the Network constructor from NetworkDynamics.jl This constructor takes a list of VertexModels (the buses) and a list of EdgeModels (the powerlines) and connects them to a network. In general, we also need to define the topology of the undelying graph. In this case however, this is not necessary because we told each component at the compile step where it is placed in the network (see the vidx, src and dst arguments above)\n\nnw = Network([bus1, bus2, bus3], [line12, line13, line23])\n\nThe Network object tells us that we've just defined a system with 7 States and 39 parameters. We have 3 vertices of 2 unique types (the inverter bus and the load bus) and 3 edges of a single unique type (all power lines are the same pi-line type).\n\nThe \"states\" and \"parameters\" already hint at a very important property of PowerDynamics/NetworkDynamics: in the end, the whole network is just a big DAE system of the form\n\nmathbfMdotmathbfx = f(mathbfx mathbfp t)\n\nwhere mathbfx are the states and mathbfp the parameters. This is very important to keep in mind, because it allows us to integrate seamlessly with the whole SciML ecosystem and, most importantly, DifferentialEquations.jl.\n\n@assert dim(nw) == 7 #hide\n@assert pdim(nw) == 39 #hide\n@assert dim(bus1) == 3 #hide\n@assert pdim(bus1) == 8 #hide\n@assert dim(bus2) == dim(bus2) == 2 #hide\n@assert pdim(bus2) == pdim(bus3) == 2 #hide\n@assert dim(line12) == dim(line13) == dim(line23) == 0 #hide\n@assert pdim(line12) == pdim(line13) == pdim(line23) == 9 #hide\n\nThe 7 states are essentially just the states of our models stacked on top of eachother. Look at the representation of our Vertex and EdgeModels above to see their contribution:\n\nBus 1: 3 states, 8 parameters\nBus 2 & 3: 2 states, 2 parameters each\nLines 1,2 and 3: 0 states, 9 parameters each\n\nIn sum, we get the 7 states and 39 parameters.\n\ntip: Advanced: State and Parameter Ordering\nEven though the states and parameters are essential \"just stacked\" on top of eachother, the ordering is not trivial due to performance reasons. Never rely on the ordering of states or parameters in the full system! PowerDynamics and NetworkDynamics provides lots of helper functions for so-called \"SymbolicIndexing\" to circumvent this.","category":"section"},{"location":"generated/typical_simulation_workflow/#Initializing-the-System-via-Power-Flow","page":"Typical Simulation Workflow","title":"Initializing the System via Power Flow","text":"With the network constructed, we can finally find our equilibrium point. We do so using initialize_from_pf:\n\ns0 = initialize_from_pf(nw; verbose=true, subverbose=true)\nnothing #hide\n\nThis function actually does quite a lot.\n\nIt extracts the powerflow model for each component constructing the powerflow problem.\nIt solves the powerflow problem.\nFrom the solution, we know the voltages and powers at each bus. Consequently, we also know the currents at each bus. This means we can directly \"map\" the powerflow solution to the inputs and outputs of each dynamic model.\nFor each dynamic model, we \"fix\" the inputs and outputs and try to find values for the states (and potentially parameters) such that the component model is in equilibrium. This is done using a nonlinear solver.\n\n@assert Set(free_p(nw[VIndex(1)])) == Set([:droopâ‚ŠPset, :droopâ‚ŠQset]) # hide\n@assert Set(free_u(nw[VIndex(1)])) == Set([:droopâ‚ŠÎ´, :droopâ‚ŠQfilt, :droopâ‚ŠPfilt]) # hide\n\nIn the log statements, we see which variables/parameters were considered free during the initialization of each component. This behavior can be fine-tuned in a lot of ways, which are beyond the scope of this tutorial. However, here we see that, for example, the complex parameter Y = B + jG of the constant Y-load was initially left free but then initialized from the powerflow solution. This means that Y is now set in a way that it draws the correct amount of power at the given voltage.\n\nSimilarly, we see that the inverter bus had the parameters P_set and Q_set free, which were also initialized from the powerflow solution. This is important, because we need to achieve power balance in the system, and due to the losses in the lines it's not possible to know the exact power injections a priori.\n\nThe return value of the initialize_from_pf function is a so-called NWState object, which wraps flat x and p vectors and provides a lot of helper functions to access and modify states (including observables) and parameters.\n\nLets inspect this object further:\n\ns0\n\nAt the highest level, we see the values of the 7 states in the network and their symbolic indices. Those indices can be used to access values directly:\n\ns0[VIndex(1, :droopâ‚ŠPfilt)]\n\ntip: Tip\nIn most julia dev environments you can type \\_+<TAB> to autocomplete the MTK namespace separator â‚Š.\n\nOften, you want to access observables or parameters instead of states. There is a whole filtering and access mechanism you can use for that. For example, in PD.jl, each bus has the states :busbarâ‚ŠP and :busbarâ‚ŠQ. We can inspect them on all vertices using:\n\ns0.v(:, [:busbarâ‚ŠP, :busbarâ‚ŠQ])\n\nIn the output, we clearly see how the load buses draw exactly the amount of power we specified in the power flow models. On the inverter bus, however, we inject slightly more power than the loads demand to compensate for the line losses.\n\nSimilarly, we can access all node parameters at initial state using\n\ns0.v.p\n\nHere we see how P_set and Q_set of the inverter were initialized in a way, that they match the powerflow solution.\n\nThere is a lot more functionality in the NWState objects, see the Symbolic Indexing docs of ND.jl and especially the FilteringProxy for more details.","category":"section"},{"location":"generated/typical_simulation_workflow/#Stage-III:-Time-Domain-Simulation","page":"Typical Simulation Workflow","title":"Stage III: Time Domain Simulation","text":"With the initialized state, we can finally simulate the system in time domain.","category":"section"},{"location":"generated/typical_simulation_workflow/#Perturbing-the-System","page":"Typical Simulation Workflow","title":"Perturbing the System","text":"Since we start from an equilibrium point, we expect the system to stay there if we don't perturb it. Therefore, to get interesting results, we need to perturb the system.\n\nThe simplest way to perturb the system is to change a parameter. For example, let's increase the admittance at bus 2 by 10% after 0.1 seconds.\n\nFor that, we define a so-called \"callback function\", more specifically a preset time callback, which is triggered at a specific simulation time and modifies the parameters. The simulation then continues. General information on callbacks in Differential Equations can be found in the DiffEq.jl docs. Specific extensions for NetworkDynamics.jl can be found in the NetworkDynamics.jl callback docs.\n\nWe define the callback and attach it to bus 2 (our first load) like this:\n\naffect = ComponentAffect([], [:loadâ‚ŠG, :loadâ‚ŠB]) do u, p, ctx\n    @info \"Increase load admittance Y by 10% at t=$(ctx.t)\"\n    p[:loadâ‚ŠG] = p[:loadâ‚ŠG] * 1.1\n    p[:loadâ‚ŠB] = p[:loadâ‚ŠB] * 1.1\nend\ncb = PresetTimeComponentCallback(0.1, affect)\nset_callback!(bus2, cb)\nbus2 #hide\n\nWith the callback defined, we can finally create and solve the ODEProblem:\n\nprob = ODEProblem(nw, s0, (0.0, 5.0))\nsol = solve(prob, Rodas5P());\nnothing #hide","category":"section"},{"location":"generated/typical_simulation_workflow/#Stage-IV:-Postprocessing-and-Visualization","page":"Typical Simulation Workflow","title":"Stage IV: Postprocessing and Visualization","text":"Once we have the solution object, we can use it like any other solution from DifferentialEquations.jl. Most importantly, we can use symbolic indices to access states, parameters and observables.","category":"section"},{"location":"generated/typical_simulation_workflow/#Plotting-Results","page":"Typical Simulation Workflow","title":"Plotting Results","text":"For example, we can quickly plot the frequency response of the droop using\n\nlines(sol, idxs=VIndex(1, :droopâ‚ŠÏ‰); axis=(;xlabel=\"Time [s]\", ylabel=\"Frequency Ï‰ [pu]\"))\n\nWe clearly see how the increased active power leads to a drop in frequency. This drop is then compensated by the droop control (i.e., we stabilize at a lower frequency).\n\nOf course, we can also create more complex plots, such as this one showing the active and reactive power at each bus:\n\nlet\n    fig = Figure(size=(1000,600))\n    ax = Axis(fig[1, 1]; xlabel=\"Time [s]\", ylabel=\"Active Power Load [pu]\")\n    for i in 2:3\n        lines!(ax, sol, idxs=VIndex(i, :busbarâ‚ŠP), color=Cycled(i))\n    end\n    axislegend(ax)\n    ax = Axis(fig[1,2]; xlabel=\"Time [s]\", ylabel=\"Reactive Power Load [pu]\")\n    for i in 2:3\n        lines!(ax, sol, idxs=VIndex(i, :busbarâ‚ŠQ), color=Cycled(i))\n    end\n    axislegend(ax)\n    ax = Axis(fig[2,1]; xlabel=\"Time [s]\", ylabel=\"Active Power Injection [pu]\")\n    lines!(ax, sol, idxs=VIndex(1, :busbarâ‚ŠP))\n    axislegend(ax)\n    ax = Axis(fig[2,2]; xlabel=\"Time [s]\", ylabel=\"Reactive Power Injection [pu]\")\n    lines!(ax, sol, idxs=VIndex(1, :busbarâ‚ŠQ))\n    axislegend(ax)\n    fig\nend\n\nHere we see that the active and reactive power demand shoots up in the beginning after we increase Y. The power demand then slowly decreases again. This is probably due to a drop in voltage, which leads to lower power demand on constant Y loads.\n\nLet's plot the voltage to verify this:\n\nlet\n    fig = Figure()\n    ax = Axis(fig[1, 1]; xlabel=\"Time [s]\", ylabel=\"Voltage [pu]\")\n    for i in 1:3\n        lines!(ax, sol, idxs=VIndex(i, :busbarâ‚Šu_mag), color=Cycled(i))\n    end\n    axislegend(ax; position=:rc)\n    fig\nend","category":"section"},{"location":"generated/typical_simulation_workflow/#Programmatic-Access-to-Variables","page":"Typical Simulation Workflow","title":"Programmatic Access to Variables","text":"Instead of plotting, we can also always use the solution interpolation to access values programmatically. For example\n\nsol(1.0, idxs=VIndex(1,:droopâ‚ŠÏ‰))\n\ngives us the frequency of the droop inverter at time t=1.0s.\n\nSimilarly, we can extract time series by passing a vector of time points rather than a single point:\n\nsol([0.1,0.2,0.3], idxs=VIndex(1:3, :busbarâ‚Šu_mag))\n\nThis code gives us the voltage magnitude at all three buses at the time points 0.1s, 0.2s, and 0.3s.\n\nTo deeply inspect a single point, we can also construct a NWState object from the solution for a specific time:\n\ns095 = NWState(sol, 0.95)\n\ngives us the state at t=0.95s. We can use the state object for inspection as we did before. For example, we can inspect the power at the destination end of all lines at this point in time:\n\ns095.e(:, :dstâ‚ŠP)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/ieee9bus/#ieee9bus","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"This tutorial can be downloaded as a normal Julia script here.\n\nIn this example, we're going to model the IEEE 9 bus system.\n\nThe parameters are mainly adopted from the RTDS data.\n\nusing PowerDynamics\nusing PowerDynamics.Library\nusing ModelingToolkit\nusing NetworkDynamics\nusing Graphs\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie","category":"section"},{"location":"generated/ieee9bus/#Generator-Buses","page":"IEEE 9-Bus Example","title":"Generator Buses","text":"The 3 generator buses are modeled using a SauerPai 6th order machine model with variable field voltage and mechanical torque input. The field voltage is provided by an AVRTypeI, the torque is provided by a TGOV1 model.\n\nfunction GeneratorBus(; machine_p=(;), avr_p=(;), gov_p=(;))\n    @named machine = SauerPaiMachine(;\n        vf_input=true,\n        Ï„_m_input=true,\n        S_b=100,\n        V_b=1,\n        Ï‰_b=2Ï€*60,\n        R_s=0.000125,\n        Tâ€³_d0=0.01,\n        Tâ€³_q0=0.01,\n        machine_p... # unpack machine parameters\n    )\n    @named avr = AVRTypeI(; vr_min=-5, vr_max=5,\n        Ka=20, Ta=0.2,\n        Kf=0.063, Tf=0.35,\n        Ke=1, Te=0.314,\n        E1=3.3, Se1=0.6602, E2=4.5, Se2=4.2662,\n        tmeas_lag=false,\n        avr_p... # unpack AVR parameters\n    )\n    @named gov = TGOV1(; R=0.05, T1=0.05, T2=2.1, T3=7.0, DT=0, V_max=5, V_min=-5,\n        gov_p... # unpack governor parameters\n    )\n    # generate the \"injector\" as combination of multiple components\n    injector = CompositeInjector([machine, avr, gov]; name=:generator)\n\n    # generate the MTKBus (i.e. the MTK model containg the busbar and the injector)\n    mtkbus = MTKBus(injector)\nend\nnothing #hide","category":"section"},{"location":"generated/ieee9bus/#Load-Buses","page":"IEEE 9-Bus Example","title":"Load Buses","text":"The dynamic loads are modeled as static Y-loads. Those have 2 parameters: G and B which form the complex admittance\n\nY = G + jB\n\nFor now, those parameters will be left free. We'll initialize them later on from the powerflow results.\n\nfunction ConstantYLoadBus()\n    @named load = ConstantYLoad()\n    MTKBus(load; name=:loadbus)\nend\nnothing #hide","category":"section"},{"location":"generated/ieee9bus/#Generate-Dynamical-models","page":"IEEE 9-Bus Example","title":"Generate Dynamical models","text":"The parameters of the machines are obtained from the data table from the RTDS datasheet.\n\ngen1p = (;X_ls=0.01460, X_d=0.1460, Xâ€²_d=0.0608, Xâ€³_d=0.06, X_q=0.1000, Xâ€²_q=0.0969, Xâ€³_q=0.06, Tâ€²_d0=8.96, Tâ€²_q0=0.310, H=23.64)\ngen2p = (;X_ls=0.08958, X_d=0.8958, Xâ€²_d=0.1198, Xâ€³_d=0.11, X_q=0.8645, Xâ€²_q=0.1969, Xâ€³_q=0.11, Tâ€²_d0=6.00, Tâ€²_q0=0.535, H= 6.40)\ngen3p = (;X_ls=0.13125, X_d=1.3125, Xâ€²_d=0.1813, Xâ€³_d=0.18, X_q=1.2578, Xâ€²_q=0.2500, Xâ€³_q=0.18, Tâ€²_d0=5.89, Tâ€²_q0=0.600, H= 3.01)\nnothing #hide\n\nWe instantiate all models as modeling toolkit models.\n\nmtkbus1 = GeneratorBus(; machine_p=gen1p)\nmtkbus2 = GeneratorBus(; machine_p=gen2p)\nmtkbus3 = GeneratorBus(; machine_p=gen3p)\nmtkbus4 = MTKBus() # <- bus with no injectors, essentially\nmtkbus5 = ConstantYLoadBus()\nmtkbus6 = ConstantYLoadBus()\nmtkbus7 = MTKBus()\nmtkbus8 = ConstantYLoadBus()\nmtkbus9 = MTKBus()\nnothing #hide\n\nAfter this, we can build the NetworkDynamics components using the Bus-constructor.\n\nThe Bus constructor is essentially a thin wrapper around the VertexModel constructor which, per default, adds some metadata. For example the vidx property which later on allows for \"graph free\" network dynamics instantiation.\n\nWe use the pf keyword to specify the models which should be used in the powerflow calculation. Here, generator 1 is modeled as a slack bus while the other two generators are modeled as PV buses. The loads are modeled as PQ buses.\n\n@named bus1 = compile_bus(mtkbus1; vidx=1, pf=pfSlack(V=1.04))\n@named bus2 = compile_bus(mtkbus2; vidx=2, pf=pfPV(V=1.025, P=1.63))\n@named bus3 = compile_bus(mtkbus3; vidx=3, pf=pfPV(V=1.025, P=0.85))\n@named bus4 = compile_bus(mtkbus4; vidx=4)\n@named bus5 = compile_bus(mtkbus5; vidx=5, pf=pfPQ(P=-1.25, Q=-0.5))\n@named bus6 = compile_bus(mtkbus6; vidx=6, pf=pfPQ(P=-0.9, Q=-0.3))\n@named bus7 = compile_bus(mtkbus7; vidx=7)\n@named bus8 = compile_bus(mtkbus8; vidx=8, pf=pfPQ(P=-1.0, Q=-0.35))\n@named bus9 = compile_bus(mtkbus9; vidx=9)\nnothing #hide","category":"section"},{"location":"generated/ieee9bus/#Branches","page":"IEEE 9-Bus Example","title":"Branches","text":"Branches and Transformers are built from the same PILine model with optional transformer on both ends. However, the data is provided in a way that the actual transformer values are 1.0. Apparently, the transforming action has been absorbed into the line parameters according to the base voltage on both ends.\n\nFor the lines we again make use of the src and dst metadata of the EdgeModel objects for automatic graph construction.\n\nfunction piline(; R, X, B)\n    @named pibranch = PiLine(;R, X, B_src=B/2, B_dst=B/2, G_src=0, G_dst=0)\n    MTKLine(pibranch)\nend\nfunction transformer(; R, X)\n    @named transformer = PiLine(;R, X, B_src=0, B_dst=0, G_src=0, G_dst=0)\n    MTKLine(transformer)\nend\n\n@named l45 = compile_line(piline(; R=0.0100, X=0.0850, B=0.1760), src=4, dst=5)\n@named l46 = compile_line(piline(; R=0.0170, X=0.0920, B=0.1580), src=4, dst=6)\n@named l57 = compile_line(piline(; R=0.0320, X=0.1610, B=0.3060), src=5, dst=7)\n@named l69 = compile_line(piline(; R=0.0390, X=0.1700, B=0.3580), src=6, dst=9)\n@named l78 = compile_line(piline(; R=0.0085, X=0.0720, B=0.1490), src=7, dst=8)\n@named l89 = compile_line(piline(; R=0.0119, X=0.1008, B=0.2090), src=8, dst=9)\n@named t14 = compile_line(transformer(; R=0, X=0.0576), src=1, dst=4)\n@named t27 = compile_line(transformer(; R=0, X=0.0625), src=2, dst=7)\n@named t39 = compile_line(transformer(; R=0, X=0.0586), src=3, dst=9)\nnothing #hide","category":"section"},{"location":"generated/ieee9bus/#Build-Network","page":"IEEE 9-Bus Example","title":"Build Network","text":"Finally, we can build the network by providing the vertices and edges.\n\nvertexfs = [bus1, bus2, bus3, bus4, bus5, bus6, bus7, bus8, bus9];\nedgefs = [l45, l46, l57, l69, l78, l89, t14, t27, t39];\nnw = Network(vertexfs, edgefs; warn_order=false)","category":"section"},{"location":"generated/ieee9bus/#System-Initialization","page":"IEEE 9-Bus Example","title":"System Initialization","text":"To initialize the system for dynamic simulation, we use initialize_from_pf! which performs a unified powerflow solving and component initialization process.\n\nInternally, this function:\n\nBuilds an equivalent static powerflow network from the dynamic models\nSolves the static powerflow equations using the specified powerflow models (pfSlack, pfPV, pfPQ)\nUses the powerflow solution to initialize all dynamic component states and parameters\n\nThis ensures that the dynamic model starts from a steady-state condition that matches the powerflow solution. Specifically, it determines:\n\nBus voltages and currents from the powerflow solution\nUnknown G and B parameters for load buses\nInternal machine states (flux linkages, rotor angles, etc.)\nController states and references for AVRs and governors\n\nFor example, we use constant Y-loads for the dynamic load models. Those have a fixed admittance\n\nY = G+jB\n\nwhich is not known a priori. However, from the powerflow (where the loads are modeled as PQ loads) we know both voltage and current at steady state. With this knowledge, we can determine the missing parameters G and B such that the dynamic load model matches the static load model in the initial state.\n\nu0 = initialize_from_pf(nw);\nnothing #hide\n\nTo verify what we've just said, we can check the initial values of the active and reactive power of our constant Y load model at bus 5 to see if it matches the setpoints of our powerflow model:\n\nu0[VIndex(5, :loadâ‚ŠP)] â‰ˆ -1.25 && u0[VIndex(5, :loadâ‚ŠQ)] â‰ˆ -0.5","category":"section"},{"location":"generated/ieee9bus/#Disturbance","page":"IEEE 9-Bus Example","title":"Disturbance","text":"To see some dynamics, we need to introduce some disturbance. For that we use a PresetTimeComponentCallback to deactivate a line at a certain time.\n\ndeactivate_line = ComponentAffect([], [:pibranchâ‚Šactive]) do u, p, ctx\n    @info \"Deactivate line $(ctx.src)=>$(ctx.dst) at t=$(ctx.t)\"\n    p[:pibranchâ‚Šactive] = 0\nend\ncb = PresetTimeComponentCallback([1.0], deactivate_line)\nset_callback!(l46, cb)\nl46 # printout shows that the callback is set","category":"section"},{"location":"generated/ieee9bus/#Dynamic-Simulation","page":"IEEE 9-Bus Example","title":"Dynamic Simulation","text":"With the system properly initialized, we can now set up and run the dynamic simulation. We create an ODE problem using the initialized state and simulate the system response to the line outage disturbance.\n\nprob = ODEProblem(nw,  u0, (0,15))\nsol = solve(prob, Rodas5P())\nnothing #hide","category":"section"},{"location":"generated/ieee9bus/#Plotting-the-Solution","page":"IEEE 9-Bus Example","title":"Plotting the Solution","text":"Finally, we visualize the simulation results showing the system response to the line outage at t=1.0 seconds. The plots show active power, voltage magnitudes, and generator frequencies across the simulation time.\n\nfig = Figure(size=(600,800));\n\n# Active power at selected buses\nax = Axis(fig[1, 1]; title=\"Active Power\", xlabel=\"Time [s]\", ylabel=\"Power [pu]\")\nfor i in [1,2,3,5,6,8]\n    lines!(ax, sol; idxs=VIndex(i,:busbarâ‚ŠP), label=\"Bus $i\", color=Cycled(i))\nend\naxislegend(ax)\n\n# Voltage magnitude at all buses\nax = Axis(fig[2, 1]; title=\"Voltage Magnitude\", xlabel=\"Time [s]\", ylabel=\"Voltage [pu]\")\nfor i in 1:9\n    lines!(ax, sol; idxs=VIndex(i,:busbarâ‚Šu_mag), label=\"Bus $i\", color=Cycled(i))\nend\n\n# Generator frequencies\nax = Axis(fig[3, 1]; title=\"Generator Frequency\", xlabel=\"Time [s]\", ylabel=\"Frequency [pu]\")\nfor i in 1:3\n    lines!(ax, sol; idxs=VIndex(i,:generatorâ‚Šmachineâ‚ŠÏ‰), label=\"Gen $i\", color=Cycled(i))\nend\naxislegend(ax)\n\nfig #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/ieee39_part1/#ieee39-part1","page":"IEEE39 Part I: Modeling","title":"IEEE39 Bus Tutorial - Part I: Model Creation","text":"This tutorial can be downloaded as a normal Julia script here.\n\nThis is the first part of a four-part tutorial series for the IEEE 39-bus test system:\n\nPart I: Model Creation (this tutorial) - Build the network structure with buses, lines, and components\nPart II: Initialization - Perform power flow calculations and dynamic initialization\nPart III: Dynamic Simulation - Run time-domain simulations and analyze system behavior\nPart IV: Advanced Modeling & Parameter Optimization - Create custom components and optimize system parameters\n\nIn this first part, we'll construct the complete IEEE 39-bus network model using PowerDynamics.jl, including generators, loads, transmission lines, and control systems.","category":"section"},{"location":"generated/ieee39_part1/#System-Structure","page":"IEEE39 Part I: Modeling","title":"System Structure","text":"The system consists of 39 buses (with 10 generators and 19 loads) and 46 branches (12 of which are transformers).\n\nThe buses fall into the following categories:\n\nJunction: pure transient buses without dynamic components\nLoad: buses with loads only\nControlled Machine: buses with controlled machines (generators with AVR and GOV)\nControlled Machine + Load: buses with controlled machines and loads\nUncontrolled Machine + Load: buses with uncontrolled machines and loads\n\nFor the power flow solution, we have a slack bus, PV buses and PQ buses.\n\nFor the dynamic simulation, we will use the following models:\n\nZIP Load for loads,\n6th Order Sauer-Pai Machine and\nAVR Type I and TGOV1 for controlled machines.","category":"section"},{"location":"generated/ieee39_part1/#Setup-and-Data-Loading","page":"IEEE39 Part I: Modeling","title":"Setup and Data Loading","text":"warning: No Standardized Data Import\nAs of now, PowerDynamics.jl does not support any advanced import mechanisms for power grids. Therefore, this tutorial loads the data from some custom CSV files.\n\nFirst, we'll load the required packages and read the system data from CSV files. The IEEE 39-bus system data is organized into separate files for different components.\n\nusing PowerDynamics\nusing PowerDynamics.Library\nusing ModelingToolkit\nusing NetworkDynamics\nusing DataFrames\nusing CSV\n\nDATA_DIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\", \"ieee39data\")\nnothing #hide\n\nThe system data is stored in CSV files containing:\n\ndetails: bus.csv - Bus Configuration Data\nParameter Description\nbus Bus number (unique identifier)\nbus_type Power flow bus type: \"PQ\" (load), \"PV\" (generator), \"Slack\" (reference)\ncategory Component category: \"junction\", \"load\", \"ctrld_machine\", \"ctrld_machine_load\", \"unctrld_machine_load\"\nP Active power injection [pu] (positive = generation, negative = load)\nQ Reactive power injection [pu] (positive = generation, negative = load)\nV Voltage magnitude [pu] (for PV and Slack buses)\nbase_kv Base voltage level [kV]\nhas_load Boolean flag indicating presence of load component\nhas_gen Boolean flag indicating presence of generator component\nhas_avr Boolean flag indicating presence of automatic voltage regulator\nhas_gov Boolean flag indicating presence of turbine governor\n\ndetails: branch.csv - Transmission Line and Transformer Data\nParameter Description\nsrc_bus Source bus number\ndst_bus Destination bus number\ntransformer Transformer flag (0 = line, 1 = transformer)\nr_src Source end transformation ratio [pu]\nR Series resistance [pu]\nX Series reactance [pu]\nG_src Source end shunt conductance [pu]\nG_dst Destination end shunt conductance [pu]\nB_src Source end shunt susceptance [pu]\nB_dst Destination end shunt susceptance [pu]\n\ndetails: load.csv - ZIP Load Model Parameters\nParameter Description\nbus Bus number where load is connected\nPset Active power at operation point [pu]\nQset Reactive power at operation point [pu]\nKpZ Active power constant impedance fraction\nKqZ Reactive power constant impedance fraction\nKpI Active power constant current fraction\nKqI Reactive power constant current fraction\nKpC Active power constant power fraction (1-KpZ-KpI)\nKqC Reactive power constant power fraction (1-KqZ-KqI)Note: ZIP loads combine constant impedance (Z), constant current (I), and constant power (P) components.\n\ndetails: machine.csv - Generator (Sauer-Pai Machine) Parameters\nParameter Description\nbus Bus number where generator is connected\nSn Machine power rating [MVA]\nV_b System voltage basis [kV]\nVn Machine voltage rating [kV]\nR_s Stator resistance [pu]\nX_ls Stator leakage reactance [pu]\nX_d d-axis synchronous reactance [pu]\nX_q q-axis synchronous reactance [pu]\nXâ€²_d d-axis transient reactance [pu]\nXâ€²_q q-axis transient reactance [pu]\nXâ€³_d d-axis subtransient reactance [pu]\nXâ€³_q q-axis subtransient reactance [pu]\nTâ€²_d0 d-axis transient time constant [s]\nTâ€²_q0 q-axis transient time constant [s]\nTâ€³_d0 d-axis subtransient time constant [s]\nTâ€³_q0 q-axis subtransient time constant [s]\nH Inertia constant [s]\nD Direct shaft damping coefficient\n\ndetails: avr.csv - Automatic Voltage Regulator (AVR Type I) Parameters\nParameter Description\nbus Bus number where AVR-controlled generator is located\nKa Amplifier gain\nKe Field circuit integral deviation\nKf Stabilizer gain\nTa Amplifier time constant [s]\nTf Stabilizer time constant [s]\nTe Field circuit time constant [s]\nTr Measurement time constant [s]\nvr_min Minimum regulator voltage [pu]\nvr_max Maximum regulator voltage [pu]\nE1 First ceiling voltage [pu]\nSe1 First ceiling saturation factor\nE2 Second ceiling voltage [pu]\nSe2 Second ceiling saturation factor\n\ndetails: gov.csv - Turbine Governor (TGOV1) Parameters\nParameter Description\nbus Bus number where governor-controlled generator is located\nV_min Minimum valve position [pu]\nV_max Maximum valve position [pu]\nR Governor droop [Machine PU]\nT1 First transient time constant [s]\nT2 Second transient time constant [s]\nT3 Third transient time constant [s]\nDT Turbine damping coefficient\nÏ‰_ref Reference frequency [pu]\n\nbranch_df = CSV.read(joinpath(DATA_DIR, \"branch.csv\"), DataFrame)\nbus_df = CSV.read(joinpath(DATA_DIR, \"bus.csv\"), DataFrame)\nload_df = CSV.read(joinpath(DATA_DIR, \"load.csv\"), DataFrame)\nmachine_df = CSV.read(joinpath(DATA_DIR, \"machine.csv\"), DataFrame)\navr_df = CSV.read(joinpath(DATA_DIR, \"avr.csv\"), DataFrame)\ngov_df = CSV.read(joinpath(DATA_DIR, \"gov.csv\"), DataFrame)\nnothing #hide\n\nSystem base values follow the IEEE 39-bus standard:\n\nBASE_MVA = 100.0\nBASE_FREQ = 60.0\nnothing #hide","category":"section"},{"location":"generated/ieee39_part1/#Subcomponent-Definition","page":"IEEE39 Part I: Modeling","title":"Subcomponent Definition","text":"As stated above, our buses fall into 5 different categories. We will define a \"template\" for each of those categories and then create the individual buses from those templates. By doing so, we can reach substantial performance improvements, as we do not have to repeatedly compile the same models (the symbolic simplification is quite costly). Instead, we copy the templates and adjust parameters.\n\nHowever, before we can define the bus templates, we need to define the individual subcomponents. Those subcomponents are MTK models and not yet compiled node models. See Modeling Concepts and the custom bus tutorial.","category":"section"},{"location":"generated/ieee39_part1/#Load-Model","page":"IEEE39 Part I: Modeling","title":"Load Model","text":"We use the ZIP load model to represent loads. This model satisfies the Injector Interface.\n\n(t) â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n oâ”€â”€â”¤ ZIP Load â”‚\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nload = ZIPLoad(;name=:ZIPLoad)\nnothing #hide","category":"section"},{"location":"generated/ieee39_part1/#Generator-Models","page":"IEEE39 Part I: Modeling","title":"Generator Models","text":"For generators, we use the Sauer-Pai machine model, which is a 6th-order synchronous machine model. We create two variants:\n\nUncontrolled Machine: No external control inputs for mechanical torque or field voltage. This model satisfies the Injector Interface directly.\n\n(t) â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n oâ”€â”€â”¤ Machine â”‚\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nuncontrolled_machine = SauerPaiMachine(;\n    Ï„_m_input=false,  ## No external mechanical torque input\n    vf_input=false,   ## No external field voltage input\n    name=:machine,\n)\nnothing #hide\n\nControlled Machine: Includes automatic voltage regulator (AVR) and turbine governor controls.\n\nThe controlled machine is modeled as a composite injector. It consists of 3 subcomponents: the machine, the AVR and the governor. The AVR receives the voltage magnitude measurement from the terminal of the machine and sets the field voltage. The governor receives the frequency measurement and sets the mechanical torque. Together, they satisfy the Injector Interface.\n\n      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n      â”‚ CtrldMachine  u_mag_meas      â”‚\n      â”‚              â•­â”€â”€â”€â”€â”€â†’â”€â”€â”€â”€â•®     â”‚\n      â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”      â”Œâ”€â”´â”€â”€â”€â” â”‚\n  (t) â”‚    â”‚           â”œâ”€â”€â”€â†â”€â”€â”¤ AVR â”‚ â”‚\n   oâ”€â”€â”¼â”€â”€â”€â”€â”¤ Sauer-Pai â”‚ vf   â””â”€â”€â”€â”€â”€â”˜ â”‚\n      â”‚    â”‚ Machine   â”‚ Ï„_m  â”Œâ”€â”€â”€â”€â”€â” â”‚\n      â”‚    â”‚           â”œâ”€â”€â”€â†â”€â”€â”¤ Gov â”‚ â”‚\n      â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”˜      â””â”€â”¬â”€â”€â”€â”˜ â”‚\n      â”‚              â•°â”€â”€â”€â”€â”€â†’â”€â”€â”€â”€â•¯     â”‚\n      â”‚                 Ï‰_meas        â”‚\n      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n_machine = SauerPaiMachine(;\n    name=:machine,\n)\n_avr = AVRTypeI(;\n    name=:avr,\n    ceiling_function=:quadratic,\n)\n_gov = TGOV1(; name=:gov,)\n\ncontrolled_machine = CompositeInjector(\n    [_machine, _avr, _gov],\n    name=:ctrld_gen\n)\nnothing #hide","category":"section"},{"location":"generated/ieee39_part1/#Bus-Template-Creation","page":"IEEE39 Part I: Modeling","title":"Bus Template Creation","text":"Now we have all the components (i.e., the MTK models) so we can combine them into full bus models and compile the methods.","category":"section"},{"location":"generated/ieee39_part1/#Junction-Bus","page":"IEEE39 Part I: Modeling","title":"Junction Bus","text":"Pure transmission buses with no generation or load\n\n           â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n           â•‘ Junction (compiled)  â•‘\n Network   â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘\ninterface  â•‘  â”‚MTKBus           â”‚ â•‘\n current â”€â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â”         â”‚ â•‘\n           â•‘  â”‚â”‚BusBarâ”‚(nothing)â”‚ â•‘\n voltage â†â”€â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”˜         â”‚ â•‘\n           â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘\n           â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n@named junction_bus_template = compile_bus(MTKBus())\nstrip_defaults!(junction_bus_template)  ## Clear default parameters for manual setting\njunction_bus_template #hide","category":"section"},{"location":"generated/ieee39_part1/#Load-Bus","page":"IEEE39 Part I: Modeling","title":"Load Bus","text":"Buses with only load components\n\n           â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n           â•‘ Load (compiled)     â•‘\n Network   â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘\ninterface  â•‘  â”‚MTKBus          â”‚ â•‘\n current â”€â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”‚ â•‘\n           â•‘  â”‚â”‚BusBarâ”œoâ”¤Loadâ”‚ â”‚ â•‘\n voltage â†â”€â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â”‚ â•‘\n           â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘\n           â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n@named load_bus_template = compile_bus(MTKBus(load))\nstrip_defaults!(load_bus_template)\nload_bus_template #hide","category":"section"},{"location":"generated/ieee39_part1/#Generator-Bus-(Controlled)","page":"IEEE39 Part I: Modeling","title":"Generator Bus (Controlled)","text":"Buses with controlled generators (machine + AVR + governor)\n\n            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n            â•‘ Ctrld Machine Bus (compiled)                   â•‘\n            â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘\n            â•‘  â”‚MTKBus                                     â”‚ â•‘\n            â•‘  â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â•‘\n  Network   â•‘  â”‚         â”‚CtrldMachine  â•­â”€â”€â”€â”€â”€â†’â”€â”€â”€â”€â•®     â”‚ â”‚ â•‘\n interface  â•‘  â”‚         â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”      â”Œâ”€â”´â”€â”€â”€â” â”‚ â”‚ â•‘\n  current â”€â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â” â”‚    â”‚           â”œâ”€â”€â”€â†â”€â”€â”¤ AVR â”‚ â”‚ â”‚ â•‘\n            â•‘  â”‚â”‚BusBarâ”œoâ”¼â”€â”€â”€â”€â”¤ Sauer-Pai â”‚      â””â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â•‘\n  voltage â†â”€â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ Machine   â”‚      â”Œâ”€â”€â”€â”€â”€â” â”‚ â”‚ â•‘\n            â•‘  â”‚         â”‚    â”‚           â”œâ”€â”€â”€â†â”€â”€â”¤ Gov â”‚ â”‚ â”‚ â•‘\n            â•‘  â”‚         â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”˜      â””â”€â”¬â”€â”€â”€â”˜ â”‚ â”‚ â•‘\n            â•‘  â”‚         â”‚              â•°â”€â”€â”€â”€â”€â†’â”€â”€â”€â”€â•¯     â”‚ â”‚ â•‘\n            â•‘  â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â•‘\n            â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘\n            â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n@named ctrld_machine_bus_template = compile_bus(\n    MTKBus(controlled_machine);\n)\nstrip_defaults!(ctrld_machine_bus_template)\n# Set system-wide base values for all generators\nset_default!(ctrld_machine_bus_template, r\"S_b$\", BASE_MVA)\nset_default!(ctrld_machine_bus_template, r\"Ï‰_b$\", 2Ï€*BASE_FREQ)\nctrld_machine_bus_template #hide","category":"section"},{"location":"generated/ieee39_part1/#Generator-Load-Bus-(Controlled)","page":"IEEE39 Part I: Modeling","title":"Generator + Load Bus (Controlled)","text":"Buses with both controlled generators and loads\n\n            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n            â•‘ Ctrld Machine Load Bus (compiled)               â•‘\n            â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘\n            â•‘  â”‚MTKBus    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â•‘\n            â•‘  â”‚          â”‚CtrldMachine  â•­â”€â”€â”€â”€â”€â†’â”€â”€â”€â”€â•®     â”‚ â”‚ â•‘\n            â•‘  â”‚          â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”      â”Œâ”€â”´â”€â”€â”€â” â”‚ â”‚ â•‘\n            â•‘  â”‚          â”‚    â”‚           â”œâ”€â”€â”€â†â”€â”€â”¤ AVR â”‚ â”‚ â”‚ â•‘\n  Network   â•‘  â”‚        â”Œâ”€â”¼â”€â”€â”€â”€â”¤ Sauer-Pai â”‚      â””â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â•‘\n interface  â•‘  â”‚        â”‚ â”‚    â”‚ Machine   â”‚      â”Œâ”€â”€â”€â”€â”€â” â”‚ â”‚ â•‘\n  current â”€â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â”â”‚ â”‚    â”‚           â”œâ”€â”€â”€â†â”€â”€â”¤ Gov â”‚ â”‚ â”‚ â•‘\n            â•‘  â”‚â”‚BusBarâ”œo â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”˜      â””â”€â”¬â”€â”€â”€â”˜ â”‚ â”‚ â•‘\n  voltage â†â”€â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚              â•°â”€â”€â”€â”€â”€â†’â”€â”€â”€â”€â•¯     â”‚ â”‚ â•‘\n            â•‘  â”‚        â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â•‘\n            â•‘  â”‚        â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”                          â”‚ â•‘\n            â•‘  â”‚        â””â”€â”¤ Load â”‚                          â”‚ â•‘\n            â•‘  â”‚          â””â”€â”€â”€â”€â”€â”€â”˜                          â”‚ â•‘\n            â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘\n            â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n@named ctrld_machine_load_bus_template = compile_bus(\n    MTKBus(controlled_machine, load);\n)\nstrip_defaults!(ctrld_machine_load_bus_template)\nset_default!(ctrld_machine_load_bus_template, r\"S_b$\", BASE_MVA)\nset_default!(ctrld_machine_load_bus_template, r\"Ï‰_b$\", 2Ï€*BASE_FREQ)\nctrld_machine_load_bus_template #hide","category":"section"},{"location":"generated/ieee39_part1/#Generator-Load-Bus-(Uncontrolled)","page":"IEEE39 Part I: Modeling","title":"Generator + Load Bus (Uncontrolled)","text":"Buses with uncontrolled generators and loads\n\n            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n            â•‘ Unctr. Ma. Load Bus (compiled) â•‘\n            â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â•‘\n  Network   â•‘  â”‚MTKBus      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â•‘\n interface  â•‘  â”‚          â”Œâ”€â”¤ Machine â”‚ â”‚    â•‘\n  current â”€â”€â”€â”€â†’â”‚ â”Œâ”€â”€â”€â”€â”€â”€â” â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â•‘\n            â•‘  â”‚ â”‚BusBarâ”œâ”€o             â”‚    â•‘\n  voltage â†â”€â”€â”€â”€â”‚ â””â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”    â”‚    â•‘\n            â•‘  â”‚          â””â”€â”¤ Load â”‚    â”‚    â•‘\n            â•‘  â”‚            â””â”€â”€â”€â”€â”€â”€â”˜    â”‚    â•‘\n            â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â•‘\n            â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n@named unctrld_machine_load_bus_template = compile_bus(\n    MTKBus(uncontrolled_machine, load);\n)\nstrip_defaults!(unctrld_machine_load_bus_template)\nset_default!(unctrld_machine_load_bus_template, r\"S_b$\", BASE_MVA)\nset_default!(unctrld_machine_load_bus_template, r\"Ï‰_b$\", 2Ï€*BASE_FREQ)\nunctrld_machine_load_bus_template #hide","category":"section"},{"location":"generated/ieee39_part1/#Bus-Instantiation-and-Parameter-Setting","page":"IEEE39 Part I: Modeling","title":"Bus Instantiation and Parameter Setting","text":"Now we create the actual bus instances by copying templates and applying specific parameters from the CSV data files.\n\n# Helper function to apply CSV parameters to bus components\nfunction apply_csv_params!(bus, table, bus_index)\n    row_idx = findfirst(table.bus .== bus_index)\n\n    # Apply all parameters except \"bus\" column\n    row = table[row_idx, :]\n    for col_name in names(table)\n        if col_name != \"bus\"\n            set_default!(bus, Regex(col_name*\"\\$\"), row[col_name])\n        end\n    end\nend\nnothing #hide\n\nFor each bus in the system, we:\n\nSelect the appropriate template based on its category\nCreate a bus instance with the correct vertex index and name\nApply component-specific parameters from CSV files\nSet the power flow model (PQ, PV, or Slack)\n\nbusses = []\nfor row in eachrow(bus_df)\n    i = row.bus\n\n    # Select template based on bus category\n    bus = if row.category == \"junction\"\n        compile_bus(junction_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    elseif row.category == \"load\"\n        compile_bus(load_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    elseif row.category == \"ctrld_machine\"\n        compile_bus(ctrld_machine_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    elseif row.category == \"ctrld_machine_load\"\n        compile_bus(ctrld_machine_load_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    elseif row.category == \"unctrld_machine_load\"\n        compile_bus(unctrld_machine_load_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    end\n\n    # Apply component parameters from CSV files\n    row.has_load && apply_csv_params!(bus, load_df, i)\n    row.has_gen && apply_csv_params!(bus, machine_df, i)\n    row.has_avr && apply_csv_params!(bus, avr_df, i)\n    row.has_gov && apply_csv_params!(bus, gov_df, i)\n\n    # Set power flow model based on bus type\n    pf_model = if row.bus_type == \"PQ\"\n        pfPQ(P=row.P, Q=row.Q)  ## Load bus: fixed P and Q\n    elseif row.bus_type == \"PV\"\n        pfPV(P=row.P, V=row.V)  ## Generator bus: fixed P and V\n    elseif row.bus_type == \"Slack\"\n        pfSlack(V=row.V, Î´=0)   ## Slack bus: fixed V and angle\n    end\n    set_pfmodel!(bus, pf_model)\n\n    push!(busses, bus)\nend","category":"section"},{"location":"generated/ieee39_part1/#Transmission-Line-Creation","page":"IEEE39 Part I: Modeling","title":"Transmission Line Creation","text":"The IEEE 39-bus system includes both transmission lines and transformers, all modeled using the Ï€-line equivalent circuit model.\n\nThe model consists of several layers:\n\nThe PiModel, which satisfies the Branch Interface as it has two terminals\nThe MTKLine constructor, which creates a MTK model fulfilling the MTKLine Interface\nThe compiled EdgeModel created by calling the compile_line constructor\n\n       â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n       â•‘ EdgeModel (compiled)             â•‘\n   src â•‘ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘ dst\nvertex â•‘ â”‚MTKLine                       â”‚ â•‘ vertex\n   u â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â†â”€â”€â”€ u\n       â•‘ â”‚â”‚LineEndâ”œoâ”¤ PiLine â”œoâ”¤LineEndâ”‚â”‚ â•‘\n   i â†â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”€â”€â”€â†’ i\n       â•‘ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘\n       â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n(We used the PiLine_fault model since we plan on simulating short circuits later.)\n\n@named piline_template = compile_line(MTKLine(PiLine_fault(;name=:piline)))\n\nEach transmission element is created by:\n\nInstantiating a line from the template with source and destination buses\nSetting electrical parameters (resistance, reactance, susceptance) from CSV data\n\nbranches = []\nfor row in eachrow(branch_df)\n    # Create line instance with topology\n    line = compile_line(piline_template; src=row.src_bus, dst=row.dst_bus)\n\n    # Apply electrical parameters from CSV data\n    for col_name in names(branch_df)\n        if col_name âˆ‰ [\"src_bus\", \"dst_bus\", \"transformer\"]\n            set_default!(line, Regex(col_name*\"\\$\"), row[col_name])\n        end\n    end\n\n    push!(branches, line)\nend","category":"section"},{"location":"generated/ieee39_part1/#Network-Assembly","page":"IEEE39 Part I: Modeling","title":"Network Assembly","text":"Finally, we combine all buses and transmission lines into a complete network model. This creates the IEEE 39-bus test system ready for initialization and simulation.\n\nnw = Network(busses, branches)\n\nThe network nw now contains the complete IEEE 39-bus model structure. In Part 2 of this tutorial series, we'll initialize this network by solving the power flow and setting up the dynamic initial conditions.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"Library/#Component-Library","page":"Component Library","title":"Component Library","text":"This page documents all the pre-built components available in the PowerDynamics.jl library.\n\nwarning: PowerDynamics.Library Under Active Development\nThe PowerDynamics.Library component library is currently excluded from semantic versioning and is under heavy development.While PowerDynamics itself follows semantic versioning, the Library submodule's API is highly unstable and variable names, function signatures, and model interfaces may change frequently without notice. If you are using specific models from PowerDynamics.Library in their current state, we strongly recommend copying them to your own source code to avoid breaking changes in future updates.","category":"section"},{"location":"Library/#Slack-Models","page":"Component Library","title":"Slack Models","text":"","category":"section"},{"location":"Library/#Algebraic-and-Differential-Slack","page":"Component Library","title":"Algebraic and Differential Slack","text":"","category":"section"},{"location":"Library/#Machine-Models","page":"Component Library","title":"Machine Models","text":"","category":"section"},{"location":"Library/#Synchronous-Machine-Models","page":"Component Library","title":"Synchronous Machine Models","text":"","category":"section"},{"location":"Library/#Control-Systems","page":"Component Library","title":"Control Systems","text":"","category":"section"},{"location":"Library/#Exciters-and-AVRs","page":"Component Library","title":"Exciters & AVRs","text":"","category":"section"},{"location":"Library/#Governors-and-Turbines","page":"Component Library","title":"Governors and Turbines","text":"","category":"section"},{"location":"Library/#Power-System-Stabilizers-(PSS)","page":"Component Library","title":"Power System Stabilizers (PSS)","text":"","category":"section"},{"location":"Library/#Load-Models","page":"Component Library","title":"Load Models","text":"","category":"section"},{"location":"Library/#Static-Load-Models","page":"Component Library","title":"Static Load Models","text":"","category":"section"},{"location":"Library/#Line-Models","page":"Component Library","title":"Line Models","text":"","category":"section"},{"location":"Library/#Transmission-Line-Models","page":"Component Library","title":"Transmission Line Models","text":"","category":"section"},{"location":"Library/#Fault-Models","page":"Component Library","title":"Fault Models","text":"","category":"section"},{"location":"Library/#Ground-Fault-Models","page":"Component Library","title":"Ground Fault Models","text":"","category":"section"},{"location":"Library/#PowerDynamics.Library.PSSE_GENCLS","page":"Component Library","title":"PowerDynamics.Library.PSSE_GENCLS","text":"PSSE_GENCLS\n\nThis model is a port of the OpenIPSL Electrical.Machines.PSSE.GENCLS model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Machines.PSSE.GENCLS. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_GENROU","page":"Component Library","title":"PowerDynamics.Library.PSSE_GENROU","text":"PSSE_GENROU\n\nThis model is a port of the OpenIPSL Electrical.Machines.PSSE.GENROU model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Machines.PSSE.GENROU. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"function"},{"location":"Library/#PowerDynamics.Library.PSSE_GENROE","page":"Component Library","title":"PowerDynamics.Library.PSSE_GENROE","text":"PSSE_GENROE\n\nThis model is a port of the OpenIPSL Electrical.Machines.PSSE.GENROE model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Machines.PSSE.GENROE. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"function"},{"location":"Library/#PowerDynamics.Library.PSSE_GENSAL","page":"Component Library","title":"PowerDynamics.Library.PSSE_GENSAL","text":"PSSE_GENSAL\n\nThis model is a port of the OpenIPSL Electrical.Machines.PSSE.GENSAL model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Machines.PSSE.GENSAL. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"function"},{"location":"Library/#PowerDynamics.Library.PSSE_GENSAE","page":"Component Library","title":"PowerDynamics.Library.PSSE_GENSAE","text":"PSSE_GENSAE\n\nThis model is a port of the OpenIPSL Electrical.Machines.PSSE.GENSAE model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Machines.PSSE.GENSAE. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"function"},{"location":"Library/#PowerDynamics.Library.PSSE_EXST1","page":"Component Library","title":"PowerDynamics.Library.PSSE_EXST1","text":"PSSE_EXST1\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.ES.EXST1 model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.ES.EXST1. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_ESST4B","page":"Component Library","title":"PowerDynamics.Library.PSSE_ESST4B","text":"PSSE_ESST4B\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.ES.ESST4B model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.ES.ESST4B. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\nwarning: Slight deviations from OpenIPSL behavior\nThere are still some slight deviations, likely due to differences in the initialization/steady state (see the current integrator state in the validation plot).\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_ESST1A","page":"Component Library","title":"PowerDynamics.Library.PSSE_ESST1A","text":"PSSE_ESST1A\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.ES.ESST1A model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.ES.ESST1A. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_SCRX","page":"Component Library","title":"PowerDynamics.Library.PSSE_SCRX","text":"PSSE_SCRX\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.ES.SCRX model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.ES.SCRX. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_IEEET1","page":"Component Library","title":"PowerDynamics.Library.PSSE_IEEET1","text":"PSSE_IEEET1\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.ES.IEEET1 model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.ES.IEEET1. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_IEEEG1","page":"Component Library","title":"PowerDynamics.Library.PSSE_IEEEG1","text":"PSSE_IEEEG1\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.TG.IEEEG1 model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.TG.IEEEG1. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\nwarning: Slight deviations from OpenIPSL behavior\nThere are still some slight deviations, likely due to differences in the initialization/steady state (see P_MECH output of the validation plot).\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_HYGOV","page":"Component Library","title":"PowerDynamics.Library.PSSE_HYGOV","text":"PSSE_HYGOV\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.TG.HYGOV model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.TG.HYGOV. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_GGOV1_EXPERIMENTAL","page":"Component Library","title":"PowerDynamics.Library.PSSE_GGOV1_EXPERIMENTAL","text":"PSSE_GGOV1_EXPERIMENTAL\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.TG.GGOV1 model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nwarning: Warning\nThis model does not support delay! It is validaded against a modified version of the OpenIPSL SMIB testcase Tests.Controls.PSSE.TG.GGOV1 without delay (see reference data generation script in /test/OpenIPSL/GGOV1 for modified version). Also, the OpenIPSL testcase does not start in a steady state, so we have some deviation in the validation still.     See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_IEEEST","page":"Component Library","title":"PowerDynamics.Library.PSSE_IEEEST","text":"PSSE_IEEEST\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.PSS.IEEEST model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.PSS.IEEEST. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"generated/ieee39_part3/#ieee39-part3","page":"IEEE39 Part III: Simulation","title":"IEEE39 Bus Tutorial - Part III: Dynamic Simulation","text":"This tutorial can be downloaded as a normal Julia script here.\n\nThis is the third part of the IEEE 39-bus tutorial series:\n\nPart I: Model Creation - Build the network structure with buses, lines, and components\nPart II: Initialization - Perform power flow calculations and dynamic initialization\nPart III: Dynamic Simulation (this tutorial) - Run time-domain simulations and analyze system behavior\nPart IV: Advanced Modeling & Parameter Optimization - Create custom components and optimize system parameters\n\nIn this tutorial, we'll demonstrate how to perform dynamic simulations of power system disturbances using PowerDynamics.jl. We'll simulate a short circuit fault followed by line disconnection and analyze the system's dynamic response.","category":"section"},{"location":"generated/ieee39_part3/#Short-Circuit-Disturbance-Scenario","page":"IEEE39 Part III: Simulation","title":"Short Circuit Disturbance Scenario","text":"We will simulate a three-phase short circuit fault on a transmission line, which is a common and severe disturbance in power systems. The disturbance scenario consists of:\n\nt = 0.1s: A short circuit occurs on line 11, drastically reducing its impedance\nt = 0.2s: The protective relay trips the line, completely disconnecting it from the system\nt = 0.2s onwards: The system operates with the line permanently out of service\n\nThis scenario tests the system's ability to:\n\nSurvive the initial fault (maintain synchronism)\nStabilize after the line disconnection\nOperate reliably with reduced transmission capacity\n\n# Loading required packages and setup\nusing PowerDynamics\nusing PowerDynamics.Library\nusing ModelingToolkit\nusing NetworkDynamics\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\n\n# Load the network model from Part I\nEXAMPLEDIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\")\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part1.jl\"))","category":"section"},{"location":"generated/ieee39_part3/#Network-Initialization","page":"IEEE39 Part III: Simulation","title":"Network Initialization","text":"Before we can run dynamic simulations, we need to initialize the network as described in Part II. This involves solving the power flow and initializing all dynamic components.\n\nFor buses with both generators and loads (buses 31 and 39), we need to add initialization formulas to resolve structural underconstraints by setting the load voltage setpoint equal to the bus voltage magnitude.\n\n# Add initialization formulas as described in Part II\nformula = @initformula :ZIPLoadâ‚ŠVset = sqrt(:busbarâ‚Šu_r^2 + :busbarâ‚Šu_i^2)\nset_initformula!(nw[VIndex(31)], formula)\nset_initformula!(nw[VIndex(39)], formula)\n\n# Initialize the complete network from power flow solution\ns0 = initialize_from_pf!(nw; verbose=false)\nnothing #hide","category":"section"},{"location":"generated/ieee39_part3/#Short-Circuit-Disturbance-Definition","page":"IEEE39 Part III: Simulation","title":"Short Circuit Disturbance Definition","text":"To simulate realistic power system dynamics, we need to introduce a disturbance that will excite the system's dynamic behavior. We'll simulate a short circuit fault on transmission line 11, which connects buses 5 and 8.","category":"section"},{"location":"generated/ieee39_part3/#Understanding-Line-Models-with-Fault-Capability","page":"IEEE39 Part III: Simulation","title":"Understanding Line Models with Fault Capability","text":"The transmission line models in our network include built-in parameters for fault simulation:\n\npibranchâ‚Šshortcircuit: When set to 1, this simulates a three-phase to ground short circuit along the line. The position in percentage can be given as a parameter too.\npibranchâ‚Šactive: When set to 0, this completely disconnects the line from the network (no current flowing into line or out of line, i.e., the line is disconnected at both ends)","category":"section"},{"location":"generated/ieee39_part3/#Callback-Functions-for-Disturbance-Events","page":"IEEE39 Part III: Simulation","title":"Callback Functions for Disturbance Events","text":"In order to simulate discrete perturbations, such as enabling a short circuit or disabling a line, we need to use callbacks. Callbacks are a neat feature of DifferentialEquations.jl, which allow you to stop the solver under certain conditions and trigger a user-defined affect function to change the state of the system.\n\nNetworkDynamics inherits this functionality as well. In addition, ND.jl provides a new type of callback: component callbacks. Those are callbacks which are attached to a single component rather than the full network, bringing the effect handling to the component level.\n\nHere we'll define two component callbacks: one to enable a short circuit at a given time and one to disable the line at a given time.\n\n# Select the line to be affected by the short circuit\nAFFECTED_LINE = 11\nnothing #hide\n\nLet's examine the transmission line that will experience the short circuit. This line connects two important buses in the network and its outage will test the system's stability.\n\nNow we define callback functions to model the disturbance sequence:\n\n# Define callback to enable short circuit at t=0.1s\nVERBOSE_CALLBACK = true #hide\n_enable_short = ComponentAffect([], [:pilineâ‚Šshortcircuit]) do u, p, ctx\n    if VERBOSE_CALLBACK #hide\n    @info \"Short circuit activated on line $(ctx.src)â†’$(ctx.dst) at t = $(ctx.t)s\"\n    end #hide\n    p[:pilineâ‚Šshortcircuit] = 1\nend\nshortcircuit_cb = PresetTimeComponentCallback(0.1, _enable_short)\n\n# Define callback to disconnect line at t=0.2s (fault clearing)\n_disable_line = ComponentAffect([], [:pilineâ‚Šactive]) do u, p, ctx\n    if VERBOSE_CALLBACK #hide\n    @info \"Line $(ctx.src)â†’$(ctx.dst) disconnected at t = $(ctx.t)s\"\n    end #hide\n    p[:pilineâ‚Šactive] = 0\nend\ndeactivate_cb = PresetTimeComponentCallback(0.2, _disable_line)\n\n# Attach both callbacks to the selected line\nset_callback!(nw, EIndex(AFFECTED_LINE), (shortcircuit_cb, deactivate_cb))\nnothing #hide\n\nThe callbacks are now attached to line 11. During simulation:\n\nAt t=0.1s, the short circuit callback activates, simulating the fault\nAt t=0.2s, the line disconnection callback activates, simulating relay action\n\nLet's verify the callbacks are properly attached:\n\nnw[EIndex(AFFECTED_LINE)]","category":"section"},{"location":"generated/ieee39_part3/#Dynamic-Simulation","page":"IEEE39 Part III: Simulation","title":"Dynamic Simulation","text":"Now we're ready to perform the dynamic simulation. We'll set up and solve an ordinary differential equation (ODE) problem that represents the network's dynamic behavior.","category":"section"},{"location":"generated/ieee39_part3/#Simulation-Setup","page":"IEEE39 Part III: Simulation","title":"Simulation Setup","text":"The simulation process involves:\n\nCreating the initial state vector from our initialized network\nSetting up the ODE problem with appropriate time span and callbacks\nSolving the ODE using a suitable numerical method\nAnalyzing the results\n\nThe constructor ODEProblem(::Network) automatically extracts the component callbacks from the models and uses them during the simulation.\n\nu0 = NWState(nw) # state is stored in metadata because of mutating init function!\nprob = ODEProblem(nw,  u0, (0.0, 15.0))\n# Solve the ODE using Rodas5P (suitable for stiff differential-algebraic systems)\nsol = solve(prob, Rodas5P());\n@assert SciMLBase.successful_retcode(sol) # ensure the simulation was successful\n\nThe simulation is complete! The sol object contains the time-domain solution of all network variables. We can now analyze how the system responded to the short circuit disturbance.\n\ntip: Tip\nThe ODEProblem contains a reference to exactly one copy of the flat parameter array. If you use callbacks to change those parameters (as we do), it is advised to copy the parameter array before passing it to the ODEProblem! Otherwise the callback will change our u0 object. Also, this means you need to be careful when using the same prob for multiple subsequent solve calls, as the initial state of the prob object might have changed!","category":"section"},{"location":"generated/ieee39_part3/#Simulation-Results-Overview","page":"IEEE39 Part III: Simulation","title":"Simulation Results Overview","text":"The solution object contains:\n\nTime-domain trajectories of all state variables (generator angles, voltages, etc.)\nNetwork interface variables (bus voltages, line currents and power flows)\nFull system response from t=0 to t=15 seconds\n\nLet's examine some key aspects of the system response through various plots.","category":"section"},{"location":"generated/ieee39_part3/#Results-Analysis","page":"IEEE39 Part III: Simulation","title":"Results Analysis","text":"","category":"section"},{"location":"generated/ieee39_part3/#Power-Flow-in-the-Affected-Line","page":"IEEE39 Part III: Simulation","title":"Power Flow in the Affected Line","text":"First, let's examine how the power flow through the faulted line changes during the disturbance. This plot shows the most direct impact of our short circuit and line disconnection events.\n\nlet fig = Figure(; size=(800, 400))\n    ax = Axis(fig[1, 1];\n        title=\"Active Power Flow in Line $AFFECTED_LINE During Short Circuit\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Active Power [pu]\")\n\n    # Focus on the disturbance period to see the fault clearly\n    ts = range(0, 0.35, length=1000)\n\n    # Plot power flow at the destination end of the line\n    lines!(ax, ts, sol(ts; idxs=EIndex(AFFECTED_LINE, :srcâ‚ŠP)).u;\n           label=\"Active Power towards src\", linewidth=2)\n    lines!(ax, ts, sol(ts; idxs=EIndex(AFFECTED_LINE, :dstâ‚ŠP)).u;\n           label=\"Active Power towards dst\", linewidth=2)\n\n    axislegend(ax; position=:rt)\n\n    fig\nend\n\nObservations:\n\nNormal operation (t < 0.1s): Steady power flow through the line. Power towards destination is positive while power towards source is negative. This means we have net transmission from bus 5 to bus 8.\nShort circuit (0.1s < t < 0.2s): Dramatic power flow change due to the short circuit. Both source and destination show negative power, which means we have active power flowing from both sides towards the short circuit.\nLine disconnection (t > 0.2s): Zero power flow as the line is permanently out of service\n\nThe power absorption during the fault demonstrates the severe electrical stress that short circuits place on the system. The protective relay action at t=0.2s successfully isolates the fault.","category":"section"},{"location":"generated/ieee39_part3/#Voltage-Response-at-Adjacent-Buses","page":"IEEE39 Part III: Simulation","title":"Voltage Response at Adjacent Buses","text":"Next, let's examine how the buses directly connected to the faulted line respond to the disturbance. These buses experience the most severe voltage impacts during the fault.\n\nlet fig = Figure(; size=(800, 500))\n    ax = Axis(fig[1, 1];\n        title=\"Voltage Magnitudes at Buses Adjacent to Faulted Line\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Voltage Magnitude [pu]\")\n\n    # Full simulation time to see both disturbance and recovery\n    ts = range(0, 15, length=1000)\n\n    # Get the source and destination buses of the affected line\n    src_bus, dst_bus = get_graphelement(nw[EIndex(AFFECTED_LINE)])\n\n    # Plot voltage magnitudes at both ends of the faulted line\n    lines!(ax, ts, sol(ts; idxs=VIndex(src_bus, :busbarâ‚Šu_mag)).u;\n           label=\"Bus $src_bus (source)\", linewidth=2)\n    lines!(ax, ts, sol(ts; idxs=VIndex(dst_bus, :busbarâ‚Šu_mag)).u;\n           label=\"Bus $dst_bus (destination)\", linewidth=2)\n\n    axislegend(ax; position=:rb)\n    ylims!(ax, 0.85, 1.15)\n\n    fig\nend\n\nObservations: Both buses experience voltage depression during the short circuit but are able to recover after the short circuit is cleared by disconnection of the line.\n\nThe voltage recovery demonstrates the system's ability to adapt to the new network topology after the line outage. The generators' automatic voltage regulators help maintain voltage stability.","category":"section"},{"location":"generated/ieee39_part3/#System-Wide-Voltage-Response","page":"IEEE39 Part III: Simulation","title":"System-Wide Voltage Response","text":"To get a complete picture of the system's response, let's examine the voltage profiles across all 39 buses. This \"spaghetti plot\" shows how the disturbance propagates through the entire network.\n\nlet fig = Figure(; size=(800, 600))\n    ax = Axis(fig[1, 1];\n        title=\"Voltage Magnitudes Across All 39 Buses\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Voltage Magnitude [pu]\")\n\n    # Full simulation time range\n    ts = range(0, 15, length=1000)\n\n    # Plot voltage magnitude for all buses\n    for i in 1:39\n        voltage_data = sol(ts; idxs=VIndex(i, :busbarâ‚Šu_mag)).u\n        lines!(ax, ts, voltage_data; linewidth=2)\n    end\n    ylims!(ax, 0.85, 1.15)\n    fig\nend\n\nOnce again, we see how all bus voltages are affected by the short circuit and the overall voltage drops. However, after the fault is cleared, the system achieves a synchronous steady-state again.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"initialization/#Powergrid-Initialization","page":"Initialization","title":"Powergrid Initialization","text":"Initialization of power grid simulations follows a multi-step approach that combines steady-state power flow analysis with dynamic component initialization. PowerDynamics.jl provides a structured framework for this process, building on the initialization capabilities of NetworkDynamics.jl.\n\nFor general background on NetworkDynamics initialization concepts, see the NetworkDynamics Initialization Guide.\n\nThis document is a technical description of the process, for a hands-on example which goes through the initialization process of a full network check out the Part II of the  the IEEE39 Bus Example.","category":"section"},{"location":"initialization/#Overview","page":"Initialization","title":"Overview","text":"Power grid initialization involves finding valid initial conditions that satisfy both:\n\nPower flow constraints: Electrical power balance equations (steady-state)\nDynamic constraints: Initial conditions for dynamic components (generators, controllers, etc.)\n\nThis is typically achieved through a two-step process:\n\nSolve the power flow problem to determine steady-state electrical conditions\nInitialize dynamic components using the power flow solution as boundary conditions, i.e. find the initial states/parameters of the dynamical models in a way, that they are in a steady state at the powerflow solution.\n\nThis follows the Two-Step Initialization Pattern described in NetworkDynamics.jl, specialized for power grid applications.","category":"section"},{"location":"initialization/#Multi-Step-Initialization-Process","page":"Initialization","title":"Multi-Step Initialization Process","text":"nw = get_dynamic_network(...)\n\n# extract powerflow model       # â«                 â«\npfnw = powerflow_model(nw)      # â”‚                 â”‚\n# initial guess for powerflow   # â¬ solve_powerflow â”‚\npfs0 = NWState(pfnw)            # â”‚                 â”‚\n# find fixpoint for pf model    # â”‚                 â”‚\npfs = find_fixpoint(pfnw, pfs0) # â­                 â¬ initialize_from_pf[!]\n# extract interface (u/i values)#                   â”‚\ninterf = interface_values(pfs)  #                   â”‚\n# initialize around powerflow   #                   â”‚\ninitialize_componentwise[!](    #                   â”‚\n    nw;                         #                   â”‚\n    default_overrides = interf  #                   â”‚\n)                               #                   â­\n\nThis low-level step-wise interface allows users full control and complete management of the initialization process. However, PowerDynamics.jl also provides higher-level wrapper functions solve_powerflow and initialize_from_pf that combine these steps for common use cases.\n\nNote: This workflow above is slightly simplified, see Integration with Initialization Process below for the full set of commands.","category":"section"},{"location":"initialization/#Step-1:-Power-Flow-Model-Extraction","page":"Initialization","title":"Step 1: Power Flow Model Extraction","text":"The first step creates a simplified, algebraic representation of the power grid that captures the essential power flow relationships:\n\npfnw = powerflow_model(nw)\n\nThis function extracts the power flow network from the full dynamic network model, creating a steady-state representation. The power flow network itself is also a Network in the NetworkDynamics.jl sense.\n\nThe powerflow_model function determines the appropriate power flow representation for each dynamic Node and LineModel by: checking if :pfmodel metadata is set, which points to a different component model specifically designed for power flow analysis\n\nIf the :pfmodel is not set, it assumes that the same model is used for both power flow and dynamic simulation. This is the case for purely static models such as PiLines or PQ-Loads.","category":"section"},{"location":"initialization/#Step-2:-Power-Flow-Solution","page":"Initialization","title":"Step 2: Power Flow Solution","text":"The power flow problem is solved using NetworkDynamics.jl's find_fixpoint function, which internally uses NonlinearSolve.jl:\n\npfs0 = NWState(pfnw)            # Initial guess for power flow state\npfs = find_fixpoint(pfnw, pfs0) # Solve power flow equations\n\nThis step finds the steady-state solution where:\n\nActive and reactive power are balanced at each bus\nGeneration and load are in equilibrium","category":"section"},{"location":"initialization/#Step-3:-Interface-Value-Extraction","page":"Initialization","title":"Step 3: Interface Value Extraction","text":"The power flow solution provides boundary conditions for dynamic component initialization:\n\ninterf = interface_values(pfs)\n\nThis extracts voltage magnitudes, voltage angles, and current flows at each network node, which serve as interface constraints for the dynamic components.","category":"section"},{"location":"initialization/#Step-4:-Component-wise-Dynamic-Initialization","page":"Initialization","title":"Step 4: Component-wise Dynamic Initialization","text":"Finally, each dynamic component is initialized individually using the power flow solution as boundary conditions:\n\ninitialize_componentwise!(nw; default_overrides = interf)\n\nThis step leverages NetworkDynamics.jl's component-wise initialization to determine free internal states and parameters (such as rotor angles or controller setpoints), such that the steady state of the overall network matches the flows from the power flow solution (i.e. all currents and voltages match).\n\nFor details on how component initialization works, see the Single Component Initialization section in NetworkDynamics.jl.","category":"section"},{"location":"initialization/#Advanced-Component-Initialization","page":"Initialization","title":"Advanced Component Initialization","text":"In some cases, the standard initialization process may not be sufficient. For example, when component initialization constraints cannot be expressed solely in terms of interface variables (voltages and currents), but need access to other variables from the complete power flow solution.\n\nNetworkDynamics.jl provides general InitFormulas and InitConstraints for advanced component initialization. PowerDynamics.jl extends these concepts with power flow-aware variants that can access the complete power flow solution.","category":"section"},{"location":"initialization/#PFInitConstraints-vs-PFInitFormulas","page":"Initialization","title":"PFInitConstraints vs PFInitFormulas","text":"Method Purpose Usage\nPFInitConstraint Add constraint equations that must be satisfied When you need to enforce specific relationships between variables\nPFInitFormula Set default initial values directly When you need to initialize variables based on power flow results\n\nBoth methods can access any variable from the solved power flow state, not just interface variables. You get access to states, parameters and observables from the power flow model of the same component.\n\nKey difference: Constraints increase the number of equations that must be satisfied during initialization, while formulas reduce the number of free variables by setting additional default values.\n\nThese are power flow-aware extensions of NetworkDynamics.jl's standard InitConstraint and InitFormula mechanisms.","category":"section"},{"location":"initialization/#Power-Flow-Dependent-Initialization-Constraints","page":"Initialization","title":"Power Flow Dependent Initialization Constraints","text":"PFInitConstraint adds constraint equations to the initialization problem. Unlike regular InitConstraints from NetworkDynamics.jl, PFInitConstraints can access power flow variables.\n\nThe @pfinitconstraint macro provides convenient syntax for defining these constraints:\n\n# Single constraint accessing both component and power flow variables\nconstraint = @pfinitconstraint :dynamicloadâ‚ŠP - @pf(:PQâ‚ŠPset)\n\n# Multiple constraints in a single block\nconstraints = @pfinitconstraint begin\n    :pibranchâ‚ŠX - @pf(:pibranchâ‚ŠX) # \"copy\" parameters from pf\n    :P_gen - @pf(:P_load)          # Power balance constraint\n    :AVRâ‚ŠVset - :busbarâ‚Šu_mag      # init controller setpoints\nend\n\n# Attach to a component\nset_pfinitconstraint!(my_generator, constraints)","category":"section"},{"location":"initialization/#Power-Flow-Dependent-Initialization-Formulas","page":"Initialization","title":"Power Flow Dependent Initialization Formulas","text":"PFInitFormula sets default initial values for variables using both component and power flow variables. Unlike constraints, formulas directly assign values without adding equations to solve.\n\nThe @pfinitformula macro provides convenient syntax:\n\n# Single formula - set variable from component variables\n@pfinitformula :Vset = sqrt(:u_r^2 + :u_i^2)\n\n# Formula using power flow variables\n@pfinitformula :Pset = @pf(:generator_power)\n\n# Multiple formulas in a block\n@pfinitformula begin\n    :Vset = sqrt(:u_r^2 + :u_i^2)\n    :Pset = @pf(:generator_power)\nend\n\n# Attach to a component\nset_pfinitformula!(my_generator, formulas)","category":"section"},{"location":"initialization/#Integration-with-Initialization-Process","page":"Initialization","title":"Integration with Initialization Process","text":"Both PFInitConstraints and PFInitFormulas are automatically handled during initialize_from_pf[!]:\n\nPower flow solution: The power flow equations are solved first\nSpecialization: All PFInitConstraints and PFInitFormulas are converted to regular InitConstraints and InitFormulas by \"specializing\" them with the power flow solution (i.e. the @pf(:x) blocks are replaced by the actual values)\nComponent initialization: The specialized constraints and formulas are passed to NetworkDynamics.jl's component initialization\n\nThis process is transparent to the user - simply define your power flow dependent initialization methods and use initialize_from_pf[!] as usual.\n\nThe underlying mechanism follows NetworkDynamics.jl's component initialization pipeline, with the power flow solution providing additional context for constraint and formula evaluation.\n\nThe extended initialization workflow (automatically done in initialize_from_pf[!]) looks like this:\n\nnw = get_dynamic_network(...)\npfnw = powerflow_model(nw)\npfs0 = NWState(pfnw)\npfs = find_fixpoint(pfnw, pfs0)\ninterf = interface_values(pfs)\n\n# specialize the constraints and formulas and pass them down\npfconstraints = specialize_pfinitconstraints(nw, pfs)\npfformulas    = specialize_pfinitformulas(nw, pfs)\ninitialize_componentwise[!](\n    nw;\n    default_overrides = interf,\n    additional_initconstraints = pfconstraints,\n    additional_initformulas = pfformulas,\n)","category":"section"},{"location":"generated/ieee39_part4/#ieee39-part4","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Bus Tutorial - Part IV: Advanced Modeling & Parameter Optimization","text":"This tutorial can be downloaded as a normal Julia script here.\n\nThis is the fourth and final part of the IEEE 39-bus tutorial series:\n\nPart I: Model Creation - Build the network structure with buses, lines, and components\nPart II: Initialization - Perform power flow calculations and dynamic initialization\nPart III: Dynamic Simulation - Run time-domain simulations and analyze system behavior\nPart IV: Advanced Modeling & Parameter Optimization (this tutorial) - Create custom components and optimize system parameters\n\nIn this tutorial, we'll demonstrate advanced PowerDynamics.jl capabilities by:\n\nCreating a custom droop-controlled inverter component\nIntegrating it into the IEEE 39-bus system\nOptimizing its parameters to improve system performance\n\nThis tutorial showcases custom component creation and the integration with Julia's optimization ecosystem for parameter tuning.\n\nnote: Note\nThis tutorial is designed as a pedagogical example. It does not necessarily represent a realistic power system model and analysis, but rather serves to demonstrate the available tools while remaining relatively simple and concise.\n\n# Loading required packages and setup\nusing PowerDynamics\nusing PowerDynamics.Library\nusing ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\nusing NetworkDynamics\nusing NetworkDynamics: SII\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing SciMLSensitivity\nusing Optimization\nusing OptimizationOptimisers\nusing CairoMakie\nusing LinearAlgebra\nusing Graphs\nusing SparseConnectivityTracer\nusing Sparspak\n\n# Load the network models from previous parts\nEXAMPLEDIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\")\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part1.jl\"))  # Creates the basic network model\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part3.jl\"))  # Provides initialized network and reference solution\nnothing #hide","category":"section"},{"location":"generated/ieee39_part4/#Integration-of-a-Droop-Controlled-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Integration of a Droop-Controlled Inverter","text":"In this section, we'll modify our network by adding a droop-controlled inverter.","category":"section"},{"location":"generated/ieee39_part4/#Mathematical-Background","page":"IEEE39 Part IV: Parameter Tuning","title":"Mathematical Background","text":"The droop-controlled inverter implements a decentralized control strategy commonly used in microgrids and renewable energy integration. It establishes the following relationships:\n\nPower Measurement:\n\nbeginaligned\nP_meas = u_r cdot i_r + u_i cdot i_i\nQ_meas = u_i cdot i_r - u_r cdot i_i\nendaligned\n\nPower Filtering (Low-pass filtering for measurement noise reduction):\n\nbeginaligned\ntau cdot fracdP_filtdt = P_meas - P_filt \ntau cdot fracdQ_filtdt = Q_meas - Q_filt\nendaligned\n\nDroop Control:\n\nbeginaligned\nomega = omega_0 - K_p cdot (P_filt - P_set) \nV = V_set - K_q cdot (Q_filt - Q_set)\nendaligned\n\nVoltage Angle Dynamics:\n\nfracddeltadt = omega - omega_0\n\nOutput Voltage:\n\nbeginaligned\nu_r = V cdot cos(delta) \nu_i = V cdot sin(delta)\nendaligned\n\nThese equations implement:\n\nFrequency-Active Power Coupling (f-P): Frequency decreases when active power exceeds setpoint\nVoltage-Reactive Power Coupling (V-Q): Voltage decreases when reactive power exceeds setpoint\n\nThis mimics the natural behavior of synchronous generators and enables stable power sharing in islanded operation.","category":"section"},{"location":"generated/ieee39_part4/#Definition-of-the-Droop-Inverter-Component","page":"IEEE39 Part IV: Parameter Tuning","title":"Definition of the Droop Inverter Component","text":"Network components in PowerDynamics must follow the Injector Interface - they connect to the network through a single Terminal:\n\n      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n(t)   â”‚                          â”‚\n oâ†â”€â”€â”€â”¤ Droop Inverter Equations â”‚\n      â”‚                          â”‚\n      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nWe can define the following MTKModel to represent the droop inverter:\n\n@mtkmodel DroopInverter begin\n    @components begin\n        terminal = Terminal()\n    end\n\n    @parameters begin\n        Pset, [description=\"Active power setpoint\", guess=1]\n        Qset, [description=\"Reactive power setpoint\", guess=0]\n        Vset, [description=\"Voltage magnitude setpoint\", guess=1]\n        Ï‰â‚€=1, [description=\"Nominal frequency\"]\n        Kp=1, [description=\"Active power droop coefficient\"]\n        Kq=0.1, [description=\"Reactive power droop coefficient\"]\n        Ï„_p = 1, [description=\"Active Power filter time constant\"]\n        Ï„_q = 1, [description=\"Reactive Power filter time constant\"]\n    end\n\n    @variables begin\n        Pmeas(t), [description=\"Measured active power\", guess=1]\n        Qmeas(t), [description=\"Measured reactive power\", guess=0]\n        Pfilt(t), [description=\"Filtered active power\", guess=1]\n        Qfilt(t), [description=\"Filtered reactive power\", guess=1]\n        Ï‰(t), [description=\"Frequency\"]\n        Î´(t), [description=\"Voltage angle\", guess=0]\n        V(t), [description=\"Voltage magnitude\"]\n    end\n\n    @equations begin\n        # Power measurement from terminal quantities\n        Pmeas ~ terminal.u_r*terminal.i_r + terminal.u_i*terminal.i_i\n        Qmeas ~ terminal.u_i*terminal.i_r - terminal.u_r*terminal.i_i\n\n        # First-order low-pass filtering\n        Ï„_p * Dt(Pfilt) ~ Pmeas - Pfilt\n        Ï„_q * Dt(Qfilt) ~ Qmeas - Qfilt\n\n        # Droop control equations\n        Ï‰ ~ Ï‰â‚€ - Kp * (Pfilt - Pset)  # Frequency decreases with excess power\n        V ~ Vset - Kq * (Qfilt - Qset)  # Voltage decreases with excess reactive power\n\n        # Voltage angle dynamics\n        Dt(Î´) ~ Ï‰ - Ï‰â‚€\n\n        # Output voltage components\n        terminal.u_r ~ V*cos(Î´)\n        terminal.u_i ~ V*sin(Î´)\n    end\nend;\nnothing #hide","category":"section"},{"location":"generated/ieee39_part4/#Creating-a-Bus-with-the-Droop-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Creating a Bus with the Droop Inverter","text":"Following the descriptions in Modeling Concepts, we build an MTKBus using the droop as the single injector and then compile the bus model, similar to how we define the templates in part I:\n\n           â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n           â•‘ Droop (compiled)        â•‘\n Network   â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘\ninterface  â•‘  â”‚ MTKBus             â”‚ â•‘\n current â”€â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â•‘\n           â•‘  â”‚â”‚BusBarâ”œoâ”¤Inverterâ”‚ â”‚ â•‘\n voltage â†â”€â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â•‘\n           â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘\n           â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n@named inverter = DroopInverter()\nmtkbus = MTKBus(inverter)\ndroop_bus_template = compile_bus(mtkbus; name=:DroopInverter)\n\nWe see that the droop inverter has 3 free parameters (you can check free_p(droop_bus_template) or dump_initial_state(droop_bus_template)). Therefore, similar to what we did in Part II, we need to help the initialization by attaching an additional initialization formula to the bus:\n\nset_initformula!(\n    droop_bus_template,\n    @initformula(:inverterâ‚ŠVset = sqrt(:busbarâ‚Šu_r^2 + :busbarâ‚Šu_i^2))\n)\nnothing #hide","category":"section"},{"location":"generated/ieee39_part4/#Network-Modification-with-Droop-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Network Modification with Droop Inverter","text":"We'll replace bus 32 (originally a controlled generator bus) with our new droop inverter bus.\n\nDROOP_BUS_IDX = 32\nnothing #hide\n\nTo do so, we first collect all the \"old\" vertex and edge models.\n\ntip: Tip\nWe copy the components, to create individual instances for the new network. Since all the metadata (like the default values, initialize values and so on) are stored in the component models, we would otherwise share metadata between the old and the new network, which can lead to unexpected results.\n\nvertex_models = [copy(nw[VIndex(i)]) for i in 1:nv(nw)];\nedge_models = [copy(nw[EIndex(i)]) for i in 1:ne(nw)];\nnothing #hide\n\nNow we need to replace the original bus model at index DROOP_BUS_IDX with our new droop inverter bus. However, we don't want to lose the original power flow model associated with this bus, so we need to attach it to the droop bus model:\n\noriginal_pfmodel = get_pfmodel(vertex_models[DROOP_BUS_IDX])\nnothing #hide\n\nWe can then use the Bus constructor to essentially copy the droopbustemplate and adjust some properties, like the powerflow model and the vertex index.\n\ndroop_bus = compile_bus(droop_bus_template; pf=original_pfmodel, vidx=DROOP_BUS_IDX)\n\nWe then replace the original bus model in the array with our droop bus and build a network again:\n\nvertex_models[DROOP_BUS_IDX] = droop_bus\nnw_droop = Network(vertex_models, edge_models)\nset_jac_prototype!(nw_droop; remove_conditions=true)\n\nAdditionally, we've set the jacobian prototype for performance gains during simulation and optimization, see NetworkDynamics docs on Sparsity Detection.","category":"section"},{"location":"generated/ieee39_part4/#Network-Initialization-with-Droop-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Network Initialization with Droop Inverter","text":"The modified network requires the same initialization steps as the original:\n\nPower flow solution\nDynamic component initialization\n\nThis all happens within initialize_from_pf!:\n\ns0_droop = initialize_from_pf!(nw_droop; verbose=false)\nnothing #hide\n\nLet's examine the initialized state of our droop inverter:\n\ndump_initial_state(nw_droop[VIndex(DROOP_BUS_IDX)]; obs=false)\n\nWe see that the filtered powers match the setpoints (steady state), and both P and V_mathrmset are initialized according to the parameters of the PV powerflow model.","category":"section"},{"location":"generated/ieee39_part4/#Simulation-with-Droop-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Simulation with Droop Inverter","text":"Now we'll simulate the modified network and compare it with the original system response:\n\nprob_droop = ODEProblem(nw_droop, s0_droop, (0.0, 15.0))\nsol_droop = solve(prob_droop, Rodas5P())\n@assert SciMLBase.successful_retcode(sol_droop)","category":"section"},{"location":"generated/ieee39_part4/#Comparison-of-System-Responses","page":"IEEE39 Part IV: Parameter Tuning","title":"Comparison of System Responses","text":"Let's compare how the droop inverter affects the system's response to the short circuit disturbance:\n\nlet fig = Figure(; size=(1000, 600))\n    selected_buses = [3, 4, 25, DROOP_BUS_IDX]  # Representative buses including the droop bus\n    ts = range(0, 10, length=1000)\n\n    for (i, bus) in enumerate(selected_buses)\n        row, col = divrem(i-1, 2) .+ (1, 1)\n        ax = Axis(fig[row, col];\n                  title=\"Voltage Magnitude at Bus $bus\" * (bus==DROOP_BUS_IDX ? \" (droop bus)\" : \"\"),\n                  xlabel=\"Time [s]\",\n                  ylabel=\"Voltage [pu]\")\n\n        # Original system response\n        lines!(ax, ts, sol(ts; idxs=VIndex(bus, :busbarâ‚Šu_mag)).u;\n               label=\"Original System\", color=:blue, linewidth=2)\n\n        # Droop inverter system response\n        lines!(ax, ts, sol_droop(ts; idxs=VIndex(bus, :busbarâ‚Šu_mag)).u;\n               label=\"With Droop Inverter\", color=:red, linewidth=2)\n\n        ylims!(ax, 0.85, 1.15)\n        i == 1 && axislegend(ax; position=:rb)\n    end\n\n    fig\nend\n\nWe see that the overall system reacts similarly but distinctly differently to the identical disturbance.","category":"section"},{"location":"generated/ieee39_part4/#Parameter-Optimization","page":"IEEE39 Part IV: Parameter Tuning","title":"Parameter Optimization","text":"To showcase advanced capabilities of the SciML-ecosystem and the integration with PowerDynamics.jl, we now want to try to tune the droop inverter parameters so that the overall system behavior more closely resembles the original behavior, i.e., to reduce the difference between the system with generator and the system with droop inverter.","category":"section"},{"location":"generated/ieee39_part4/#Optimization-Problem-Formulation","page":"IEEE39 Part IV: Parameter Tuning","title":"Optimization Problem Formulation","text":"We define a loss function that measures the deviation between the original system response and the modified system response:\n\nL(p) = sum_it x_ref(t)_i - x(tp)_i^2\n\nWhere we have\n\nParameters p = K_p K_q tau to be optimized\nthe reference solution x_ref(t) (original system)\nthe solution of the modified system x(tp) with updated parameters p\n\nGoal: Find parameters p that minimize this loss function, making the droop inverter system behave as closely as possible to the original system.","category":"section"},{"location":"generated/ieee39_part4/#Setting-Up-the-Optimization","page":"IEEE39 Part IV: Parameter Tuning","title":"Setting Up the Optimization","text":"First, we define the reference solution and identify the tunable parameters.\n\nWe probe the original solution at fixed timepoints, exporting u_r and u_i for every bus:\n\nopt_ref = sol(0.3:0.1:10, idxs=[VIndex(1:39, :busbarâ‚Šu_r), VIndex(1:39, :busbarâ‚Šu_i)])\nnothing #hide\n\nNext, we need to identify the \"tunable\" parameters. This is a bit tricky, because the overall nw_droop has 1271 parameters, so we need to find the indices of the parameters we want to tune in the flat parameter array. We can do so, by leveraging NetworkDynamics implementation of the SymbolicIndexingInterface: tunable_parameters = [:inverterâ‚ŠKp, :inverterâ‚ŠKq, :inverterâ‚ŠÏ„]\n\ntunable_parameters = [:inverterâ‚ŠKp, :inverterâ‚ŠKq, :inverterâ‚ŠÏ„_p, :inverterâ‚ŠÏ„_q]\ntp_idx = SII.parameter_index(sol_droop, VIndex(DROOP_BUS_IDX, tunable_parameters))\n\nWe also get their initial values, which we use as the starting point for the optimization.\n\np0 = sol_droop(sol_droop.t[begin], idxs=collect(VIndex(DROOP_BUS_IDX, tunable_parameters)))","category":"section"},{"location":"generated/ieee39_part4/#Loss-Function-Implementation","page":"IEEE39 Part IV: Parameter Tuning","title":"Loss Function Implementation","text":"The loss function simulates the system with given parameters and compares the result to the reference:\n\nfunction loss(p)\n    # Create parameter vector for the full system\n    # allp = similar(p, pdim(nw_droop)) # create a vector of the full length\n    allp = similar(p, length(s0_droop.p)) # create a vector of the full length\n    allp .= pflat(s0_droop.p) # copy all \"initial\" parameters to that vector\n    allp[tp_idx] .= p  # Update only the tunable parameters with the parameters for the given optimization iteration\n\n    # Solve the system with new parameters\n    _sol = solve(prob_droop, Rodas5P(autodiff=true);\n        p = allp,\n        saveat = opt_ref.t,\n        tspan=(0.0, opt_ref.t[end]),\n        initializealg = SciMLBase.NoInit(),\n        abstol=0.01,\n        reltol=0.01\n    )\n\n    # Return infinite loss if simulation failed\n    if !SciMLBase.successful_retcode(_sol)\n        @warn \"Retcode $(_sol.retcode) indicates a failed simulation, returning Inf loss\"\n        return Inf\n    end\n\n    # Extract solution at reference time points\n    x = _sol(opt_ref.t; idxs=[VIndex(1:39, :busbarâ‚Šu_r), VIndex(1:39, :busbarâ‚Šu_i)])\n\n    # Compute L2 norm of the difference\n    res = opt_ref.u - x.u\n    l2loss = sum(abs2, reduce(vcat, res))\nend\nnothing #hide","category":"section"},{"location":"generated/ieee39_part4/#Optimization-Execution","page":"IEEE39 Part IV: Parameter Tuning","title":"Optimization Execution","text":"We use the Optimization.jl ecosystem with the Adam optimizer:\n\n# Create optimization function with automatic differentiation\noptf = Optimization.OptimizationFunction((x, p) -> loss(x), Optimization.AutoForwardDiff())\nnothing #hide\n\nTo better monitor the optimization progress, we want to store the optimized parameters at every iteration of the optimizer. We can do so by defining a callback function for the optimizer:\n\noptimization_states = Any[] # global variable to store the optimization parameters at each step\ncallback = function (state, l)\n    push!(optimization_states, state)\n    println(\"Iteration $(state.iter): loss = $l\\t p = $(state.u)\")\n    return false  # Continue optimization\nend\nnothing #hide\n\nThat callback will snapshot the current parameter values at every step of the gradient descent.\n\nWith that, we can run the optimization:\n\noptprob = Optimization.OptimizationProblem(optf, p0; callback)\nVERBOSE_CALLBACK = false #hide\n\n@time optsol = Optimization.solve(optprob, Optimisers.Adam(0.06), maxiters = 50)\n\nprintln(\"\\nOptimization completed!\")\nprintln(\"Initial parameters: \", p0)\nprintln(\"Optimized parameters: \", optsol.u)\nprintln(\"Initial loss: \", loss(p0))\nprintln(\"Final loss: \", loss(optsol.u))\nnothing #hide","category":"section"},{"location":"generated/ieee39_part4/#Optimization-Results-Analysis","page":"IEEE39 Part IV: Parameter Tuning","title":"Optimization Results Analysis","text":"Let's visualize how the optimization improved the system behavior:\n\nfunction plot_optimization_comparison(p_initial, p_current)\n    fig = Figure(; size=(1200, 800))\n    selected_buses = [3, 4, 25, DROOP_BUS_IDX]\n    ts = range(0, 10, length=1000)\n\n    # Simulate with optimized parameters\n    allp_opt = @lift let\n        _p = copy(pflat(s0_droop))\n        _p[tp_idx] .= $p_current\n        _p\n    end\n    sol_opt = @lift solve(prob_droop, Rodas5P(); p=$allp_opt)\n\n\n    for (i, bus) in enumerate(selected_buses)\n        row, col = divrem(i-1, 2) .+ (1, 1)\n        ax = Axis(fig[row, col];\n                  title=\"Voltage Magnitude at Bus $bus\" * (bus==DROOP_BUS_IDX ? \" (droop bus)\" : \"\"),\n                  xlabel=\"Time [s]\",\n                  ylabel=\"Voltage [pu]\")\n\n        # Reference (original system)\n        lines!(ax, ts, sol(ts; idxs=VIndex(bus, :busbarâ‚Šu_mag)).u;\n               label=\"Reference\", linestyle=:solid, color=:blue, linewidth=2)\n\n        # Initial droop parameters\n        lines!(ax, ts, sol_droop(ts; idxs=VIndex(bus, :busbarâ‚Šu_mag)).u;\n               label=\"Initial Droop\", linestyle=:dash, color=:red, linewidth=2)\n\n        # Optimized droop parameters\n        dat = @lift $(sol_opt)(ts; idxs=VIndex(bus, :busbarâ‚Šu_mag)).u\n        lines!(ax, ts, dat; label=\"Optimized Droop\", color=:green, linewidth=2)\n\n        ylims!(ax, 0.85, 1.15)\n        i == 1 && axislegend(ax; position=:rb)\n    end\n\n    fig\nend\n\npobs = Observable(p0)\ncomparison_fig = plot_optimization_comparison(p0, pobs)\nrecord(comparison_fig, \"parameter_evolution.mp4\", optimization_states; framerate=10) do s\n    pobs[] = s.u\nend\nnothing #hide\n\n(Image: timeseries evolution animation)","category":"section"},{"location":"generated/ieee39_part4/#Parameter-Evolution-During-Optimization","page":"IEEE39 Part IV: Parameter Tuning","title":"Parameter Evolution During Optimization","text":"Let's see how each parameter changed during the optimization process:\n\nlet fig = Figure(; size=(1000, 800))\n    param_names = [\"Kp\", \"Kq\", \"Ï„_p\", \"Ï„_q\"]\n    for (i, param_name) in enumerate(param_names)\n        row = (i-1) Ã· 2 + 1\n        col = (i-1) % 2 + 1\n        ax = Axis(fig[row, col];\n                  title=\"Parameter Evolution: $param_name\",\n                  xlabel=\"Iteration\",\n                  ylabel=\"Parameter Value\")\n\n        # Extract parameter values over iterations\n        param_values = [state.u[i] for state in optimization_states[1:end-1]]\n        iterations = [state.iter for state in optimization_states[1:end-1]]\n\n        scatterlines!(ax, iterations, param_values; linewidth=3, markersize=6, color=:blue)\n\n        # Mark initial and final values\n        hlines!(ax, [p0[i]]; linestyle=:dash, color=:gray, alpha=0.7)\n        text!(ax, 1, p0[i]; text=\"Initial: $(round(p0[i], digits=3))\",\n              fontsize=10, color=:gray)\n\n        lossax = Axis(fig[row, col],\n            yticklabelcolor=:black,\n            yaxisposition = :right,\n            ylabel=\"loss\", yscale=log10,\n            xgridvisible=false, ygridvisible=false\n        )\n        scatterlines!(\n            lossax,\n            iterations,\n            [loss(s.u) for s in optimization_states[1:end-1]],\n            color=:black, linewidth=1, markersize=3,\n        )\n    end\n    fig\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"ModelingConcepts/#Modeling-Concepts","page":"Modeling Concepts","title":"Modeling Concepts","text":"In general, PowerDynamics models power grids as a set of dynamical systems for both nodes and edges on a graph. Check out the Mathematical Model documentation of NetworkDynamics for the underlying concepts.\n\nThe simulation happens entirely in a synchronous dq-frame. Due to their conceptual similarity to complex phasors, variables in this global dq-frame are referenced by subscripts _r and _i (for real and imaginary). This helps distinguish the variables from local dq frames, e.g. a generator model might transform u_r and u_i into u_d and u_q.\n\nBoth edge and node models are so-called input-output-systems: the edges receive the voltage of adjacent nodes as an input, the nodes receive the currents on adjacent edges as an input. In general, this leads to the following structure of a bus/node model:\n\nbeginaligned\nM_mathrm vfracmathrmdmathrmdtx_mathrm v = f_mathrm vleft(x_mathrm v sum_kbeginbmatrixi^k_r i^k_iendbmatrix p_mathrm v tright)\nbeginbmatrixu_r u_iendbmatrix = g_mathrm v(x_mathrm vp_mathrm v t)\nendaligned\n\nwhere M_mathrm v is the (possibly singular) mass-matrix, x_mathrm v are the internal states and p_mathrm v are parameters. Function f_mathrm v describes the time evolution of the internal states while output equation g_mathrm v defines the output voltage. The input for the system is the sum of all inflowing currents from adjacent lines k. Note how vertices are modeled as one-port systems; i.e., they receive the accumulated current from all connected lines, they can't distinguish which line provides which current. For special cases, this limitation might be mitigated using External Inputs.\n\nnote: Nodal dynamics include injectors\nAn important distinction between our modeling and the modeling in many other libraries is that we include the injector dynamics inside the node dynamics. I.e. if you have a bus with a load and a generator, the overall node dynamics will include both machine and load dynamics within their equations. The modularity and model reuse on the bus level is provided by ModelingToolkit.jl integration.\n\nThe edge model on the other hand looks like this:\n\nbeginaligned\nM_mathrm efracmathrmdmathrmdtx_mathrm e = f_mathrm eleft(x_mathrm e beginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix beginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrixp_mathrme tright)\nbeginbmatrixi_r^mathrmsrci_i^mathrmsrcendbmatrix = g^mathrmsrc_mathrm eleft(x_mathrm e beginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix beginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrix p_mathrme tright)\nbeginbmatrixi_r^mathrmdsti_i^mathrmdstendbmatrix = g^mathrmdst_mathrm eleft(x_mathrm e beginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix beginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrix p_mathrme tright)\nendaligned\n\nThere are a few notable differences compared to bus models: Edges are two-port systems, they have two distinct inputs and two distinct outputs. Namely, they receive the dq voltage from both source and destination end, and define the current for both ends separately. In very simple systems without losses, those output currents might be just antisymmetric, in general cases however the current on both ends can differ drastically.\n\nnote: Note\nSource and destination end of a line are purely conventional. It has nothing to do with the actual flow direction. Per convention from Graphs.jl, edges in undirected graphs always go from vertex with lower index to vertex with higher index, i.e. 15 to 23 never 23 to 15.\n\nThe above descriptions are important to understand what's happening inside the package. However, since we use ModelingToolkit to define the individual models a lot of this complexity is hidden from the user. In the following, we'll go through the most important concepts when designing models using ModelingToolkit.","category":"section"},{"location":"ModelingConcepts/#Relationship-between-ModelingToolkit-and-NetworkDynamics","page":"Modeling Concepts","title":"Relationship between ModelingToolkit and NetworkDynamics","text":"A crucial part of using this library is understanding the relationship between ModelingToolkit models and NetworkDynamics.\n\nIn a nutshell, ModelingToolkit models are symbolic models; i.e., they consist of symbolic equations which are not yet \"compiled\" for use as a numeric model. The modeling in MTK is very flexible and similar to the Modelica language. What we need in the end is models in the structure defined in the equations above. For that, we need the MTK models to have a specific structure. Then we can use the compile_bus and compile_line function to compile the MTK models and create EdgeModel and VertexModel objects from them. Those objects are not symbolic anymore but compiled numeric versions of the symbolically created systems.","category":"section"},{"location":"ModelingConcepts/#ModelingToolkit-Models","page":"Modeling Concepts","title":"ModelingToolkit Models","text":"","category":"section"},{"location":"ModelingConcepts/#Terminal","page":"Modeling Concepts","title":"Terminal","text":"The Terminal-Connector is an important building block for every model. It represents a connection point with constant voltage in dq-coordinates u_r and u_i and enforces the Kirchhoff constraints sum(i_r)=0 and sum(i_i)=0.","category":"section"},{"location":"ModelingConcepts/#Modeling-of-Buses","page":"Modeling Concepts","title":"Modeling of Buses","text":"","category":"section"},{"location":"ModelingConcepts/#Injector-Interface","page":"Modeling Concepts","title":"Model class Injector","text":"An injector is a class of components with a single Terminal() (called :terminal). Examples for injectors might be Generators, Shunts, Loads.\n\n(t)   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n oâ†â”€â”€â”€â”¤ Injector â”‚\n      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nThe current for injectors is always in injector convention; i.e., positive currents flow out of the injector towards the terminal.\n\nnote: Model classes\nModel \"classes\" are nothing formalized. In this document, a model class is just a description for some System from ModelingToolkit.jl, which satisfies certain requirements. For example, any System is considered an \"Injector\" if it contains a connector Terminal() called :terminal.\n\nYou can check if a model satisfies the injector interface using the isinjectormodel function.\n\ndetails: Code example: definition of PQ load as injector\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\n@mtkmodel MyPQLoad begin\n    @components begin\n        terminal = Terminal()\n    end\n    @parameters begin\n        Pset, [description=\"Active Power demand\"]\n        Qset, [description=\"Reactive Power demand\"]\n    end\n    @variables begin\n        P(t), [description=\"Active Power\"]\n        Q(t), [description=\"Reactive Power\"]\n    end\n    @equations begin\n        P ~ terminal.u_r*terminal.i_r + terminal.u_i*terminal.i_i\n        Q ~ terminal.u_i*terminal.i_r - terminal.u_r*terminal.i_i\n        # if possible, it's better for the solver to explicitly provide algebraic equations for the current\n        terminal.i_r ~ (Pset*terminal.u_r + Qset*terminal.u_i)/(terminal.u_r^2 + terminal.u_i^2)\n        terminal.i_i ~ (Pset*terminal.u_i - Qset*terminal.u_r)/(terminal.u_r^2 + terminal.u_i^2)\n    end\nend\nMyPQLoad(name=:pqload) #hide\nnothing #hide","category":"section"},{"location":"ModelingConcepts/#MTKBus-Interface","page":"Modeling Concepts","title":"Model class MTKBus","text":"A MTKBus is a class of models, which are used to describe the dynamic behavior of a full bus in a power grid. Each MTKBus must contain a predefined model of type BusBar() (named :busbar). This busbar represents the connection point to the grid. Optionally, it may contain various injectors. If there are no injectors, the model just describes a junction bus; i.e., a bus that just satisfies the Kirchhoff constraint for the flows of connected lines.\n\n â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n â”‚ MTKBus             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚\n â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”¤ Generator â”‚  â”‚\n â”‚  â”‚          â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚\n â”‚  â”‚  BusBar  â”œâ”€â”€â”€o                 â”‚\n â”‚  â”‚          â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚\n â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”¤ Load      â”‚  â”‚\n â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚\n â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nSometimes it is not possible to connect all injectors directly but instead one needs or wants Branches between the busbar and injector terminal. As long as the :busbar is present at the toplevel, there are few limitations on the overall model complexity.\n\nFor simple models (direct connections of a few injectors), it is possible to use the convenience method MTKBus(injectors...) to create the composite model based on provided injector models.\n\nYou can check if a model satisfies the bus interface using the isbusmodel function.\n\ndetails: Code example: definition of a Bus containing a swing equation and a load\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\n@mtkmodel MyMTKBus begin\n    @components begin\n        busbar = BusBar()\n        swing = Swing()\n        load = PQLoad()\n    end\n    @equations begin\n        connect(busbar.terminal, swing.terminal)\n        connect(busbar.terminal, load.terminal)\n    end\nend\nMyMTKBus(name=:bus) #hide\nnothing #hideAlternatively, for that system you could have just calledmybus = MTKBus(Swing(;name=:swing), PQLoad(;name=:load))\nnothing #hideto get an instance of a model which is structurally equivalent to MyMTKBus.","category":"section"},{"location":"ModelingConcepts/#Line-Modeling","page":"Modeling Concepts","title":"Line Modeling","text":"","category":"section"},{"location":"ModelingConcepts/#Branch-Interface","page":"Modeling Concepts","title":"Model class Branch","text":"A branch is the two-port equivalent to an injector. It needs to have two Terminal()s, one is called :src, the other :dst.\n\nExamples for branches are: PI-model branches, dynamic RL branches or transformers.\n\n(src) â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” (dst)\n  oâ†â”€â”€â”¤  Branch  â”œâ”€â”€â†’o\n      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nBoth ends follow the injector interface; i.e., current leaving the device towards the terminals is always positive.\n\nYou can check if a model satisfies the branch interface using the isbranchmodel function.\n\ndetails: Code example: algebraic R-line\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\n@mtkmodel MyRLine begin\n    @components begin\n        src = Terminal()\n        dst = Terminal()\n    end\n    @parameters begin\n        R=0, [description=\"Resistance\"]\n    end\n    @equations begin\n        dst.i_r ~ (dst.u_r - src.u_r)/R\n        dst.i_i ~ (dst.u_i - src.u_i)/R\n        src.i_r ~ -dst.i_r\n        src.i_i ~ -dst.i_i\n    end\nend\nMyRLine(name=:rline) #hide\nnothing #hide","category":"section"},{"location":"ModelingConcepts/#MTKLine-Interface","page":"Modeling Concepts","title":"Model class: MTKLine","text":"Similar to the MTKBus, a MTKLine is a model class which represents a transmission line in the network.\n\nIt must contain two LineEnd() instances, one called :src, one called :dst.\n\n â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n â”‚ MTKLine          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚\n â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”¤ Branch A â”œâ”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚\n â”‚  â”‚ LineEnd â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚ LineEnd â”‚  â”‚\n â”‚  â”‚  :src   â”œâ”€â”€o                oâ”€â”€â”¤  :dst   â”‚  â”‚\n â”‚  â”‚         â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚         â”‚  â”‚\n â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”¤ Branch B â”œâ”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚\n â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚\n â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nSimple line models, which consist only of valid Branch models, can be instantiated using the MTKLine(branches...) constructor.\n\nMore complex models can be created manually. For example, you could define a dynamic multi-branch DC line model by chaining (possibly very complex and nested) source and destination inverter/rectifier models with one or many dc branches.\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ MTKLine                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚\nâ”‚                       â”Œâ”¤ DC Br. A â”œâ”                      â”‚\nâ”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚\nâ”‚â”‚ LineEnd â”œâ”€â”¤ src inv â”œo            oâ”¤ dst inv â”œâ”¤ LineEnd â”‚â”‚\nâ”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚\nâ”‚   :src                â””â”¤ DC Br. B â”œâ”˜              :dst    â”‚\nâ”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nYou can check if a model satisfies the line interface using the islinemodel function.\n\ndetails: Code example: Transmission line with two pi-branches\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\n@mtkmodel MyMTKLine begin\n    @components begin\n        src = LineEnd()\n        dst = LineEnd()\n        branch1 = PiLine()\n        branch2 = PiLine()\n    end\n    @equations begin\n        connect(src.terminal, branch1.src)\n        connect(src.terminal, branch2.src)\n        connect(dst.terminal, branch1.dst)\n        connect(dst.terminal, branch2.dst)\n    end\nend\nMyMTKLine(name=:mtkline) #hide\nnothing #hideAlternatively, an equivalent model with multiple valid branch models in parallel could be created and instantiated with the convenience constructorline = MTKLine(PiLine(;name=:branch1), PiLine(;name=:branch2))\nnothing #hide","category":"section"},{"location":"ModelingConcepts/#From-MTK-Models-to-NetworkDynamics","page":"Modeling Concepts","title":"From MTK Models to NetworkDynamics","text":"Both MTKLine and MTKBus are still purely symbolic ModelingToolkit models. However, they have an important property: they possess the correct input-output structure and variable names to be compiled into VertexModel and EdgeModel models. To do so, PowerDynamics.jl provides the compile_line and compile_bus functions.\n\nAt their core, both compile_* functions use ModelingToolkit's mtkcompile to perform symbolic simplifications on your models and reduce the number of states. Most notably, this process can drastically reduce the number of equations, while all previously defined states remain \"observable\", i.e. inspectable after simulation. For example, in the above code example of the PQ load we defined equations for active and reactive powers P and Q. Those equations don't add anything to the actual behavior of the system, however they will be kept around as so-called \"observed\" states, meaning we can reconstruct and plot them from dynamical simulations.\n\ntip: Tip: Introduce states of interest as observables\nIt is often useful to add derived quantities of interest explicitly to your models. For example, if you're interested in some internal voltage angle just define an equation u_angle ~ atan(u_d, u_q). If nothing else depends on it, this equation will be symbolically reduced,  i.e. you don't add any overhead to your simulation but it will be accessible after the simulation.  This is often far more convenient than \"reconstructing\" such states manually!","category":"section"},{"location":"ModelingConcepts/#(MTK)-Bus-Model-to-VertexModel:-compile_bus","page":"Modeling Concepts","title":"(MTK) Bus Model to VertexModel: compile_bus","text":"                                      â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n                                      â•‘ VertexModel (compiled)  â•‘\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      Network   â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘\nâ”‚MTKBus   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚     interface  â•‘  â”‚MTKBus   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â•‘\nâ”‚        â”Œâ”¤Generatorâ”‚â”‚                â•‘  â”‚        â”Œâ”¤Generatorâ”‚â”‚ â•‘\nâ”‚â”Œâ”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚      current â”€â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â•‘\nâ”‚â”‚BusBarâ”œo           â”‚  =>            â•‘  â”‚â”‚BusBarâ”œo           â”‚ â•‘\nâ”‚â””â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”     â”‚      voltage â†â”€â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”     â”‚ â•‘\nâ”‚        â””â”¤Loadâ”‚     â”‚                â•‘  â”‚        â””â”¤Loadâ”‚     â”‚ â•‘\nâ”‚         â””â”€â”€â”€â”€â”˜     â”‚                â•‘  â”‚         â””â”€â”€â”€â”€â”˜     â”‚ â•‘\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘\n                                      â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•","category":"section"},{"location":"ModelingConcepts/#(MTK)-Line-Model-to-EdgeModel:-compile_line","page":"Modeling Concepts","title":"(MTK) Line Model to EdgeModel: compile_line","text":"\n                                        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n                                        â•‘ EdgeModel (compiled)         â•‘\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     src â•‘ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘ dst\nâ”‚MTKLine   â”Œâ”€â”€â”€â”€â”€â”€â”€â”          â”‚  vertex â•‘ â”‚MTKLine   â”Œâ”€â”€â”€â”€â”          â”‚ â•‘ vertex\nâ”‚         â”Œâ”¤BranchAâ”œâ”         â”‚         â•‘ â”‚         â”Œâ”¤    â”œâ”         â”‚ â•‘\nâ”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚     u â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â†â”€â”€â”€ u\nâ”‚â”‚LineEndâ”œo         oâ”¤LineEndâ”‚â”‚  =>     â•‘ â”‚â”‚LineEndâ”œo      oâ”¤LineEndâ”‚â”‚ â•‘\nâ”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚     i â†â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”€â”€â”€â†’ i\nâ”‚  :src   â””â”¤BranchBâ”œâ”˜  :dst   â”‚         â•‘ â”‚         â””â”¤    â”œâ”˜         â”‚ â•‘\nâ”‚          â””â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚         â•‘ â”‚          â””â”€â”€â”€â”€â”˜          â”‚ â•‘\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â•‘ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘\n                                        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•","category":"section"},{"location":"ModelingConcepts/#End-to-End-Example","page":"Modeling Concepts","title":"End to End Example","text":"Putting the knowledge from this document together, we can start a short simulation of an example network:\n\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\nusing Graphs, NetworkDynamics\nusing OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\nnothing #hide\n\nFirst, we define an MTKBus consisting of two predefined injector models from the library: a Swing generator model and a PQLoad. To do so, we use the MTKBus(injectors...) constructor.\n\n@named swing = Swing(; Pm=1, V=1, D=0.1)\n@named load = PQLoad(; Pset=-.5, Qset=0)\nbus1mtk = MTKBus(swing, load; name=:swingbus)\nshow(stdout, MIME\"text/plain\"(), bus1mtk) #hide\n\nThis results in an MTK model, which fulfills the MTKBus interface and thus can be compiled into an actual VertexModel for simulation:\n\nvertex1f = compile_bus(bus1mtk) # extract component function\n\nAs a second bus in this example, we use a SlackDifferential from the library. This model is not an Injector but an MTKBus directly, as it does not make sense to connect anything else to a slack bus.\n\nbus2mtk = SlackDifferential(; name=:slackbus)\nvertex2f = compile_bus(bus2mtk) # extract component function\n\nFor the connecting line, we instantiate two PiLine from the library. Each PiLine fulfills the Branch interface. Therefore we can define a MTKLine model by putting both Branches in parallel:\n\n@named branch1 = PiLine()\n@named branch2 = PiLine()\nlinemtk = MTKLine(branch1, branch2; name=:powerline)\nshow(stdout, MIME\"text/plain\"(), bus1mtk) #hide\n\nSimilar to before, we need to compile the MTKModel by calling compile_line.\n\nedgef = compile_line(linemtk) # extract component function\n\nTo simulate the system, we place both components on a graph and define their network topology. We define both graph topology as well as the models for the individual components.\n\ng = complete_graph(2)\nnw = Network(g, [vertex1f, vertex2f], edgef)\nu0 = NWState(nw) # extract parameters and state from models\nu0.v[1, :swingâ‚ŠÎ¸] = 0 # set missing initial conditions\nu0.v[1, :swingâ‚ŠÏ‰] = 1\nnothing #hide\n\nThen we can solve the problem\n\nprob = ODEProblem(nw, u0, (0,1))\nsol = solve(prob, Rodas5P())\n@assert OrdinaryDiffEqRosenbrock.SciMLBase.successful_retcode(sol) #hide\nnothing #hide\n\nAnd finally we can plot the solution:\n\nfig = Figure();\nax = Axis(fig[1,1])\nlines!(ax, sol; idxs=VIndex(1,:busbarâ‚ŠP), label=\"Power injection Bus\", color=Cycled(1))\nlines!(ax, sol; idxs=VIndex(1,:swingâ‚ŠPel), label=\"Power injection Swing\", color=Cycled(2))\nlines!(ax, sol; idxs=VIndex(1,:loadâ‚ŠP), label=\"Power injection load\", color=Cycled(3))\naxislegend(ax)\n\nax = Axis(fig[2,1])\nlines!(ax, sol; idxs=VIndex(1,:busbarâ‚Šu_arg), label=\"swing bus voltage angle\", color=Cycled(1))\nlines!(ax, sol; idxs=VIndex(2,:busbarâ‚Šu_arg), label=\"slack bus voltage angle\", color=Cycled(2))\naxislegend(ax)\nfig #hide","category":"section"},{"location":"ModelingConcepts/#Internals","page":"Modeling Concepts","title":"Internals","text":"Internally, we use different input/output conventions for bus and line models. The predefined models BusBar() and LineEnd() are defined in the following way:","category":"section"},{"location":"ModelingConcepts/#Model:-BusBar()","page":"Modeling Concepts","title":"Model: BusBar()","text":"A busbar is a concrete model used in bus modeling. It represents the physical connection within a bus, the component where all injectors and lines attach.\n\n           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\ni_lines â”€â”€â†’â”‚          â”‚  (t)\n           â”‚  Busbar  â”œâ”€â”€â”€o\n  u_bus â†â”€â”€â”‚          â”‚\n           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nIt receives the sum of all line currents as an input and balances this with the currents flowing into the terminal. As an output, it forwards the terminal voltage to the backend.","category":"section"},{"location":"ModelingConcepts/#Model:-LineEnd()","page":"Modeling Concepts","title":"Model: LineEnd()","text":"A LineEnd model is very similar to the BusBar model. It represents one end of a transmission line.\n\n          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n u_bus â”€â”€â†’â”‚           â”‚  (t)\n          â”‚  LineEnd  â”œâ”€â”€â”€o\ni_line â†â”€â”€â”‚           â”‚\n          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nIt has special input/output connectors which handle the network interconnection. The main difference being the distinct input/output conventions for the network interface.","category":"section"},{"location":"generated/emt_toymodel/#emt-toymodel","page":"EMT Toymodel","title":"EMT Toy Model Example","text":"This script can be downloaded as a normal Julia script here.\n\nThis example demonstrates an electromagnetic transient (EMT) simulation of a simple two-bus system using PowerDynamics.jl. The system consists of a slack bus connected to a load bus through an RL transmission line, with the load bus having both a dynamic PQ load and a capacitive shunt element.\n\nWe compare our simulation results with PowerFactory reference data to validate the EMT modeling approach.\n\nnote: Pedagogical Example\nThis is a pedagogical example that demonstrates the modeling concepts in PowerDynamics.jl are generally compatible with EMT simulations. However, this is far from being an actual interesting simulation study. The way we want to handle EMT simulations in PowerDynamics.jl is not yet fully clear and remains an active area of development.The example serves to illustrate the flexibility of the modeling framework rather than provide a production-ready EMT simulation tool.","category":"section"},{"location":"generated/emt_toymodel/#System-Description","page":"EMT Toymodel","title":"System Description","text":"The test system includes:\n\nBus 1: Slack bus (infinite bus with constant voltage)\nBus 2: Load bus with PQ load and shunt capacitor\nTransmission line: RL model with distributed capacitance\nDisturbance: Load disconnection at t=0.1s\n\nusing PowerDynamics\nusing PowerDynamics.Library\nusing NetworkDynamics\nusing ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\nusing CSV\nusing SteadyStateDiffEq\nusing OrdinaryDiffEqRosenbrock\nusing DataFrames\nusing CairoMakie","category":"section"},{"location":"generated/emt_toymodel/#System-Parameters","page":"EMT Toymodel","title":"System Parameters","text":"First, we define the base system parameters and component values.\n\nÏ‰0    = 2Ï€*50    ## Nominal frequency [rad/s]\nSbase = 300      ## Base power [MW]\nVbase = 110      ## Base voltage [kV]\n\nRline = 1        ## Line resistance [Î©]\nLline = (1/100Ï€) ## Line inductance [H]\nCline = (2e-6)   ## Line capacitance [F]\nPload = -300     ## Load power (negative = consumption) [MW]\n\n# Convert to per-unit values\nRline_pu = Rline / Zbase(Sbase, Vbase)\nLline_pu = Lline / Zbase(Sbase, Vbase)\nCline_pu = Cline / Ybase(Sbase, Vbase)\nPload_pu = Pload / Sbase\nnothing # hide","category":"section"},{"location":"generated/emt_toymodel/#Bus-Definitions","page":"EMT Toymodel","title":"Bus Definitions","text":"","category":"section"},{"location":"generated/emt_toymodel/#Slack-Bus","page":"EMT Toymodel","title":"Slack Bus","text":"The slack bus maintains constant voltage magnitude and angle, representing an infinite bus or strong grid connection.\n\nslackbus = compile_bus(pfSlack(; V=1), vidx=1)","category":"section"},{"location":"generated/emt_toymodel/#Dynamic-Shunt-Capacitor-Model","page":"EMT Toymodel","title":"Dynamic Shunt Capacitor Model","text":"The shunt capacitor is modeled as a dynamic component in the dq-frame. This allows us to observe the three-phase voltages (u_a, u_b, u_c) by transforming from the dq-frame back to abc coordinates.\n\nThe capacitor dynamics are given by:\n\nbeginaligned\nfracdu_rdt = phantom-omega_0 u_i + frac1C i_r \nfracdu_idt = -omega_0 u_r + frac1C i_i\nendaligned\n\nwhere the omega_0 u_i and -omega_0 u_r terms account for the rotating dq-frame.\n\n@mtkmodel DynamicShunt begin\n    @components begin\n        terminal = Terminal()\n    end\n    @variables begin\n        u_r(t), [guess=1, description=\"Real part of voltage\"]\n        u_i(t), [guess=0, description=\"Imaginary part of voltage\"]\n        # Three-phase voltages as observables\n        u_a(t), [description=\"Voltage in a phase\"]\n        u_b(t), [description=\"Voltage in b phase\"]\n        u_c(t), [description=\"Voltage in c phase\"]\n    end\n    @parameters begin\n        C, [description=\"Capacitance\"]\n        Ï‰0, [description=\"Angular frequency of dq Frame\"]\n    end\n    begin\n        # Transformation matrix from dq to abc coordinates\n        Tdqinv(Î´) = [cos(Î´)       -sin(Î´)\n                     cos(Î´-2pi/3) -sin(Î´-2pi/3)\n                     cos(Î´+2pi/3) -sin(Î´+2pi/3)]\n    end\n    @equations begin\n        # Capacitor dynamics in rotating dq-frame\n        Dt(u_r) ~  Ï‰0*u_i + 1/C * terminal.i_r\n        Dt(u_i) ~ -Ï‰0*u_r + 1/C * terminal.i_i\n        # Terminal connections\n        terminal.u_r ~ u_r\n        terminal.u_i ~ u_i\n        # Transform to three-phase voltages\n        [u_a, u_b, u_c] ~ Tdqinv(Ï‰0*t) * [u_r, u_i]\n    end\nend\nnothing #hide","category":"section"},{"location":"generated/emt_toymodel/#Load-Bus-Components","page":"EMT Toymodel","title":"Load Bus Components","text":"The load bus combines two components:\n\nA PQ load consuming constant active power (injector model from Library)\nA dynamic shunt capacitor representing line charging\n\n@named load = PQLoad(Pset=-Pload_pu, Qset=0)\n@named shunt = DynamicShunt(C=Cline_pu, Ï‰0=Ï‰0)\nloadbus = compile_bus(\n    MTKBus(load, shunt);\n    vidx=2\n)","category":"section"},{"location":"generated/emt_toymodel/#Transmission-Line-Model","page":"EMT Toymodel","title":"Transmission Line Model","text":"","category":"section"},{"location":"generated/emt_toymodel/#Dynamic-RL-Branch","page":"EMT Toymodel","title":"Dynamic RL Branch","text":"The transmission line is modeled as a dynamic RL branch in the dq-frame. The line current dynamics are given by:\n\nbeginaligned\nfracdi_rdt = phantom-omega_0 i_i - fracRL i_r + frac1L(u_textdstr - u_textsrcr) \nfracdi_idt = -omega_0 i_r - fracRL i_i + frac1L(u_textdsti - u_textsrci)\nendaligned\n\nwhere the voltage difference drives the current through the line impedance.\n\n@mtkmodel DynamicRLBranch begin\n    @components begin\n        src = Terminal()\n        dst = Terminal()\n    end\n    @variables begin\n        i_r(t)=0, [description=\"Current in real part\"]\n        i_i(t)=-1, [description=\"Current in imaginary part\"]\n    end\n    @parameters begin\n        R, [description=\"Resistance\"]\n        L, [description=\"Inductance\"]\n        Ï‰0, [description=\"Angular frequency of dq Frame\"]\n    end\n    @equations begin\n        # RL line dynamics in rotating dq-frame\n        Dt(i_r) ~  Ï‰0 * i_i  - R/L * i_r + 1/L*(dst.u_r - src.u_r)\n        Dt(i_i) ~ -Ï‰0 * i_r  - R/L * i_i + 1/L*(dst.u_i - src.u_i)\n        # Terminal current connections (KCL enforcement)\n        src.i_r ~ -i_r  ## Current flows out of source\n        src.i_i ~ -i_i\n        dst.i_r ~ i_r   ## Current flows into destination\n        dst.i_i ~ i_i\n    end\nend\n\n@named branch = DynamicRLBranch(; R=Rline_pu, L=Lline_pu, Ï‰0=Ï‰0)\nline_model = compile_line(\n    MTKLine(branch);\n    src=1, dst=2\n)","category":"section"},{"location":"generated/emt_toymodel/#Network-Assembly-and-Initialization","page":"EMT Toymodel","title":"Network Assembly and Initialization","text":"We assemble the complete network and attempt initialization.\n\nnw = Network([slackbus, loadbus], line_model)\ntry #hide\ns0 = find_fixpoint(nw; alg=DynamicSS(Rodas5P()))\ncatch e #hide\n    @error e #hide\nend #hide","category":"section"},{"location":"generated/emt_toymodel/#Initialization-Challenge","page":"EMT Toymodel","title":"Initialization Challenge","text":"The direct initialization fails due to the stiffness of the PQ load model. When the load current is computed algebraically from i = P fracuu^2, the system becomes numerically challenging to initialize.\n\nTo overcome this, we use a \"less stiff\" load model with dynamics that smooth out the algebraic singularity during initialization.\n\nWe create a \"less stiff\" version of the PQ load that introduces first-order dynamics with a fast time constant (1/1000 s). This smooths the algebraic relation and makes initialization more robust:\n\nbeginaligned\nfracdi_rdt = 1000 left( P fracu_ru_r^2 + u_i^2 - i_r right) \nfracdi_idt = 1000 left( P fracu_iu_r^2 + u_i^2 - i_i right)\nendaligned\n\nThis approaches the algebraic PQ load behavior but avoids initialization issues.\n\n@mtkmodel LessStiffPQLoad begin\n    @components begin\n        terminal = Terminal()\n    end\n    @variables begin\n        i_r(t)=0, [description=\"Current in real part\"]\n        i_i(t)=0, [description=\"Current in imaginary part\"]\n    end\n    @parameters begin\n        Pset, [description=\"Active Power demand\"]\n    end\n    @equations begin\n        # First-order dynamics with fast time constant\n        Dt(i_r) ~ 1e3*(Pset * terminal.u_r/(terminal.u_r^2 + terminal.u_i^2) - i_r)\n        Dt(i_i) ~ 1e3*(Pset * terminal.u_i/(terminal.u_r^2 + terminal.u_i^2) - i_i)\n        terminal.i_r ~ i_r\n        terminal.i_i ~ i_i\n    end\nend\n\n@named less_stiff_load = LessStiffPQLoad(Pset=-Pload_pu)\nless_stiff_loadbus = compile_bus(\n    MTKBus(less_stiff_load, shunt);\n    vidx=2\n)\nless_stiff_nw = Network([slackbus, less_stiff_loadbus], line_model)\nless_stiff_s0 = find_fixpoint(less_stiff_nw; alg=DynamicSS(Rodas5P()))","category":"section"},{"location":"generated/emt_toymodel/#Initialize-Target-System","page":"EMT Toymodel","title":"Initialize Target System","text":"Perfect! The less stiff load initialization worked. Now we use this solution as an initial guess for our target system with the algebraic PQ load.\n\ns0guess = NWState(nw)\n# Transfer key state variables from less stiff solution\ns0guess[VIndex(2, :busbarâ‚Šu_i)] = less_stiff_s0[VIndex(2, :busbarâ‚Šu_i)]\ns0guess[VIndex(2, :busbarâ‚Šu_r)] = less_stiff_s0[VIndex(2, :busbarâ‚Šu_r)]\ns0guess[EIndex(1, :branchâ‚Ši_i)] = less_stiff_s0[EIndex(1, :branchâ‚Ši_i)]\ns0guess[EIndex(1, :branchâ‚Ši_r)] = less_stiff_s0[EIndex(1, :branchâ‚Ši_r)]\ns0 = find_fixpoint(nw, s0guess; alg=DynamicSS(Rodas5P()))","category":"section"},{"location":"generated/emt_toymodel/#Disturbance-Setup","page":"EMT Toymodel","title":"Disturbance Setup","text":"Excellent! The initialization succeeded. Now we set up a disturbance to observe the system's transient response. We'll disable the load at t=0.1s to simulate a sudden load disconnection.\n\ndisable_load_affect = ComponentAffect([], [:loadâ‚ŠPset]) do u, p, ctx\n    println(\"Disabling load at time $(ctx.t)\")\n    p[:loadâ‚ŠPset] = 0  ## Set load power to zero\nend\nset_callback!(loadbus, PresetTimeComponentCallback(0.1, disable_load_affect))\nnothing #hide","category":"section"},{"location":"generated/emt_toymodel/#Dynamic-Simulation","page":"EMT Toymodel","title":"Dynamic Simulation","text":"With the system properly initialized and the disturbance configured, we can now run the electromagnetic transient simulation.\n\nprob = ODEProblem(nw, s0, (0.0, 0.15))\nsol = solve(prob, Rodas5P());\nnothing #hide","category":"section"},{"location":"generated/emt_toymodel/#Results-and-Validation","page":"EMT Toymodel","title":"Results and Validation","text":"We compare our EMT simulation results with PowerFactory reference data to validate the modeling approach. The comparison focuses on the three-phase voltages at bus 2 during the load disconnection transient.\n\nThe thick gray lines show the PowerFactory reference, while our PowerDynamics.jl results are overlaid in color. The close agreement validates our EMT modeling approach.\n\nfig = let\n    fig = Figure()\n    ax = Axis(fig[1,1];\n        title=\"Three-Phase Voltage at Bus 2\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Voltage [pu]\")\n    ts = range(0.09, 0.13; length=2000)\n\n    # Load PowerFactory reference data\n    df = CSV.read(\n        joinpath(pkgdir(PowerDynamics),\"docs\",\"examples\", \"emt_data_minimal.csv.gz\"),\n        DataFrame\n    )\n    # Plot PowerFactory results (thick gray lines)\n    lines!(ax, df.t, df.u_2_a; label=\"PowerFactory A\", color=:lightgray, linewidth=5)\n    lines!(ax, df.t, df.u_2_b; label=\"PowerFactory B\", color=:lightgray, linewidth=5)\n    lines!(ax, df.t, df.u_2_c; label=\"PowerFactory C\", color=:lightgray, linewidth=5)\n\n    # Extract and plot our simulation results\n    a = sol(ts, idxs=VIndex(2, :shuntâ‚Šu_a)).u\n    b = sol(ts, idxs=VIndex(2, :shuntâ‚Šu_b)).u\n    c = sol(ts, idxs=VIndex(2, :shuntâ‚Šu_c)).u\n    lines!(ax, ts, a, label=\"PowerDynamics A\", color=Cycled(1))\n    lines!(ax, ts, b, label=\"PowerDynamics B\", color=Cycled(2))\n    lines!(ax, ts, c, label=\"PowerDynamics C\", color=Cycled(3))\n\n    axislegend(ax, position=:rt)\n    xlims!(ax, ts[begin], ts[end])\n    fig\nend","category":"section"},{"location":"generated/emt_toymodel/#Detailed-View-of-Transient-Response","page":"EMT Toymodel","title":"Detailed View of Transient Response","text":"Let's zoom in on the critical period around the load disconnection to better observe the transient behavior and compare with the reference.\n\nxlims!(0.0995, 0.105)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"API/#API","page":"API","title":"API","text":"The following functions are designed for public use.","category":"section"},{"location":"API/#Modeling-Tools","page":"API","title":"Modeling Tools","text":"","category":"section"},{"location":"API/#Connectors-and-Base-Components","page":"API","title":"Connectors and Base Components","text":"","category":"section"},{"location":"API/#Bus-and-Line-Construction","page":"API","title":"Bus and Line Construction","text":"","category":"section"},{"location":"API/#Base-Unit-Calculations","page":"API","title":"Base Unit Calculations","text":"","category":"section"},{"location":"API/#Network-Components","page":"API","title":"Network Components","text":"","category":"section"},{"location":"API/#Interface-Checking-Functions","page":"API","title":"Interface Checking Functions","text":"","category":"section"},{"location":"API/#Power-Flow-Analysis","page":"API","title":"Power Flow Analysis","text":"","category":"section"},{"location":"API/#Power-Flow-Bus-Types","page":"API","title":"Power Flow Bus Types","text":"","category":"section"},{"location":"API/#Power-Flow-Solution-Functions","page":"API","title":"Power Flow Solution Functions","text":"","category":"section"},{"location":"API/#Power-Flow-Model-Management-Functions","page":"API","title":"Power Flow Model Management Functions","text":"","category":"section"},{"location":"API/#Power-Flow-Initialization-Constraints","page":"API","title":"Power Flow Initialization Constraints","text":"","category":"section"},{"location":"API/#Constraint-Types","page":"API","title":"Constraint Types","text":"","category":"section"},{"location":"API/#Constraint-Management-Functions","page":"API","title":"Constraint Management Functions","text":"","category":"section"},{"location":"API/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"API/#PowerDynamics.Terminal","page":"API","title":"PowerDynamics.Terminal","text":"@named t = Terminal()\n\nA ModelingToolkit connector for electrical terminals in power system components.\n\nRepresents an electrical connection point with complex voltage and current in dq coordinates. The terminal defines the interface between power system components like buses, lines, and machines.\n\nVariables\n\nu_r(t): d-axis voltage component\nu_i(t): q-axis voltage component\ni_r(t): d-axis current component (flow variable)\ni_i(t): q-axis current component (flow variable)\n\nNotes\n\nCurrent variables are defined as flow variables, meaning they sum to zero at connection points according to Kirchhoff's current law.\n\nSee also: BusBar, LineEnd\n\n\n\n\n\n","category":"constant"},{"location":"API/#PowerDynamics.BusBar","page":"API","title":"PowerDynamics.BusBar","text":"@named busbar = BusBar()\n\nA ModelingToolkit model representing the physical connection point within a bus in power systems. It represents the physical busbar where all injectors and lines attach.\n\nWithin PowerDynamics.jl, it serves as an interface between the MTK world and the NetworkDynamics world: A MTK model containing a BusBar the highest level is consdered a busmodel (see isbusmodel) and describes the dynamics of an entire bus. It can be transformed in a VertexModel by calling compile_bus.\n\nSee also: Terminal, MTKBus, compile_bus\n\n\n\n\n\n","category":"constant"},{"location":"API/#PowerDynamics.LineEnd","page":"API","title":"PowerDynamics.LineEnd","text":"LineEnd\n\nA ModelingToolkit model representing one end of a transmission line in power systems. It represents the physical connection point at the end of a transmission line.\n\nWithin PowerDynamics.jl, it serves as an interface between the MTK world and the NetworkDynamics world: A MTK model containing two LineEnds (named :src and :dst) at the highest level is considered a linemodel (see islinemodel) and describes the dynamics of an entire line. It can be transformed in an EdgeModel by calling compile_line.\n\nSee also: Terminal, MTKLine, compile_line\n\n\n\n\n\n","category":"constant"},{"location":"API/#PowerDynamics.MTKBus","page":"API","title":"PowerDynamics.MTKBus","text":"MTKBus(injectors...; name=:bus)\n\nCreate a ModelingToolkit bus system by connecting multiple injector components.\n\nConstructs a bus System by connecting all provided injector components to a central BusBar. Each injector component must satisfy the injector model interface (see isinjectormodel).\n\nArguments\n\ninjectors...: Variable number of injector components (generators, loads, etc.)\nname=:bus: Name for the resulting bus system\n\nReturns\n\nAn System representing the complete bus with all connected injectors\n\n                                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                                 â”‚MTKBus   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚\n                                 â”‚        â”Œâ”¤Generatorâ”‚â”‚\n        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”     â”‚â”Œâ”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚\nMTKBus(oâ”¤Generatorâ”‚, oâ”¤Loadâ”‚) => â”‚â”‚BusBarâ”œo           â”‚\n        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”˜     â”‚â””â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”     â”‚\n                                 â”‚        â””â”¤Loadâ”‚     â”‚\n                                 â”‚         â””â”€â”€â”€â”€â”˜     â”‚\n                                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nSee also: compile_bus, BusBar, isinjectormodel\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.MTKLine","page":"API","title":"PowerDynamics.MTKLine","text":"MTKLine(branches...; name=:line)\n\nCreate a ModelingToolkit line system by connecting multiple branch components.\n\nConstructs a line System by connecting all provided branch components between source and destination line ends in parallel. Each branch component must satisfy the branch model interface.\n\nArguments\n\nbranches...: Variable number of branch components (transmission lines, transformers, etc.)\nname=:line: Name for the resulting line system\n\nReturns\n\nAn System representing the complete line with all connected branches\n\n                                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                                     â”‚MTKLine   â”Œâ”€â”€â”€â”€â”€â”€â”€â”          â”‚\n                                     â”‚         â”Œâ”¤BranchAâ”œâ”         â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”      â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚\nMTKLine(oâ”¤BranchAâ”œo, oâ”¤BranchBâ”œo) => â”‚â”‚LineEndâ”œo         oâ”¤LineEndâ”‚â”‚\n         â””â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚\n                                     â”‚  :src   â””â”¤BranchBâ”œâ”˜  :dst   â”‚\n                                     â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚\n                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nSee also: compile_line, LineEnd, isbranchmodel\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.CompositeInjector","page":"API","title":"PowerDynamics.CompositeInjector","text":"CompositeInjector(systems, eqs=autoconnections(systems); name=Symbol(join(getname.(systems), \"_\")))\n\nCreate an injector object which contains several subsystems. Every subsystem which has a terminal will be connected to a newly created terminal of the composite injector. The subsystems are namespaced within the composite injector.\n\nThere are two options for additional connections between the subsystems:\n\ninterconnections will be created automatically using some name-matching heuristics using autoconnections(systems): It searches all Blocks.RealOutput and Blocks.RealInput, and tries to find a single matching output for each input.\nalternatively pass connecting equations of the form [connect(sys1.output, sys2.input)] explicitly\n\nFor example, one could create a composite injector with three subsystems:\n\na generator,\na controller, and\na load;\n\nwhich is augmented with 2 connection equations\n\none for the measurements (generator -> controller), and\none for the actuation (controller -> generator).\n\nThe returned model contains a new terminal :terminal at the toplevel, thus satisfying the injector interface, see isinjectormodel). It can be used as such in the MTKBus constructor.\n\n    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n    â”‚ CompositeInjector                  â”‚\n    â”‚              â•­â”€â”€â”€â†’â”€â”€â”€â•® measurementsâ”‚\n    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”   â”Œâ”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚\n(t) â”‚  oâ”€â”¤ Generator â”‚   â”‚ Controller â”‚  â”‚\n oâ”€â”€â”¼â”€â”€â”¤ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”˜   â””â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚\n    â”‚  â”‚           â•°â”€â”€â”€â†â”€â”€â”€â•¯ actuation   â”‚\n    â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”                        â”‚\n    â”‚  oâ”€â”¤ Load â”‚                        â”‚\n    â”‚    â””â”€â”€â”€â”€â”€â”€â”˜                        â”‚\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.Ibase","page":"API","title":"PowerDynamics.Ibase","text":"Ibase(S, V)\n\nCalculates current pu base based on Sbase and Vbase: Ibase = Sbase/Vbase.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.Zbase","page":"API","title":"PowerDynamics.Zbase","text":"Zbase(S, V)\n\nCalculates impedance pu base based on Sbase and Vbase: Zbase = VbaseÂ²/Sbase.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.Ybase","page":"API","title":"PowerDynamics.Ybase","text":"Ybase(S, V)\n\nCalculates admittance pu base based on Sbase and Vbase: Ybase = Sbase/VbaseÂ².\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.compile_bus","page":"API","title":"PowerDynamics.compile_bus","text":"compile_bus(sys::System; verbose=false, name=getname(sys), kwargs...)\n\nCreate a VertexModel from an System that satisfies the bus model interface.\n\nArguments\n\nsys::System: The system must satisfy the bus model interface (see isbusmodel)\nverbose::Bool=false: Enable verbose output during creation\nname: Name for the bus (defaults to system name)\nkwargs...: Additional keyword arguments passed to the Bus constructor\n\nReturns\n\nA VertexModel representing the bus\n\n                                                  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n                                                  â•‘ VertexModel (compiled)  â•‘\n            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      Network   â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘\n            â”‚MTKBus   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚     interface  â•‘  â”‚MTKBus   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â•‘\n            â”‚        â”Œâ”¤Generatorâ”‚â”‚                â•‘  â”‚        â”Œâ”¤Generatorâ”‚â”‚ â•‘\n            â”‚â”Œâ”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚      current â”€â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â•‘\ncompile_bus(â”‚â”‚BusBarâ”œo           â”‚) =>            â•‘  â”‚â”‚BusBarâ”œo           â”‚ â•‘\n            â”‚â””â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”     â”‚      voltage â†â”€â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”     â”‚ â•‘\n            â”‚        â””â”¤Loadâ”‚     â”‚                â•‘  â”‚        â””â”¤Loadâ”‚     â”‚ â•‘\n            â”‚         â””â”€â”€â”€â”€â”˜     â”‚                â•‘  â”‚         â””â”€â”€â”€â”€â”˜     â”‚ â•‘\n            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘\n                                                  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nSee also: MTKBus\n\n\n\n\n\ncompile_bus(template::VertexModel; copy=true, pf=nothing, name=template.name, pairs...)\n\nSimilar to the Bus constructor, but takes a pre-compiled VertexModel. It copies the VertexModel and applies the keyword arguments. This is useful when you want to create new bus models based on a template.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.compile_line","page":"API","title":"PowerDynamics.compile_line","text":"compile_line(sys::System; verbose=false, name=getname(sys), kwargs...)\n\nCreate an EdgeModel from a System that satisfies the line model interface.\n\nArguments\n\nsys::System: The system must satisfy the line model interface (see islinemodel)\nverbose::Bool=false: Enable verbose output during creation\nname: Name for the line (defaults to system name)\nkwargs...: Additional keyword arguments passed to the Line constructor\n\nReturns\n\nAn EdgeModel representing the line\n\n\n                                                     â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n                                                     â•‘ EdgeModel (compiled)         â•‘\n             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     src â•‘ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘ dst\n             â”‚MTKLine   â”Œâ”€â”€â”€â”€â”€â”€â”€â”          â”‚  vertex â•‘ â”‚MTKLine   â”Œâ”€â”€â”€â”€â”          â”‚ â•‘ vertex\n             â”‚         â”Œâ”¤BranchAâ”œâ”         â”‚         â•‘ â”‚         â”Œâ”¤    â”œâ”         â”‚ â•‘\n             â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚     u â”€â”€â”€â†’â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â†â”€â”€â”€ u\ncompile_line(â”‚â”‚LineEndâ”œo         oâ”¤LineEndâ”‚â”‚) =>     â•‘ â”‚â”‚LineEndâ”œo      oâ”¤LineEndâ”‚â”‚ â•‘\n             â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚     i â†â”€â”€â”€â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”Œâ”€â”€â”€â”€â”â”‚â””â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”€â”€â”€â†’ i\n             â”‚  :src   â””â”¤BranchBâ”œâ”˜  :dst   â”‚         â•‘ â”‚         â””â”¤    â”œâ”˜         â”‚ â•‘\n             â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚         â•‘ â”‚          â””â”€â”€â”€â”€â”˜          â”‚ â•‘\n             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â•‘ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘\n                                                     â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nSee also: MTKLine\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.simplify_mtkbus","page":"API","title":"PowerDynamics.simplify_mtkbus","text":"simplify_mtkbus(sys::System; busbar=:busbar)\n\nStructurally simplify a bus model System by eliminating equations.\n\nClosely matches what VertexModel does, but returns the System after the simplifications rather than compiling it into a VertexModel.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.simplify_mtkline","page":"API","title":"PowerDynamics.simplify_mtkline","text":"simplify_mtkline(sys::System; src=:src, dst=:dst)\n\nStructurally simplify a line model System by eliminating equations.\n\nClosely matches what EdgeModel does, but returns the System after the simplifications rather than compiling it into an EdgeModel.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.Bus","page":"API","title":"PowerDynamics.Bus","text":"Bus(args...; kwargs...) => compile_bus(args...; kwargs...)\n\nDEPRECATED! Use compile_bus instead.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.Line","page":"API","title":"PowerDynamics.Line","text":"Line(args...; kwargs...) => compile_line(args...; kwargs...)\n\nDEPRECATED! Use compile_line instead.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.isinjectormodel","page":"API","title":"PowerDynamics.isinjectormodel","text":"isinjectormodel(sys::System)\n\nCheck if a System satisfies the injector model interface.\n\nAn injector model must contain a Terminal named :terminal. Injector models represent components like generators, loads, and other devices that connect to a single bus. They can have arbitrary internal complexity as long as they have exactly one terminal.\n\n   (t)    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n    oâ”€â”€â”€â”€â”€â”¤ Injector â”‚\n:terminal â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nSee also: Terminal\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.isbusmodel","page":"API","title":"PowerDynamics.isbusmodel","text":"isbusmodel(sys::System)\n\nCheck if a System satisfies the bus model interface.\n\nA bus model must contain a component named :busbar that satisfies the busbar interface. Bus models represent the complete dynamics of a power system bus and can be transformed into a VertexModel using compile_bus.\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚BusModel     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚\nâ”‚           â”Œâ”€â”¤ Injector 1 â”‚â”‚\nâ”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚\nâ”‚â”‚ BusBar â”œâ”€o               â”‚\nâ”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚               â”‚\nâ”‚ :busbar   â”” ...           â”‚\nâ”‚                           â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nNote: The BusModel musst contain exaclty one BusBar, the rest of the structure is free. For example, you could also put a Brach between an injector and a Busbar or have multiple injectors and controllers connected.\n\nSee also: compile_bus, BusBar, MTKBus\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.isbranchmodel","page":"API","title":"PowerDynamics.isbranchmodel","text":"isbranchmodel(sys::System)\n\nCheck if a System satisfies the branch model interface.\n\nA branch model must contain two Terminal components named :src and :dst. Branch models represent two-port network elements like transmission lines, transformers, and other connecting devices.\n\n (t) â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” (t)\n  oâ”€â”€â”¤ Branch â”œâ”€â”€o\n:src â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ :dst\n\nSee also: Terminal\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.islinemodel","page":"API","title":"PowerDynamics.islinemodel","text":"islinemodel(sys::System)\n\nCheck if a System satisfies the line model interface.\n\nA line model must contain two components named :src and :dst that both satisfy the line end interface. Line models represent transmission lines and can be transformed into an EdgeModel using compile_line.\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚LineModel     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚\nâ”‚            â”Œâ”€â”¤ Branch â”œâ”€â”            â”‚\nâ”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚\nâ”‚â”‚ LineEnd â”œâ”€o            oâ”€â”¤ LineEnd â”‚â”‚\nâ”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚            â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚\nâ”‚   :src     â””    ....    â”˜    :dst    â”‚\nâ”‚                                      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nNote: Between the LineEnds there can be arbeitrary structures, for example branches in series or parallel.\n\nSee also: compile_line, LineEnd, MTKBus\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.pfSlack","page":"API","title":"PowerDynamics.pfSlack","text":"pfSlack(; V=missing, Î´=missing, u_r=missing, u_i=missing, name=:slackbus)\n\nCreate a slack bus for power flow analysis.\n\nA slack bus maintains constant voltage magnitude and phase angle (or real and imaginary voltage components). Either provide voltage magnitude V and phase angle Î´, or provide real and imaginary voltage components u_r and u_i.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.pfPV","page":"API","title":"PowerDynamics.pfPV","text":"pfPV(; P, V, name=:pvbus)\n\nCreate a PV bus for power flow analysis.\n\nA PV bus maintains constant active power injection and voltage magnitude. The reactive power and voltage phase angle are determined by the power flow solution.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.pfPQ","page":"API","title":"PowerDynamics.pfPQ","text":"pfPQ(; P=0, Q=0, name=:pqbus)\n\nCreate a PQ bus for power flow analysis.\n\nA PQ bus has specified active and reactive power injections. The voltage magnitude and phase angle are determined by the power flow solution.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.solve_powerflow","page":"API","title":"PowerDynamics.solve_powerflow","text":"solve_powerflow(nw::Network;\n                pfnw = powerflow_model(nw),\n                pfs0 = NWState(pfnw),\n                fill_busbar_defaults=true\n                verbose=true)\n\nSolve the power flow equations for a given network.\n\nUses find_fixpoint from NetworkDynamics to solve the algebraic power flow equations.\n\nParameters\n\nnw: The dynamic network model\npfnw: The power flow network model (default: created from nw)\npfs0: Initial state for the power flow calculation\nfill_busbar_defaults: Whether to fill missing default values for busbar states (i.e. ur=1 ui=0)\nverbose: Whether to print the power flow solution\n\nReturns\n\nA NWState containing the solved power flow solution\n\nSee also initialize_from_pf.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.initialize_from_pf!","page":"API","title":"PowerDynamics.initialize_from_pf!","text":"initialize_from_pf[!](\n    nw::Network;\n    verbose = true,\n    subverbose = false,\n    pfnw = powerflow_model(nw),\n    pfs0 = NWState(pfnw),\n    pfs = solve_powerflow(nw; pfnw, pfs0, verbose),\n    kwargs...\n)\n\nInitialize a dynamic network model from a power flow solution.\n\nThis function performs a two-step initialization process:\n\nSolve the power flow equations for the network\nUse the power flow solution to initialize the dynamic model\n\nPer default, the powerflow solution is computed as\n\npfnw = powerflow_model(nw)                     # get powerflow network model\npfs0 = NWState(pfnw)                           # initial condition for network model\npfs = solve_powerflow(nw; pfnw, pfs0, verbose) # solve powerflow\n\nYou can override any of these steps by providing pfnw, pfs0, or pfs directly as a keyword argument.\n\nThere are two versions of this function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses initialize_componentwise! internally, the non-mutating one initialize_componentwise. When the mutating version is used, NWState(nw) after initialization will return the same initialized state again, as it is stored in the metadata.\n\nParameters\n\nnw: The dynamic network model to initialize\nverbose: Whether to print information about the power flow solution (default: true)\nsubverbose: Whether to print detailed information during component initialization (default: false). Can be Vector [VIndex(1), EIndex(3), ...] for selective output\npfnw: Power flow network model (default: created from nw using powerflow_model)\npfs0: Initial state for power flow calculation (default: created from pfnw)\npfs: Power flow solution (default: calculated using solve_powerflow)\nAdditional keyword arguments are passed to initialize_componentwise[!]\n\nReturns\n\nA fully initialized network state\n\nSee also: solve_powerflow, initialize_componentwise, interface_values\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.initialize_from_pf","page":"API","title":"PowerDynamics.initialize_from_pf","text":"initialize_from_pf[!](\n    nw::Network;\n    verbose = true,\n    subverbose = false,\n    pfnw = powerflow_model(nw),\n    pfs0 = NWState(pfnw),\n    pfs = solve_powerflow(nw; pfnw, pfs0, verbose),\n    kwargs...\n)\n\nInitialize a dynamic network model from a power flow solution.\n\nThis function performs a two-step initialization process:\n\nSolve the power flow equations for the network\nUse the power flow solution to initialize the dynamic model\n\nPer default, the powerflow solution is computed as\n\npfnw = powerflow_model(nw)                     # get powerflow network model\npfs0 = NWState(pfnw)                           # initial condition for network model\npfs = solve_powerflow(nw; pfnw, pfs0, verbose) # solve powerflow\n\nYou can override any of these steps by providing pfnw, pfs0, or pfs directly as a keyword argument.\n\nThere are two versions of this function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses initialize_componentwise! internally, the non-mutating one initialize_componentwise. When the mutating version is used, NWState(nw) after initialization will return the same initialized state again, as it is stored in the metadata.\n\nParameters\n\nnw: The dynamic network model to initialize\nverbose: Whether to print information about the power flow solution (default: true)\nsubverbose: Whether to print detailed information during component initialization (default: false). Can be Vector [VIndex(1), EIndex(3), ...] for selective output\npfnw: Power flow network model (default: created from nw using powerflow_model)\npfs0: Initial state for power flow calculation (default: created from pfnw)\npfs: Power flow solution (default: calculated using solve_powerflow)\nAdditional keyword arguments are passed to initialize_componentwise[!]\n\nReturns\n\nA fully initialized network state\n\nSee also: solve_powerflow, initialize_componentwise, interface_values\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.show_powerflow","page":"API","title":"PowerDynamics.show_powerflow","text":"show_powerflow(s::NWState/Network)\n\nDisplay power flow results in a tabular format.\n\nExtract and format power flow solution data from a network state, showing bus-level information including voltage magnitudes, phase angles, active power, and reactive power.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.powerflow_model","page":"API","title":"PowerDynamics.powerflow_model","text":"powerflow_model(cf::NetworkDynamics.ComponentModel; check=:error)\n\nExtract or create a power flow component model from a dynamic component model.\n\nIf the component has :pfmodel metadata, use that model (after validation)\nIf the component is already a valid power flow model (i.e. no ODE, just constraints), return it as-is\n\nParameters\n\ncf: The component model to extract/create a power flow model from\ncheck: Validation behavior (:error, :warn, or :none) when model validation fails\n\nReturns\n\nA component model suitable for power flow analysis (no dynamics)\n\nValidation\n\nThe returned model must satisfy ispfmodel criteria:\n\nEither no states or zero mass matrix (no dynamics)\n\nSee also: ispfmodel, pfSlack, pfPV, pfPQ\n\n\n\n\n\npowerflow_model(nw::Network; check=:error)\n\nCreate a power flow network model from a dynamic network model.\n\nThis method applies powerflow_model to all vertex and edge components in the network, creating a new network suitable for steady-state power flow analysis.\n\nParameters\n\nnw: The network to create a power flow model from\ncheck: Validation behavior (:error, :warn, or :none) passed to component-level powerflow_model calls\n\nReturns\n\nA new Network with the same graph structure but power flow component models\n\nSee also: solve_powerflow\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.ispfmodel","page":"API","title":"PowerDynamics.ispfmodel","text":"ispfmodel(cf::NetworkDynamics.ComponentModel)\n\nCheck if a component model is suitable for power flow analysis.\n\nA component model is considered a valid power flow model if it has no dynamics, i.e., either no states or a zero mass matrix.\n\nReturns\n\ntrue if the component is suitable for power flow analysis\nfalse otherwise\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.has_pfmodel","page":"API","title":"PowerDynamics.has_pfmodel","text":"has_pfmodel(c::ComponentModel)\nhas_pfmodel(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has a power flow model in metadata.\n\nSee also: get_pfmodel, set_pfmodel!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.get_pfmodel","page":"API","title":"PowerDynamics.get_pfmodel","text":"get_pfmodel(c::NetworkDynamics.ComponentModel)\nget_pfmodel(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the power flow model for the component model. May error if no power flow model is present. Use has_pfmodel to check first.\n\nSee also: has_pfmodel, set_pfmodel!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.set_pfmodel!","page":"API","title":"PowerDynamics.set_pfmodel!","text":"set_pfmodel!(c::NetworkDynamics.ComponentModel, model)\nset_pfmodel!(nw::Network, idx::Union{VIndex,EIndex}, model)\n\nSets the power flow model for the component. Overwrites any existing power flow model.\n\nSee also delete_pfmodel!, get_pfmodel.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.delete_pfmodel!","page":"API","title":"PowerDynamics.delete_pfmodel!","text":"delete_pfmodel!(c::NetworkDynamics.ComponentModel)\ndelete_pfmodel!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the power flow model from the component model, or from a component referenced by idx in a network. Returns true if the power flow model existed and was removed, false otherwise.\n\nSee also: set_pfmodel!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.PFInitConstraint","page":"API","title":"PowerDynamics.PFInitConstraint","text":"struct PFInitConstraint{F}\nPFInitConstraint(f, sym, pfsym, dim)\n\nA representation of an additional constraint that is applied during the initialization phase of a component. In contrast to a InitConstraint, this constraint may access additional variables which are available in the full NWState of the solved power flow!\n\nCrucially, this is only necessary for constraints, which cannot be expressed in terms of the interface variables (voltages and currents).\n\nSee also: @pfinitconstraint for a macro to create such constraints, PFInitConstraint, set_pfinitconstraint!, add_pfinitconstraint!\n\n\n\n\n\n","category":"type"},{"location":"API/#PowerDynamics.@pfinitconstraint","page":"API","title":"PowerDynamics.@pfinitconstraint","text":"@pfinitconstraint expr\n@pfinitconstraint begin\n    constraint1\n    constraint2\nend\n\nCreate a PFInitConstraint using macro syntax. Component variables are accessed with :symbol and power flow state variables with @pf(:symbol). Multiple constraints can be defined in a begin...end block.\n\nFor example, the following code creates constraints Pset/Qset of the dynamic model in reference to the variables P and Q of the powerflow model.\n\n@pfinitconstraint :dynamicâ‚ŠPset - @pf(:staticâ‚ŠP)\n@pfinitconstraint begin\n    :dynamicâ‚ŠPset - @pf(:staticâ‚ŠP)\n    :dynamicâ‚ŠQset - @pf(:staticâ‚ŠQ)\nend\n\nNote that this particiular example could have been a PFInitFormula, since we can solve it directly.\n\nSee also: PFInitConstraint, set_pfinitconstraint!, add_pfinitconstraint!\n\n\n\n\n\n","category":"macro"},{"location":"API/#PowerDynamics.PFInitFormula","page":"API","title":"PowerDynamics.PFInitFormula","text":"struct PFInitFormula{F}\nPFInitFormula(f, outsym, sym, pfsym)\n\nA representation of an initialization formula that is applied during the initialization phase of a component. In contrast to a InitFormula, this formula may access additional variables which are available in the full NWState of the solved power flow!\n\nCrucially, this is only necessary for formulas, which cannot be expressed in terms of the interface variables (voltages and currents).\n\nSimilar to InitFormula, this sets defaults rather than adding constraint equations. The formula is applied early in the initialization pipeline before constraints are solved.\n\nSee also: @pfinitformula for a macro to create such formulas, PFInitFormula, set_pfinitformula!, add_pfinitformula!\n\n\n\n\n\n","category":"type"},{"location":"API/#PowerDynamics.@pfinitformula","page":"API","title":"PowerDynamics.@pfinitformula","text":"@pfinitformula expr\n@pfinitformula begin\n    :var1 = expr1\n    :var2 = expr2\nend\n\nCreate a PFInitFormula using macro syntax. Component variables are accessed with :symbol and power flow state variables with @pf(:symbol). Multiple formulas can be defined in a begin...end block.\n\nUnlike constraints, formulas use assignment syntax (:var = expression) to set variable values during initialization. The left-hand side specifies output variables, and the right-hand side can access both component variables and power flow state variables.\n\nFor example, the following code creates formulas for Pset/Qset of the dynamic model in reference to the variables P and Q of the powerflow model.\n\n@pfinitformula :dynamicâ‚ŠPset = @pf(:staticâ‚ŠP)\n@pfinitformula begin\n    :dynamicâ‚ŠPset = @pf(:staticâ‚ŠP)\n    :dynamicâ‚ŠQset = @pf(:staticâ‚ŠQ)\nend\n\nSee also: PFInitFormula, set_pfinitformula!, add_pfinitformula!\n\n\n\n\n\n","category":"macro"},{"location":"API/#PowerDynamics.add_pfinitconstraint!","page":"API","title":"PowerDynamics.add_pfinitconstraint!","text":"add_pfinitconstraint!(c::NetworkDynamics.ComponentModel, constraint::PFInitConstraint) -> Bool\nadd_pfinitconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint) -> Bool\n\nAdds a new initialization constraint which depends on the powerflow solution to the component. If constraints already exist, the new constraint is added to the existing ones. If no constraints exist, this is equivalent to set_pfinitconstraint!.\n\nReturns true if the constraint was successfully added, false if it already exists.\n\nSee also set_pfinitconstraint!, delete_pfinitconstraints!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.add_pfinitformula!","page":"API","title":"PowerDynamics.add_pfinitformula!","text":"add_pfinitformula!(c::NetworkDynamics.ComponentModel, formula::PFInitFormula) -> Bool\nadd_pfinitformula!(nw::Network, idx::Union{VIndex,EIndex}, formula) -> Bool\n\nAdds a new initialization formula which depends on the powerflow solution to the component. If formulas already exist, the new formula is added to the existing ones. If no formulas exist, this is equivalent to set_pfinitformula!.\n\nReturns true if the formula was successfully added, false if it already exists.\n\nSee also set_pfinitformula!, delete_pfinitformulas!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.set_pfinitconstraint!","page":"API","title":"PowerDynamics.set_pfinitconstraint!","text":"set_pfinitconstraint!(c::NetworkDynamics.ComponentModel, constraint; check=true)\nset_pfinitconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint; check=true)\n\nSets initialization constraints which depend on the powerflow solution to the component. Accepts either a single PFInitConstraint or a tuple of PFInitConstraint objects. Overwrites any existing pf constraints. See also delete_pfinitconstraints!, add_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.set_pfinitformula!","page":"API","title":"PowerDynamics.set_pfinitformula!","text":"set_pfinitformula!(c::NetworkDynamics.ComponentModel, formula; check=true)\nset_pfinitformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)\n\nSets initialization formulas which depend on the powerflow solution to the component. Accepts either a single PFInitFormula or a tuple of PFInitFormula objects. Overwrites any existing pf formulas. See also delete_pfinitformulas!, add_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.has_pfinitconstraint","page":"API","title":"PowerDynamics.has_pfinitconstraint","text":"has_pfinitconstraint(c::ComponentModel)\nhas_pfinitconstraint(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has an initialization constraint which depends on the pf state in metadata.\n\nSee also: get_pfinitconstraints, set_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.has_pfinitformula","page":"API","title":"PowerDynamics.has_pfinitformula","text":"has_pfinitformula(c::ComponentModel)\nhas_pfinitformula(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has an initialization formula which depends on the pf state in metadata.\n\nSee also: get_pfinitformulas, set_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.get_pfinitconstraints","page":"API","title":"PowerDynamics.get_pfinitconstraints","text":"get_pfinitconstraints(c::NetworkDynamics.ComponentModel)\nget_pfinitconstraints(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the initialization constraints which depend on pf state for the component model. Returns a tuple of constraints, even if only one constraint is present. May error if no constraints are present. Use has_pfinitconstraint to check first.\n\nSee also: has_pfinitconstraint, set_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.get_pfinitformulas","page":"API","title":"PowerDynamics.get_pfinitformulas","text":"get_pfinitformulas(c::NetworkDynamics.ComponentModel)\nget_pfinitformulas(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the initialization formulas which depend on pf state for the component model. Returns a tuple of formulas, even if only one formula is present. May error if no formulas are present. Use has_pfinitformula to check first.\n\nSee also: has_pfinitformula, set_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.delete_pfinitconstraints!","page":"API","title":"PowerDynamics.delete_pfinitconstraints!","text":"delete_pfinitconstraints!(c::NetworkDynamics.ComponentModel)\ndelete_pfinitconstraints!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the powerflow dependent initialization constraint from the component model, or from a component referenced by idx in a network. Returns true if the constraint existed and was removed, false otherwise.\n\nSee also: set_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.delete_pfinitformulas!","page":"API","title":"PowerDynamics.delete_pfinitformulas!","text":"delete_pfinitformulas!(c::NetworkDynamics.ComponentModel)\ndelete_pfinitformulas!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the powerflow dependent initialization formula from the component model, or from a component referenced by idx in a network. Returns true if the formula existed and was removed, false otherwise.\n\nSee also: set_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.copy_pf_parameters","page":"API","title":"PowerDynamics.copy_pf_parameters","text":"copy_pf_parameters(cm::ComponentModel) -> PFInitFormula\n\nCreates a PFInitFormula that copies all parameters from the powerflow model to the component model. This formula can then be added to the component using add_pfinitformula!.\n\nThis is useful for components where the powerflow and dynamic models should have identical parameter values, ensuring consistency between the two models.\n\nSee also: PFInitFormula, add_pfinitformula!\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.refine_timeseries","page":"API","title":"PowerDynamics.refine_timeseries","text":"refine_timeseries(ts, factor=10)\n\nRefine a time series by interpolating additional time points between existing ones. Usefull for creating denser plots based on refine_timeseries(sol.t).\n\nArguments\n\nts: Input time series vector\nfactor: Number of subdivisions between each pair of consecutive time points (default: 10)\n\n\n\n\n\n","category":"function"},{"location":"generated/custom_bus/#custom-bus","page":"Custom Generator Bus","title":"Define a Custom Bus Model","text":"This tutorial can be downloaded as a normal Julia script here.\n\nIn this Tutorial, we will define a custom bus model that can be used in PowerDynamics.jl.\n\nThe model we set out to recreate is the classical machine from Chapter 15.1 from Milano's book\n\nF. Milano, Power System Modelling and Scripting,  Berlin, Heidelberg: Springer Berlin Heidelberg, 2010. doi: 10.1007/978-3-642-13669-6.","category":"section"},{"location":"generated/custom_bus/#Defining-the-Machine-as-Injector","page":"Custom Generator Bus","title":"Defining the Machine as Injector","text":"In order to use this model in a Bus, we need to define it in a way that it specifies the Injector Interface.\n\n            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nterminal    â”‚                   â”‚\n   oâ†â”€â”€â”€â”€â”€â”€â”€â”¤ Machine Equations â”‚\nu_r, u_i    â”‚                   â”‚\ni_r, i_i    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\nThe received values for u_r, u_i, i_r, and i_i at the terminal are in the global synchronous dq frame. The internal state Î´ describes the rotor angle of the machine in this frame. In order to obtain the local dq-frame voltages and currents, we need to apply a Park transformation.\n\n<picture>\n<source srcset=\"../../assets/dqgrafic-dark.svg\" media=\"(prefers-color-scheme: dark)\">\n<img src=\"../../assets/dqgrafic.svg\" width=\"70%\" height=\"70%\"/>\n</picture>\n\nIn addition to the transformation, the model is defined by the following equations:\n\nbeginaligned\nfracddeltadt = omega_b(omega - 1) text(Milano 155) \n2H fracdomegadt = fracP_momega - tau_e text(Power form of Milano 155) \npsi_d = V_q + R_s I_q text(Milano 1511) \npsi_q = -V_d - R_s I_d text(Milano 1511) \ntau_e = psi_d I_q - psi_q I_d text(Milano 156) \n0 = V_q + R_s I_q + X_d I_d - v_ftextset text(Milano 1536) \n0 = V_d + R_s I_d - X_d I_q text(Milano 1536)\nendaligned\n\nWe can use the ModelingToolkit DSL to define the full injector model:\n\nusing PowerDynamics, NetworkDynamics, ModelingToolkit\nusing PowerDynamics.Library\nusing ModelingToolkit: t_nounits as t, D_nounits as Dt\nusing ModelingToolkitStandardLibrary.Blocks\nusing OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\n\n@mtkmodel MilanoClassicalMachine begin\n    @components begin\n        terminal=Terminal()\n    end\n    @parameters begin\n        R_s=0.000124, [description=\"stator resistance\"]\n        Xâ€²_d=0.0608, [description=\"d-axis transient reactance\"]\n        H=23.64, [description=\"inertia constant\"]\n        Ï‰_b=2Ï€*50, [description=\"System base frequency in rad/s\"]\n        vf_set, [guess=1, description=\"field voltage\"]\n        P_m, [guess=1, description=\"mechanical power\"]\n    end\n    @variables begin\n        Î´(t), [guess=0, description=\"rotor angle\"]\n        Ï‰(t), [guess=1, description=\"rotor speed\"]\n        Ï„_e(t), [description=\"electrical torque\"]\n        I_d(t), [description=\"d-axis current\"]\n        I_q(t), [description=\"q-axis current\"]\n        V_d(t), [description=\"d-axis voltage\"]\n        V_q(t), [description=\"q-axis voltage\"]\n        Ïˆ_d(t), [description=\"d-axis flux linkage\"]\n        Ïˆ_q(t), [description=\"q-axis flux linkage\"]\n    end\n    begin\n        T_to_loc(Î±)  = [ sin(Î±) -cos(Î±);\n                         cos(Î±)  sin(Î±)]\n        T_to_glob(Î±) = [ sin(Î±)  cos(Î±);\n                        -cos(Î±)  sin(Î±)]\n    end\n    @equations begin\n        # Park's transformations\n        [terminal.u_r, terminal.u_i] .~ T_to_glob(Î´)*[V_d, V_q]\n        [I_d, I_q] .~ T_to_loc(Î´)*[terminal.i_r, terminal.i_i]\n\n        # mechanical swing equation Milano 15.5\n        Dt(Î´) ~ Ï‰_b*(Ï‰ - 1)\n        2*H * Dt(Ï‰) ~ P_m/Ï‰ - Ï„_e\n\n        # static flux linkage equations Milano 15.11\n        Ïˆ_d ~  V_q + R_s*I_q\n        Ïˆ_q ~ -V_d - R_s*I_d\n\n        # electrical torque Milano 15.6\n        Ï„_e ~ Ïˆ_d*I_q - Ïˆ_q*I_d\n\n        # magnetic equations from static model Milano 15.36\n        0 ~ V_q + R_s*I_q + Xâ€²_d*I_d - vf_set\n        0 ~ V_d + R_s*I_d - Xâ€²_d*I_q\n    end\nend\n\n\n@named machine = MilanoClassicalMachine();\nnothing #hide\n\nWe can verify that the model satisfies the Injector Interface by checking\n\nisinjectormodel(machine)","category":"section"},{"location":"generated/custom_bus/#Attaching-the-Machine-to-a-Busbar","page":"Custom Generator Bus","title":"Attaching the Machine to a Busbar","text":"In order to use the machine model, we need to attach it to a busbar, thus forming a system which satisfies the MTKBus Interface. There are two ways of doing so: manually and using the MTKBus constructor.\n\nManual Construction\n\nWe need to define a new MTK model, which has 2 components: a busbar and the machine. Both components have a terminal as a subcomponent, we can use the connect function to hook the machine on the busbar.\n\n@mtkmodel MyMTKBus begin\n    @components begin\n        busbar = BusBar()\n        machine = MilanoClassicalMachine()\n    end\n    @equations begin\n        connect(busbar.terminal, machine.terminal)\n    end\nend\nmtkbus = MyMTKBus(name=:bus)\nisbusmodel(mtkbus) # assert that the created model satisfies the interface\n\nAutomatic Construction\n\nWe can also use the MTKBus constructor to create a busbar with a machine attached. This constructor takes a list of injector models and hooks them all to the same busbar.\n\nmtkbus = MTKBus(machine; name=:bus)\nisbusmodel(mtkbus) # assert that the created model satisfies the interface","category":"section"},{"location":"generated/custom_bus/#Compiling-bus-to-VertexModel","page":"Custom Generator Bus","title":"Compiling bus to VertexModel","text":"To actually simulate the system, we need to compile the model, i.e. transforming it from a purely symbolic representation to a numerical one.\n\ncompile_bus(mtkbus)","category":"section"},{"location":"generated/custom_bus/#Defining-a-Simulation-Scenario","page":"Custom Generator Bus","title":"Defining a Simulation Scenario","text":"To simulate the model, we need to define some kind of scenario. We'll create a simple two-bus system where our custom Milano machine is connected to a slack bus through a transmission line. This will allow us to observe the machine's dynamic behavior in response to a frequency disturbance.\n\nFirst, we create a slack bus that provides the voltage and frequency reference for the system.\n\nslackbus = compile_bus(\n    PowerDynamics.VariableFrequencySlack(name=:variable_slack),\n    vidx=1,\n    pf=pfSlack(V=1)\n)\n\nWe define a frequency event that increases the system frequency at t=1 second (see ND docs on Callbacks for details). This disturbance will cause our machine to respond dynamically as it tries to maintain synchronism with the network.\n\nfreq_event = PresetTimeComponentCallback(\n    1, # trigger at time 1\n    ComponentAffect([],[:V,:Ï‰]) do u, p, ctx\n        p[:Ï‰] = 1.01 # set frequency to 1.01 pu\n    end\n)\nset_callback!(slackbus, freq_event)\nnothing #hide\n\nNext, we create the generator bus using our custom Milano machine model. We specify it as a PV bus for the power flow with 1 pu voltage and 1 pu active power.\n\ngenbus = compile_bus(\n    mtkbus,\n    vidx=2,\n    pf=pfPV(V=1, P=1)\n)\n\nWe connect the two buses with a simple PI transmission line model.\n\nline = compile_line(MTKLine(PiLine(; name=:piline)); src=1,dst=2)\n\nNow we can build the complete network with our two buses and the connecting line.\n\nnw = Network([slackbus, genbus], line)\n\nBefore running dynamic simulation, we initialize the system from power flow. This ensures that all dynamic states start from a steady-state condition.\n\nTo do so, we use the function initialize_from_pf!, which does several steps:\n\nCalculate the powerflow according to the powerflow models.\nInitialize the \"free\" states and parameters of the dynamical components, such that the system is in a steady state.\n\nMore information on initialization can be found in the docs on Powergrid Initialization.\n\ninitialize_from_pf!(nw)\nnothing #hide\n\nLet's examine the initial state of our generator bus to verify proper initialization.\n\ndump_initial_state(nw[VIndex(2)])\n\nThe printout shows us several important aspects: The free internal states delta, omega and the free internal parameters P_mathrm m and vf_mathrmset have been initialized. We see, that both power and excitation voltage are slightly above the given (1,1) for the powerflow, which is expected since there are some losses in the model. However the initialized state matches the powerflow solution at the network interface, i.e. busbarâ‚ŠP and busbarâ‚Šu_mag are both 1 pu.","category":"section"},{"location":"generated/custom_bus/#Dynamic-Simulation","page":"Custom Generator Bus","title":"Dynamic Simulation","text":"With the system properly initialized, we can set up and solve the dynamic simulation. We simulate for 100 seconds to capture the machine's response to the frequency disturbance.\n\ns0 = NWState(nw)\nprob = ODEProblem(nw, s0, (0,100))\nsol = solve(prob, Rodas5P())\nnothing #hide","category":"section"},{"location":"generated/custom_bus/#Visualizing-the-Results","page":"Custom Generator Bus","title":"Visualizing the Results","text":"Now let's create comprehensive plots to visualize how our custom Milano machine responds to the frequency disturbance. We'll plot several key variables that demonstrate the machine's electromechanical dynamics.\n\nlet\n    fig = Figure(size=(800, 600));\n\n    ax1 = Axis(fig[1, 1];\n        title=\"Rotor Angle\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Rotor Angle Î´ [rad]\")\n    lines!(ax1, sol; idxs=VIndex(2, :machineâ‚ŠÎ´), linewidth=2)\n    axislegend(ax1)\n\n    ax2 = Axis(fig[2, 1];\n        title=\"Rotor Speed\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Rotor Speed Ï‰ [pu]\")\n    lines!(ax2, sol; idxs=VIndex(2, :machineâ‚ŠÏ‰), linewidth=2)\n    axislegend(ax2)\n\n    ax3 = Axis(fig[3, 1];\n        title=\"Machine Voltages\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Voltage [pu]\")\n    lines!(ax3, sol; idxs=VIndex(2, :machineâ‚ŠV_d), color=Cycled(1), linewidth=2)\n    lines!(ax3, sol; idxs=VIndex(2, :machineâ‚ŠV_q), color=Cycled(2), linewidth=2)\n    axislegend(ax3)\n    fig\nend","category":"section"},{"location":"generated/custom_bus/#Observing-the-Poor-Damping-Problem","page":"Custom Generator Bus","title":"Observing the Poor Damping Problem","text":"From the plots above, we can see that the Milano classical machine exhibits very lightly damped oscillations that persist for a very long time. The rotor angle and speed oscillate for hundreds of seconds without settling to a steady state.\n\nThis poor damping behavior occurs because:\n\nNo damper windings: The model lacks electromagnetic damping mechanisms\nConstant field voltage: No dynamic response to help stabilize the machine\nNo mechanical damping: The swing equation has no friction losses\n\nThe only source of damping here is, that we have specified a constant mechanical power rather than a constant mechanical torque.\n\nTo solve this problem, real power systems use control systems, particularly Power System Stabilizers (PSS) that are specifically designed to damp electromechanical oscillations.","category":"section"},{"location":"generated/custom_bus/#Adding-a-Power-System-Stabilizer-(PSS)","page":"Custom Generator Bus","title":"Adding a Power System Stabilizer (PSS)","text":"Let's create an improved machine model with controllable field voltage and add the simplest possible PSS to demonstrate the damping improvement.\n\nThe implemented PSS is a simple device, which adjusts the excitation voltage based on frequency deviation. It consists of a washout filter to remove steady-state errors and only react to frequency changes, and a gain to amplify the response.\n\nTo achieve this goal we will:\n\nModify the Milano machine model to include a controllable field voltage input and a rotor frequency measurement output.\nCreate a simple PSS model that takes the frequency input and outputs a stabilizing signal to the field voltage.\nCombine the machine and PSS into a new composite model that forms an injector.\nRepeat the simulation above with our new controlled-generator model and compare the results.","category":"section"},{"location":"generated/custom_bus/#Controllable-Machine-Model","page":"Custom Generator Bus","title":"Controllable Machine Model","text":"First, we create a modified Milano machine with control inputs/outputs: vf_in for field voltage and Ï‰_out for frequency output.\n\n@mtkmodel MilanoControllableMachine begin\n    @components begin\n        terminal=Terminal()\n        # Control interface\n        vf_in = RealInput(guess=1)  # field voltage input\n        Ï‰_out = RealOutput()        # frequency output for PSS\n    end\n    @parameters begin\n        R_s=0.000124, [description=\"stator resistance\"]\n        Xâ€²_d=0.0608, [description=\"d-axis transient reactance\"]\n        H=23.64, [description=\"inertia constant\"]\n        Ï‰_b=2Ï€*50, [description=\"System base frequency in rad/s\"]\n        P_m, [guess=1, description=\"mechanical power\"]\n    end\n    @variables begin\n        Î´(t), [guess=0, description=\"rotor angle\"]\n        Ï‰(t), [guess=1, description=\"rotor speed\"]\n        Ï„_e(t), [description=\"electrical torque\"]\n        I_d(t), [description=\"d-axis current\"]\n        I_q(t), [description=\"q-axis current\"]\n        V_d(t), [description=\"d-axis voltage\"]\n        V_q(t), [description=\"q-axis voltage\"]\n        Ïˆ_d(t), [description=\"d-axis flux linkage\"]\n        Ïˆ_q(t), [description=\"q-axis flux linkage\"]\n    end\n    begin\n        T_to_loc(Î±)  = [ sin(Î±) -cos(Î±);\n                         cos(Î±)  sin(Î±)]\n        T_to_glob(Î±) = [ sin(Î±)  cos(Î±);\n                        -cos(Î±)  sin(Î±)]\n    end\n    @equations begin\n        # Park's transformations\n        [terminal.u_r, terminal.u_i] .~ T_to_glob(Î´)*[V_d, V_q]\n        [I_d, I_q] .~ T_to_loc(Î´)*[terminal.i_r, terminal.i_i]\n\n        # mechanical swing equation Milano 15.5\n        Dt(Î´) ~ Ï‰_b*(Ï‰ - 1)\n        2*H * Dt(Ï‰) ~ P_m/Ï‰ - Ï„_e\n\n        # static flux linkage equations Milano 15.11\n        Ïˆ_d ~  V_q + R_s*I_q\n        Ïˆ_q ~ -V_d - R_s*I_d\n\n        # electrical torque Milano 15.6\n        Ï„_e ~ Ïˆ_d*I_q - Ïˆ_q*I_d\n\n        # magnetic equations from static model Milano 15.36\n        0 ~ V_q + R_s*I_q + Xâ€²_d*I_d - vf_in.u  # Use controllable input\n        0 ~ V_d + R_s*I_d - Xâ€²_d*I_q\n\n        # Control interface - output frequency for PSS\n        Ï‰_out.u ~ Ï‰\n    end\nend\nnothing #hide","category":"section"},{"location":"generated/custom_bus/#Simple-Power-System-Stabilizer","page":"Custom Generator Bus","title":"Simple Power System Stabilizer","text":"The simplest PSS consists of a washout filter with gain. The washout filter ensures the PSS only responds to frequency changes, not steady-state errors.\n\n@mtkmodel SimplePSS begin\n    @components begin\n        Ï‰_in = RealInput() # frequency input from machine\n        vst = RealOutput() # stabilizer output signal\n    end\n    @parameters begin\n        Tw=10, [description=\"washout time constant\"]\n        Ks=20, [description=\"stabilizer gain\"]\n    end\n    @variables begin\n        y(t), [guess=0, description=\"washout filter output\"]\n    end\n    @equations begin\n        # Washout filter: dy/dt = (Ï‰ - y)/Tw\n        Dt(y) ~ (Ï‰_in.u - y) / Tw\n        # output gain\n        vst.u ~ Ks * (Ï‰_in.u - y)\n    end\nend\nnothing #hide","category":"section"},{"location":"generated/custom_bus/#Complete-Generator-with-PSS","page":"Custom Generator Bus","title":"Complete Generator with PSS","text":"The PSS only adds an offset to the field voltage based on the frequency input. Therefore, our combined injector model needs to look something like this:\n\n    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n    â”‚GeneratorWithPss           â”‚\n    â”‚         â•­â”€â”€â”€â”€â”€â†’â”€â”€â”€â”€â”€â•®     â”‚\n(t) â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â” Ï‰_out â”Œâ”€â”´â”€â”€â”€â” â”‚\n oâ”€â”€â”¼â”€â”¤ Machine â”‚       â”‚ PSS â”‚ â”‚\n    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”˜       â””â”€â”¬â”€â”€â”€â”˜ â”‚\n    â”‚   vf_in â•°â”€â”€â†â”€(+)â”€â”€â†â”€â•¯ vst â”‚\n    â”‚               â†‘           â”‚\n    â”‚            vf_base        â”‚\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nNotably, similar to how we left vf_set free for initialization in the previous example, now we need to leave vf_base free.\n\nWe define a new mtkmodel which combines machine with controller and forms a new injector:\n\n@mtkmodel GeneratorWithPSS begin\n    @components begin\n        terminal = Terminal()\n        machine = MilanoControllableMachine()\n        pss = SimplePSS()\n    end\n    @parameters begin\n        vf_base, [guess=1.0, description=\"base field voltage\"]\n    end\n    @equations begin\n        # Connect terminals\n        connect(terminal, machine.terminal)\n        # Connect control loop: machine frequency â†’ PSS â†’ back to machine field voltage\n        connect(machine.Ï‰_out, pss.Ï‰_in)\n        # Sum base field voltage with PSS output\n        machine.vf_in.u ~ vf_base + pss.vst.u\n    end\nend\n\n@named gen_with_pss = GeneratorWithPSS()\nisinjectormodel(gen_with_pss) # Verify it's still an injector\n\nSince this is an injector, we can use MTKBus(gen_with_pss) to build the symbolic bus model. However, this leads to another level of namespacing, as the overall bus will have variable names like gen_with_pssâ‚Šmachineâ‚ŠÎ´ due to the encapsulation.\n\nAlternatively, we could define a model which directly implements the MTKBus interface:\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚MyMTKBus                             â”‚\nâ”‚                   â•­â”€â”€â”€â”€â”€â†’â”€â”€â”€â”€â”€â•®     â”‚\nâ”‚â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â” Ï‰_out â”Œâ”€â”´â”€â”€â”€â” â”‚\nâ”‚â”‚BusBarâ”œâ”€oâ”€â”¤ Machine â”‚       â”‚ PSS â”‚ â”‚\nâ”‚â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”˜       â””â”€â”¬â”€â”€â”€â”˜ â”‚\nâ”‚             vf_in â•°â”€â”€â†â”€(+)â”€â”€â†â”€â•¯ vst â”‚\nâ”‚                         â†‘           â”‚\nâ”‚                      vf_base        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n@mtkmodel CustomMTKBus begin\n    @components begin\n        busbar = BusBar()\n        machine = MilanoControllableMachine()\n        pss = SimplePSS()\n    end\n    @parameters begin\n        vf_base, [guess=1.0, description=\"base field voltage\"]\n    end\n    @equations begin\n        connect(busbar.terminal, machine.terminal)\n        connect(machine.Ï‰_out, pss.Ï‰_in)\n        machine.vf_in.u ~ vf_base + pss.vst.u\n    end\nend\n@named genbus_custom = CustomMTKBus()\n@assert isbusmodel(genbus_custom)\n\nIn practice, it doesn't really matter which approach you choose, as both will work. However this highlights the flexibility of the MTK modeling framework before you go to the compiled-model domain by calling compile_bus on the model fulfilling the MTKBus interface.","category":"section"},{"location":"generated/custom_bus/#Simulation-with-PSS","page":"Custom Generator Bus","title":"Simulation with PSS","text":"Now let's run the same simulation scenario with the PSS-equipped generator to observe the damping improvement.\n\nCreate the improved generator bus with simple PSS\n\ngenbus_pss = compile_bus(\n    MTKBus(gen_with_pss; name=:bus_pss),\n    vidx=2,\n    pf=pfPV(V=1, P=1)\n)\n\nCreate network with PSS-equipped generator\n\nnw_pss = Network([slackbus, genbus_pss], line)\ninitialize_from_pf!(nw_pss)\nnothing #hide\n\nRun simulation with simple PSS\n\ns0_pss = NWState(nw_pss)\nprob_pss = ODEProblem(nw_pss, s0_pss, (0,100))\nsol_pss = solve(prob_pss, Rodas5P())\nnothing #hide","category":"section"},{"location":"generated/custom_bus/#Comparing-Results:-With-and-Without-PSS","page":"Custom Generator Bus","title":"Comparing Results: With and Without PSS","text":"Let's create comparison plots to clearly see the damping improvement:\n\nlet\n    fig = Figure(size=(800, 600));\n\n    # Compare rotor speeds\n    ax1 = Axis(fig[1, 1];\n        title=\"Rotor Speed Comparison: Effect of PSS on Damping\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Rotor Speed Ï‰ [pu]\")\n    lines!(ax1, sol; idxs=VIndex(2, :machineâ‚ŠÏ‰), label=\"No PSS\", color=Cycled(2))\n    lines!(ax1, sol_pss; idxs=VIndex(2, :gen_with_pssâ‚Šmachineâ‚ŠÏ‰), label=\"Simple PSS\", color=Cycled(1), linewidth=2)\n    axislegend(ax1, position=:rt)\n    xlims!(ax1, 0, 30)  # Focus on first 30 seconds\n\n    # PSS Output - shows the actual stabilizer signal\n    ax2 = Axis(fig[2, 1];\n        title=\"PSS Output Signal\",\n        xlabel=\"Time [s]\",\n        ylabel=\"PSS Output [pu]\")\n    lines!(ax2, sol_pss; idxs=VIndex(2, :gen_with_pssâ‚Špssâ‚Švstâ‚Šu), label=\"PSS Output\", linewidth=2)\n    axislegend(ax2, position=:rt)\n    xlims!(ax2, 0, 30)\n\n    fig\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#PowerDynamics","page":"Home","title":"PowerDynamics","text":"PowerDynamics.jl is a Julia package for modeling and simulating power grid dynamics. It provides a comprehensive framework for analyzing electrical power systems, including synchronous machines, loads, lines, and various control elements. The package is built on top of NetworkDynamics.jl and offers both predefined component models and the flexibility to create custom power system components.\n\nwarning: PowerDynamics.Library Under Active Development\nThe PowerDynamics.Library component library is currently excluded from semantic versioning and is under heavy development.While PowerDynamics itself follows semantic versioning, the Library submodule's API is highly unstable and variable names, function signatures, and model interfaces may change frequently without notice. If you are using specific models from PowerDynamics.Library in their current state, we strongly recommend copying them to your own source code to avoid breaking changes in future updates.","category":"section"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"The documentation is roughly split into 3 parts: we have the reference and concepts documentation, which contains technical descriptions of different aspects of PowerDynamics.jl. We have the Tutorials, which are pedagogical examples which aim to show a specific aspect of working with the package and we have the advanced examples, which are less focused than the tutorials but also consist of copy-pastable examples showing different aspects of modeling and simulation.\n\nIf you're new to Julia, start with the Julia Setup guide to set up your development environment.\n\nAs a first step, it is advised to read through the Getting Started tutorial to understand the core philosophy and SciML integration. Then, work through the Typical Simulation Workflow tutorial for a hands-on walkthrough of building and simulating a power system. Afterwards, it's a good idea to read on the Modeling Concepts.\n\nIt is also highly recommended to check out the docs on NetworkDynamics.jl as those explain lots of the underlying functionality and concepts","category":"section"},{"location":"#Reference-and-Concepts","page":"Home","title":"Reference & Concepts","text":"Modeling Concepts - Learn the fundamental concepts behind PowerDynamics modeling\nComponent Library - Explore the available power system component models\nPowergrid Initialization - Understand how to properly initialize power system simulations\nAPI Reference - Complete function and type documentation","category":"section"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"Getting Started - Introduction to the core philosophy behind PowerDynamics.jl and its integration with the SciML ecosystem\nTypical Simulation Workflow - Hands-on walkthrough of a small 3-bus example system, covering all stages from modeling to simulation\nCustom Components - Shows how to implement Milano's classical synchronous machine model with a power system stabilizer (PSS)\nCustom Transmission Lines - Demonstrates creating a PI-branch transmission line model with overcurrent protection that can trip during faults","category":"section"},{"location":"#Advanced-Examples","page":"Home","title":"Advanced Examples","text":"IEEE 9-Bus System - Simulates the complete 9-bus IEEE test system with synchronous generators and dynamic load changes\nIEEE 39-Bus System Part 1 - Shows how to build the 39-bus New England test system from custom CSV data files with proper component modeling\nIEEE 39-Bus System Part 2 - Demonstrates the detailed initialization process for the 39-bus system including power flow and initialization of dynamic models\nIEEE 39-Bus System Part 3 - Runs dynamic simulation of the 39-bus system with a short circuit disturbance and fault clearing\nIEEE 39-Bus System Part 4 - Implements a custom droop-controlled inverter model and performs parameter optimization using sensitivity analysis\nEMT Toy Model Example - Demonstrates very basic EMT modeling using dynamic shunt capacitor and RL transmission line components in rotating dq coordinates","category":"section"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"<details><summary>Direct dependencies used for this documentation:</summary>\n\nusing Pkg #hide\nPkg.status() #hide\n\n</details>\n\n<details><summary>Julia Version:</summary>\n\nusing InteractiveUtils #hide\nversioninfo() #hide\n\n</details>\n\n<details><summary>Full Manifest:</summary>\n\nusing Pkg #hide\nPkg.status(; mode = PKGMODE_MANIFEST) #hide\n\n</details>","category":"section"},{"location":"#Funding","page":"Home","title":"Funding","text":"Development of this project was in part funded by the German Federal Ministry for Economic Affairs and Climate Action as part of the OpPoDyn-Project (Project ID 01258425/1, 2024-2027).\n\n<img src=\"assets/bmwk_logo_en.svg\" width=\"300\"/>","category":"section"}]
}
