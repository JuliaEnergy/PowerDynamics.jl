var documenterSearchIndex = {"docs":
[{"location":"#","page":"General","title":"General","text":"(Image: Build Status) (Image: Chat on Slack.) (Image: Get your Slack invitation.) (Image: Code on Github.)","category":"page"},{"location":"#PowerDynamics.jl-Dynamic-Power-System-Analysis-in-Julia-1","page":"General","title":"PowerDynamics.jl - Dynamic Power System Analysis in Julia","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"This package provides all the tools you need to create a dynamic power grid model and analyze it.","category":"page"},{"location":"#","page":"General","title":"General","text":"The source code is licensed under GPLv3 and published on github.","category":"page"},{"location":"#","page":"General","title":"General","text":"These Docs have been built","category":"page"},{"location":"#","page":"General","title":"General","text":"using Dates\nfunction printBuiltTime()\n  println(Dates.format(now(), \"on YYYY-mm-dd at HH:MM\"))\nend","category":"page"},{"location":"#","page":"General","title":"General","text":"printBuiltTime() # hide","category":"page"},{"location":"#","page":"General","title":"General","text":"with the following version of the sub-packages:","category":"page"},{"location":"#","page":"General","title":"General","text":"using Pkg\nenv = Pkg.Types.EnvCache()\nsubpackages = copy(env.project[\"deps\"])\nuuids = map(Base.UUID, values(subpackages))\nfunction printversions()\n  for uuid in uuids\n    pkg = Pkg.Types.manifest_info(env, uuid)\n    println(rpad(\" * $(pkg[\"name\"]) \", 30, \".\"), \" $(pkg[\"version\"])\")\n  end\nend","category":"page"},{"location":"#","page":"General","title":"General","text":"printversions() # hide","category":"page"},{"location":"#Installation-1","page":"General","title":"Installation","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"The installation can be done via the new package manager. Either use","category":"page"},{"location":"#","page":"General","title":"General","text":"]add PowerDynamics","category":"page"},{"location":"#","page":"General","title":"General","text":"or copy","category":"page"},{"location":"#","page":"General","title":"General","text":"using Pkg; Pkg.add(\"PowerDynamics\")","category":"page"},{"location":"#","page":"General","title":"General","text":"Please note that PowerDynamics.jl is a fast developing library whose API is not settled yet. In order to ensure that your old code will still work in the future while using the latest version of PowerDynamics.jl for your new code, we strongly recommend the usage of environments. Please check out this video from the introduction of Pkg3, where environments are introduced, too.","category":"page"},{"location":"#Compatibility-1","page":"General","title":"Compatibility","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"PowerDynamics.jl is written for Julia 1.0 and above. We will quickly switch to new Julia version as they come out, but support older versions and enable long transition periods for users. Julia versions 0.x are not supported.","category":"page"},{"location":"#Usage-1","page":"General","title":"Usage","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Generally, we distinguish three types of user for PowerDynamics.jl:","category":"page"},{"location":"#","page":"General","title":"General","text":"Grid Modeler\nGrid Component Developer\nPowerDynamics.jl Developer","category":"page"},{"location":"#Grid-Modeler-1","page":"General","title":"Grid Modeler","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Your Goal is to use PowerDynamics.jl to model your grid of preference. You don't want to implement new types of nodes.","category":"page"},{"location":"#","page":"General","title":"General","text":"We recommend you to choose your favorite example from PowerDynamicsExamples, read Node Types and try to understand it. That should give you the kickstart you need. If you have any questions, contact us.","category":"page"},{"location":"#Grid-Component-Developer-1","page":"General","title":"Grid Component Developer","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Your Goal is to use PowerDynamics.jl to develop types of nodes, e.g. new control schemes for inverters or new descriptions of synchronous machines.","category":"page"},{"location":"#","page":"General","title":"General","text":"After going through the introduction for a Grid Modeler, we recommend that you read through Dynamics Types and Custom Node Types and try to implement a new node type for an example grid. With that, you should have all the tools you need. If you have any questions, contact us.","category":"page"},{"location":"#PowerDynamics.jl-Developer-1","page":"General","title":"PowerDynamics.jl Developer","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Your Goal is to extend PowerDynamics.jl with new fundamental functionalities.","category":"page"},{"location":"#","page":"General","title":"General","text":"After going throught the introduction for a Grid Modeler and a Grid Component Developer, read through the code where hopefully all of this documentation will helpful for you. Afterwards, it's probably best to open an issue explainng the idea you want to implement and we can discuss how you can transform your idea into a pull request.","category":"page"},{"location":"language_conventions/#Language-and-Conventions-1","page":"Language & Conventions","title":"Language & Conventions","text":"","category":"section"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"Generally, variables are miniscule (e.g. u, i, ω) and parameters are capitalized (e.g. H, D, P, Ω). As it is common to use greek letters for modeling equations and Julia supports Unicode, greek letters are used within the Code, e.g. Ω and ω in PowerDynamics.SwingEq. If you don't want to use greek keyboard (which I am currently switching to) you can simply type the latex representating \\Omega and Atom can complete it with Ω using Tab.","category":"page"},{"location":"language_conventions/#List-of-symbols-and-corresponding-names-1","page":"Language & Conventions","title":"List of symbols and corresponding names","text":"","category":"section"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"Symbol (Code) Symbol (Math) Name within PowerDynamics.jl Common alternative names\n  node bus, vertex\n  grid network, power grid, power network\n y_ab = y_ba admittance between nodes a and b \nLY Y^L admittance laplacian (nodal) admittance matrix\nt t time \nim j imaginary element sqrt-1\nu = v \\cdot exp(im*φ) u = v cdot e^jφ complex voltage \nv v voltage magnitude absolute voltage\nφ phi voltage angle \ni_c = i \\cdot exp(im*δ) i_c = i cdot e^jdelta nodal complex current \ni i magnitude of the current \nδ delta angle of the current \ns = p + im*q s = p + jq complex power \np p real power active power\nq q imaginary power reactive power","category":"page"},{"location":"language_conventions/#List-of-modeling-conventions-1","page":"Language & Conventions","title":"List of modeling conventions","text":"","category":"section"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"Counting of nodes starts at 1.\nRanges of nodes are mathematical, i.e. they include the first and the last element. For example sum_k=3^6 sums over 3, 4, 5, and 6.\nFor now, no selfadmittance is allowed, i.e. y_aa = 0 for all nodes a.\nThe admittance laplacian uses the following definition (convention from wikipedia)","category":"page"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"Y^L_ab = begincases\n  sum_c y_ac  textif  a=b \n  -y_ab  textotherwise\nendcases","category":"page"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"The nodal complex current is calculated as","category":"page"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"i_c_a = sum_b LY_ab u_b ","category":"page"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"The complex power is calculated as (with ^* as complex conjugation)","category":"page"},{"location":"language_conventions/#","page":"Language & Conventions","title":"Language & Conventions","text":"s_a = u_a cdot i_c_a^*","category":"page"},{"location":"node_dynamics_types/#Dynamics-Types-1","page":"Dynamics Types","title":"Dynamics Types","text":"","category":"section"},{"location":"node_dynamics_types/#Network-Dynamics-1","page":"Dynamics Types","title":"Network Dynamics","text":"","category":"section"},{"location":"node_dynamics_types/#","page":"Dynamics Types","title":"Dynamics Types","text":"to be done","category":"page"},{"location":"node_types/#Node-Types-1","page":"Node Types","title":"Node Types","text":"","category":"section"},{"location":"node_types/#","page":"Node Types","title":"Node Types","text":"The currently implementes node types are","category":"page"},{"location":"node_types/#","page":"Node Types","title":"Node Types","text":"using InteractiveUtils, PowerDynamics, Markdown\nnodetypes = subtypes(PowerDynamics.AbstractNodeParameters)\njoin([\"* [`$n`](@ref PowerDynamics.$n)\" for n in nodetypes], \"\\n\") |> Markdown.parse","category":"page"},{"location":"node_types/#Detailed-Node-Type-Documentation-1","page":"Node Types","title":"Detailed Node Type Documentation","text":"","category":"section"},{"location":"node_types/#","page":"Node Types","title":"Node Types","text":"PowerDynamics.AbstractNodeParameters","category":"page"},{"location":"node_types/#","page":"Node Types","title":"Node Types","text":"Modules = [PowerDynamics]\nFilter = t -> typeof(t) === DataType","category":"page"},{"location":"node_types/#PowerDynamics.CSIMinimal","page":"Node Types","title":"PowerDynamics.CSIMinimal","text":"CSIMinimal(;I_r)\n\nA node type that keeps the current fixed as a desired values I_r.\n\nCSIMinimal models an inverters as an ideal current source. This can be the most simple representation of an inverter in grid-feeding mode, according to Rocabert, Joan, et al. \"Control of power converters in AC microgrids.\" (2012). Here, additionally to u, there are no internal dynamic variables.\n\nKeyword Arguments\n\nI_r: reference/ desired current\n\nMathematical Representation\n\nUsing CSIMinimal for node a gives:\n\n0 = I_ra - lefti_aright\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.ExponentialRecoveryLoad","page":"Node Types","title":"PowerDynamics.ExponentialRecoveryLoad","text":"ExponentialRecoveryLoad(P0, Q0, Nps, Npt, Nqs, Nqt, Tp, Tq, V0)\n\nA node type that represents the exponential recovery load model. The exponential recovery load model aims to capture the load restoration characteristics with an exponential recovery process expressed as an input–output relationship between powers (real and reactive) and voltage.\n\nKeyword Arguments\n\nP0: Active power load demand [pu]\nQ0: Reactive power load demand [pu]\nNps: Steady-state load voltage dependence p-axis [pu]\nNpt: Transient load voltage dependence p-axis [pu]\nNqs: Steady-state load voltage dependence q-axis [pu]\nNqt: Transient load voltage dependence q-axis [ pu]\nTp: Load recovery constant p-axis [s]\nTq: Load recovery constant q-axis [s]\nV0: Reference grid voltage [pu]\n\nMathematical Representation\n\n\tdfracdx_pdt = dfrac1T_p(-x_p + P_0(dfracabs(u)V_0)^N_ps - P_0(dfracabs(u)V_0)^N_pt) \n    dfracdx_qdt = dfrac1T_q(-x_q + Q_0(dfracabs(u)V_0)^N_qs - Q_0(dfracabs(u)V_0)^N_qt) \n    P = x_p + P_0(dfracabs(u)V_0)^N_pt \n    Q = x_q - Q_0(dfracabs(u)V_0)^N_qt \n\nIEEE TRANSACTIONS ON POWER SYSTEMS, VOL. 21, NO. 3, AUGUST 2006 Measurement-Based Dynamic Load Models: Derivation, Comparison, and Validation Byoung-Kon Choi, Member, IEEE, Hsiao-Dong Chiang, Fellow, IEEE, Yinhong Li, Hua Li, Member, IEEE, Yung-Tien Chen, Der-Hua Huang, and Mark G. Lauby\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.FourthOrderEq","page":"Node Types","title":"PowerDynamics.FourthOrderEq","text":"FourthEq(H, P, D, Ω, E_f, T_d_dash ,T_q_dash ,X_q_dash ,X_d_dash,X_d, X_q)\n\nA node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics, which is implemented according to P. Sauer, \"Power System Dynamics and Stability\". For an illustration of a synchronous machine schematic see P. Sauer, Fig. 3.1 on p. 25.\n\nUsually the swing equation (SwingEq) is used for short time periods to analyze the transient behavior of generators in a power grid, the so-called first swing. The 4th-order model  also takes the back reaction of the power flow onto the voltage into account. This has the effect that the angle of the voltage as seen by the power grid, and the angle of the rotating mass are no longer the same but become dynamically coupled.\n\nAdditionally to u, it has the internal dynamic variables\n\nω representing the frequency of the rotator relative to the grid frequency Ω, i.e. the real frequency ω_r of the rotator is given as omega_r = Omega + omega and\nθ representing the relative angle of the rotor with respect to the voltage angle ϕ.\n\nKeyword Arguments\n\nH: shaft inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)\nP: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]\nD: damping coefficient (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal Dω)\nΩ: rated frequency of the power grid, often 50Hz\nT_d_dash: time constant of d-axis, given in [s], see P. Sauer, chapter 3.7, p. 54 for a general explanation on time constants\nT_q_dash: time constant of q-axis, given in [s]\nX_d_dash: transient reactance of d-axis, given in [pu]\nX_q_dash: transient reactance of q-axis, given in [pu]\nX_d: reactance of d-, given in [pu]\nX_d: reactance of q-axis, given in [pu]\nE_f: scaled field voltage, which, if set equal to 1.0 pu, gives 1.0 pu open-circuit terminal voltage. The physical device that provides the value of E_f is called the exciter (according to P. Sauer, p. 65)\n\nMathematical Representation\n\nUsing FourthEq for node a applies the equations\n\n    u = -je_c e^jtheta = -j(e_d + je_q)e^jtheta\n    e_c= e_d + je_q = jue^-jtheta\n    i  = -jie^jtheta = -j(i_d+ j i_q )e^jtheta = Y^L cdot u \n    i_c= i_d + ji_q = jie^-jtheta\n    p = Re (i^* u)\n\nwhere complex voltage and current are described in a co-rotating frame with axes labeled d and q.\n\nThe fourth-order equations read (according to P. Sauer, \"Power System Dynamics and Stability\", p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)\n\n    fracdthetadt = omega \n     fracdomegadt = (P-Domega - p -(X_q-X_d)i_d i_q)Ω_H\n    fracd e_qdt = frac1T_d (- e_q - (X_d - X_d) i_d+ E_f) \n    fracd e_ddt = frac1T_q (- e_d + (X_q - X_q) i_q)  \n\nThe equations for frequency and phase represent energy conservation and phase shift. The dynamic equations for the complex voltage show the relationship between the dynamicy of flux linkages and currents which must reflect a conservative coupling field.\n\nWith the PowerDynamics.jl naming conventions of i and u they read as\n\n   dot u = fracddt(-j e_c e^jtheta)=-j(dot e_d + jdot e_q)e^jtheta + ujomega\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.FourthOrderEqGovernorExciterAVR","page":"Node Types","title":"PowerDynamics.FourthOrderEqGovernorExciterAVR","text":"FourthOrderEqGovernorExciterAVR(H, P, D, Ω, T_d_dash ,T_q_dash ,X_q_dash ,X_d_dash,X_d, X_q, T_e, T_a, T_f, K_e, K_a, K_f, V_ref, R_d, T_sv, T_ch)\n\nA node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics, including an Exciter, Automatic Voltage Regulator and Governor which is implemented according to P. Sauer, \"Power System Dynamics and Stability\". For an illustration of a synchronous machine schematic see P. Sauer, Fig. 3.1 on p. 25.\n\nExciter and Automatic Voltage Regulator: The equations for the systems that balance the AC synchronous machine voltage level by increasing or decreasing the exciter DC voltage. Note, within this model, the transient reactance in the d-axis of the generator needs to be included into the nodal admittance matrix. As the bus of this generator node type is constructed to be an internal generator bus.\n\nGovernor: The prime mover provides the mechanism for controlling the synchronous machine speed and, hence, terminal voltage frequency.\n\nUsually the swing equation (SwingEq) is used for short time periods to analyze the transient behavior of generators in a power grid, the so-called first swing. The 4th-order model  also takes the back reaction of the power flow onto the voltage into account. This has the effect that the angle of the voltage as seen by the power grid, and the angle of the rotating mass are no longer the same but become dynamically coupled.\n\nAdditionally to u, it has the internal dynamic variables\n\nω representing the frequency of the rotator relative to the grid frequency Ω, i.e. the real frequency ω_r of the rotator is given as omega_r = Omega + omega and\nθ representing the relative angle of the rotor with respect to the voltage angle ϕ.\n\nKeyword Arguments\n\nH: shaft inertia constant (given in [s]), defined according to P. Sauer, p. 33, eq. (3.60)\nP: active (real) power output, also called the mechanical torque applied to the shaft, given in [pu]\nD: damping coefficient (given in [s], see P. Sauer, eq. (5.156) where the damping torque is equal Dω)\nΩ: rated frequency of the power grid, often 50Hz\nT_d_dash: time constant of d-axis, given in [s], see P. Sauer, chapter 3.7, p. 54 for a general explanation on time constants\nT_q_dash: time constant of q-axis, given in [s]\nX_d_dash: transient reactance of d-axis, given in [pu]\nX_q_dash: transient reactance of q-axis, given in [pu]\nX_d: reactance of d-, given in [pu]\nX_d: reactance of q-axis, given in [pu]\n'T_e' : Exciter time constant, integration rate associated with exciter control [s]\n'T_a' : Maximum voltage regulator output [s]\n'T_f' : Excitation control system stabilizer time constant [s]\n'K_e' : Exciter constant related to self-excited field [pu]\n'K_a' : Voltage Regulator gain [pu]\n'K_f' : Excitation control system stabilizer gains [pu]\n'V_ref' : Reference voltage for the AVR [pu]\n'Rd' : Speed regulation [2πdroop/ωs]\n'T_sv' : Steam Valve time constant [s]\n'T_ch' : Steam Chest time constant [s]\n\nMathematical Representation Synchronous Machine\n\nUsing FourthEq for node a applies the equations\n\n    u = -je_c e^jtheta = -j(e_d + je_q)e^jtheta\n    e_c= e_d + je_q = jue^-jtheta\n    i  = -jie^jtheta = -j(i_d+ j i_q )e^jtheta = Y^L cdot u \n    i_c= i_d + ji_q = jie^-jtheta\n    p = Re (i^* u) \n\nwhere complex voltage and current are described in a co-rotating frame with axes labeled d and q.\n\nThe fourth-order equations read (according to P. Sauer, \"Power System Dynamics and Stability\", p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)\n\n    fracdthetadt = omega \n    fracdomegadt = (P-Domega - p -(X_q-X_d)i_d i_q)Ω_H\n    fracd e_qdt = frac1T_d (- e_q - (X_d - X_d) i_d+ E_f) \n    fracd e_ddt = frac1T_q (- e_d + (X_q - X_q) i_q) \n\nExciter and AVR equations\n\n\tu_terminal = e_c - j X_d i \n\tS_e(e_fd) = 0098e^055 e_fd (according to P Sauer p 70) \n\tdfracdR_fdt = dfrac1T_f (-R_f + dfracK_fT_f e_f) \n\tdfracdv_rdt = dfrac1T_a (-v_r + (K_a R_f) -dfracK_a K_fT_fe_fd + K_a (V_ref - abs(u_terminal))) \n\tdfracde_fddt = dfrac1T_e (-K_e + S_e(e_fd)e_fd + v_r) \n\nGovernor equations\n\n    dfracdP_mdt = dfrac1T_ch (-P_m + P_sv) \n    Assumption T_m = P_m \n    dfracdP_svdt = dfrac1T_sv (-P_sv + P_c -dfrac1R_d (dfracomegaomega_s - 1)) \n\nThe equations for frequency and phase represent energy conservation and phase shift. The dynamic equations for the complex voltage show the relationship between the dynamicy of flux linkages and currents which must reflect a conservative coupling field.\n\nWith the PowerDynamics.jl naming conventions of i and u they read as\n\n   dot u = fracddt(-j e_c e^jtheta)=-j(dot e_d + jdot e_q)e^jtheta + ujomega \n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.PQAlgebraic","page":"Node Types","title":"PowerDynamics.PQAlgebraic","text":"PQAlgebraic(;S)\n\nA node type that locally fixes the active (P) and reactive power (Q) output of the node.\n\nKeyword Arguments\n\nS = P + Q*im: the complex power output\n\nMathematical Representation\n\nUsing PQAlgebraic for node a applies the equation\n\n0 = S_a - u_a cdot i_a^*\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.PVAlgebraic","page":"Node Types","title":"PowerDynamics.PVAlgebraic","text":"PVAlgebraic(;P,V)\n\nA node type that locally fixes the active power (P) and the voltage magnitude (V) of the node.\n\nKeyword Arguments\n\nP: the active (real) power output\nV: voltage magnitude\n\nMathematical Representation\n\nUsing PVAlgebraic for node a applies the equations\n\n0 = P_a - Releft(u_a cdot i_a^*right) \n0 = V_a - leftu_aright\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.PowerGrid","page":"Node Types","title":"PowerDynamics.PowerGrid","text":"Encapsulates nodes & lines of the power grid and a graph connecting both.\n\n\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.SlackAlgebraic","page":"Node Types","title":"PowerDynamics.SlackAlgebraic","text":"SlackAlgebraic(;U)\n\nA node type that locally fixes the complex voltage (U) of the node.\n\nAs the complex voltage can be represented as U=Ve^iphi, this is equivlant to fixing the voltage magnitude V and the angle phi.\n\nKeyword Arguments\n\nU: the complex voltage\n\nMathematical Representation\n\nUsing SlackAlgebraic for node a applies the equation\n\n0 = U_a - u_a\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.SwingEq","page":"Node Types","title":"PowerDynamics.SwingEq","text":"SwingEq(;H, P, D, Ω)\n\nA node type that applies the swing equation to the frequency/angle dynamics and keeps the voltage magnitude as is.\n\nAdditionally to u, it has the internal dynamic variable omega representing the frequency of the rotator relative to the grid frequency Omega, i.e. the real frequency omega_r of the rotator is given as omega_r = Omega + omega.\n\nKeyword Arguments\n\nH: inertia\nP: active (real) power output\nD: damping coefficient\nΩ: rated frequency of the power grid, often 50Hz\n\nMathematical Representation\n\nUsing SwingEq for node a applies the equations\n\nfracdu_adt = i u_a  omega_a \nfracH2piOmegafracdomega_adt = P_a - D_aomega_a - Releft(u_a cdot i_a^*right)\n\nwhich is equivalent to\n\nfracdphi_adt = omega \nv = v(t=0) = textconst \nfracH2piOmegafracdomega_adt = P_a - D_aomega_a - Releft(u_a cdot i_a^*right)\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.SwingEqLVS","page":"Node Types","title":"PowerDynamics.SwingEqLVS","text":"SwingEqLVS(;H, P, D, Ω, Γ, V)\n\nA node type that applies the swing equation to the frequency/angle dynamics and has a linear voltage stability (LVS) term.\n\nAdditionally to u, it has the internal dynamic variable omega representing the frequency of the rotator relative to the grid frequency Omega, i.e. the real frequency omega_r of the rotator is given as omega_r = Omega + omega.\n\nKeyword Arguments\n\nH: inertia\nP: active (real) power output\nD: damping coefficient\nΩ: rated frequency of the power grid, often 50Hz\nΓ: voltage stability coefficient\nV: set voltage, usually 1\n\nMathematical Representation\n\nUsing SwingEq for node a applies the equations\n\nfracdu_adt = i u_a omega - fracuu Γ_a  (v_a - V_a) \nfracH2piOmegafracdomega_adt = P_a - D_aomega_a - Releft(u_a cdot i_a^*right)\n\nwhich is equivalent to\n\nfracdphi_adt = omega_a \nfracdv_adt = - Γ_a  (v_a - V_a) \nfracH2piOmegafracdomega_adt = P_a - D_aomega_a - Releft(u_a cdot i_a^*right)\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.VSIMinimal","page":"Node Types","title":"PowerDynamics.VSIMinimal","text":"VSIMinimal(;τ_P,τ_Q,K_P,K_Q,E_r,P,Q)\n\nA node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics.\n\nVSIMinimal models an inverters as AC voltage source which means the amplitude and frequency can defined by the designer (often called grid-forming inverter mode). The frequency and voltage regulation is assumed to be instantaneous. In addition simple proportional controllers are implemented for frequency and voltage such that the frequency ω and voltage amplitudes v of the inverters are modified depending on the deviations (with respect to a desired value) of the active and reactive powers, respectively. ift is assumed that active and reactive power are measured via low pass fileters with time constant τ_P and τ_Q, respectively. VSIMinimal can be derived from VSIVoltagePT1 by assuming an instantaneous voltage regulation without delay.\n\nAdditionally to u, it has the internal dynamic variable ω representing the frequency of the rotator relative to the grid frequency Ω, i.e. the real frequency ω_r of the rotator is given as ω_r = Ω + ω.\n\nKeyword Arguments\n\nτ_p: time constant active power measurement\nτ_Q: time constant reactive power measurement\nK_P: droop constant frequency droop\nK_Q: droop constant voltage droop\nV_r: reference/ desired voltage\nP: active (real) power infeed\nQ: reactive (imag) power infeed\n\nMathematical Representation\n\nUsing VSIMinimal for node a (according to J. Schiffer et. al., eq. (7)) gives the equations\n\ndotphi_a=omega_a\n dotomega_a=frac1tau_Pa-omega_a-K_Pa (Releft(u_a cdot i_a^*right)-P_a)\ntau_Qdotv_a=-v_a+V_r-K_Qa (Imleft(u_a cdot i_a^*right)-Q_a)\n dotu_a=dotv_ae^jphi+jomega_a u_a\n\n```\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.VSIVoltagePT1","page":"Node Types","title":"PowerDynamics.VSIVoltagePT1","text":"VSIVoltagePT1(;τ_v,τ_P,τ_Q,K_P,K_Q,E_r,P,Q)\n\nA node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics.\n\nVSIVoltagePT1 models an inverters as AC voltage source which means the amplitude and frequency can defined by the designer (often called grid-forming inverter mode). The frequency regulation is assumed to be instantaneous, but the voltage control happens with a delay τ_v that is represented by a first order filter. In addition simple proportional controllers are implemented for frequency and voltage such that the frequency ω and voltage amplitudes v of the inverters are modified depending on the deviations (with respect to a desired value) of the active and reactive powers, respectively. ift is assumed that active and reactive power are measured via low pass fileters with time constant τ_P and τ_Q, respectively.\n\nHence, additionally to u, it has the internal dynamic variables\n\nω representing the frequency of the rotator relative to the grid frequency Ω, i.e. the real frequency ω_r of the rotator is given as ω_r = Ω + ω.\nq_m is the measured reactive power at the grid connection point.\n\nKeyword Arguments\n\nτ_v: time constant voltage control delay\nτ_P: time constant active power measurement\nτ_Q: time constant reactive power measurement\nK_P: droop constant frequency droop\nK_Q: droop constant voltage droop\nV_r: reference/ desired voltage\nP: active (real) power infeed\nQ: reactive (imag) power infeed\n\nMathematical Representation\n\nUsing VSIVoltagePT1 for node a (according to J. Schiffer et. al., eq. (6)) gives the equations\n\ndotphi_a=omega_a\n dotomega_a=frac1tau_Pa-omega_a-K_Pa (Releft(u_a cdot i_a^*right)-P_refa)\n tau_vdotv_a=-v_a+V_ref-K_Qa(q_ma-Q_refa)\n tau_Q dotq_ma=-q_ma+Imleft(u_a cdot i_a^*right)\n dotu_a=dotv_ae^jphi+jomega_a u_a\n\nIn general τ_V  τ_P, assuming τ_V = 0 would then lead to VSIMinimal.\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.OperationPointError","page":"Node Types","title":"PowerDynamics.OperationPointError","text":"Error to be thrown if something goes wrong during the operation point search.\n\n\n\n\n\n","category":"type"},{"location":"node_types/#PowerDynamics.PowerGridSolution","page":"Node Types","title":"PowerDynamics.PowerGridSolution","text":"struct PowerGridSolution\n    dqsol::AbstractTimeseriesSolution\n    powergrid::PowerGrid\nend\n\nThe data structure interfacing to the solution of the differntial equations of a power grid. Normally, it is not created by hand but return from PowerDynSolve.solve.\n\nAccessing the solution in a similar interface as State.\n\nFor some grid solution sol, one can access the variables as\n\nsol(t, n, s)\n\nwhere t is the time (either float or array), n the node number(s) (either integer, array, range (e.g. 2:3) or colon (:, for all nodes)), and s is the symbol represnting the chosen value. s can be either: :v, :φ, :i, :iabs, :δ, :s, :p, :q, or the symbol of the internal variable of the nodes. The meaning of the symbols derives from the conventions of PowerDynamics.jl. Finally, one can access the a-th internal variable of a node by using sol(t, n, :int, a).\n\nInterfacing the Plots.jl library via plotting recipes, that follow similar instructions as the direct access to the solution.\n\nFor some grid solution sol, one plot variables of the solution asin\n\nusing Plots\nplot(sol, n, s, plots_kwargs...)\n\nwhere n and s are as in the accessing of plots, and plots_kwargs are the keyword arguments for Plots.jl.\n\n\n\n\n\n","category":"type"},{"location":"custom_node_types/#Custom-Node-Types-1","page":"Custom Node Types","title":"Custom Node Types","text":"","category":"section"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"To define your own Node Types, use the PowerDynamics.@DynamicNode macro. The new node type will be a subtype of PowerDynamics.AbstractNodeParameters.","category":"page"},{"location":"custom_node_types/#","page":"Custom Node Types","title":"Custom Node Types","text":"@DynamicNode","category":"page"},{"location":"custom_node_types/#PowerDynamics.@DynamicNode","page":"Custom Node Types","title":"PowerDynamics.@DynamicNode","text":"Macro for creating a new type of dynmic nodes.\n\nSyntax Description:\n\n@DynamicNode MyNewNodeName(Par1, Par2, ...) <: NodeDynamicsType(N1, N2, ...) begin\n    [all prepratory things that need to be run just once]\nend [[x1, dx1], [x2, dx2]] begin\n    [the actual dynamics equation]\n    [important to set the output variables]\nend\n\nwhere MyNewNodeName is the name of the new type of dynamic node, Par1, Par2, ... are the names of the parameters, NodeDynamicsType the the node dynamics type (e.g. OrdinaryNodeDynamics or OrdinaryNodeDynamicsWithMass), N1, N1, ... the parameters of the dynamics type, x1, x2, ... the internal variables of the node and dx1, dx2, ... the corresponding differentials.\n\nIn the first block, the preparation code that needs to be run only once is inserted. Finally, the second block contains the dynamics description, where it's important that the output variables need to be set. In case of OrdinaryNodeDynamics and OrdinaryNodeDynamicsWithMass, these are du and the differentials of the internal variables (here dx1, dx2).\n\nBelow are two examples:\n\n@DynamicNode SwingEqParameters(H, P, D, Ω) <: OrdinaryNodeDynamics() begin\n    @assert D > 0 \"damping (D) should be >0\"\n    @assert H > 0 \"inertia (H) should be >0\"\n    Ω_H = Ω * 2pi / H\nend [[ω, dω]] begin\n    p = real(u * conj(i_c))\n    dϕ = ω # dϕ is only a temp variable that Julia should optimize out\n    du = u * im * dϕ\n    dω = (P - D*ω - p)*Ω_H\nend\n\n@DynamicNode SlackAlgebraicParameters(U) <: OrdinaryNodeDynamicsWithMass(m_u=false, m_int=no_internal_masses) begin\nend [] begin\n        du = u - U\nend\n\n\n\n\n\n","category":"macro"},{"location":"states_solutions/#States,-Solutions-and-Plotting-1","page":"States, Solutions & Plotting","title":"States, Solutions & Plotting","text":"","category":"section"},{"location":"states_solutions/#","page":"States, Solutions & Plotting","title":"States, Solutions & Plotting","text":"In order to properly interact with the state space of the power grid model, we defined two data structures [PowerDynamics.State] and [PowerDynamics.PowerGridSolution].","category":"page"},{"location":"states_solutions/#States-1","page":"States, Solutions & Plotting","title":"States","text":"","category":"section"},{"location":"states_solutions/#","page":"States, Solutions & Plotting","title":"States, Solutions & Plotting","text":"State","category":"page"},{"location":"states_solutions/#PowerDynamics.State","page":"States, Solutions & Plotting","title":"PowerDynamics.State","text":"\n    State(base; t=nothing)\n    State(grid, vec; t=nothing)\n\n\nEncode the information on the value of a state vector at a particular time point.\n\nKeyword Arguments\n\nUse a PowerGrid instance grid and a properly sized   state vector vec to instantiate a State.\n\nIndexing\n\nConcerning the indexing, a State object s basically behaves like a an array. There are plenty of convenient ways to access its contents at a node j by using a particular symbol:\n\ns[j, :u]: complex voltage\ns[j, :v]: voltage magnitude\ns[j, :φ]: voltage angle\ns[j, :i]: complex nodal current\ns[j, :iabs]: nodal current magnitude\ns[j, :δ]: nodal current angle\ns[j, :s]: apparent power\ns[j, :p]: real power\ns[j, :q]: reactive power\n\nCurrently, setting the state value is only implemented for u and v, the other quantities are derived automatically.\n\nYou can access (and set) the k-th variable by calling\n\ns[j, :var, k].\n\nThe variables can be also directly accessed with symbols, i.e.\n\ns[j, :ω]\n\nreturns the frequency ω at node j. To find out the proper symbol, the easiest way is to look into the docs of the corresponding node type, check the output of symbolsof or simply look at the output of println:\n\njulia> symbolsof(SwingEq(H=2, P=3, D=4, Ω=5))\n1-element Array{Symbol,1}:\n :ω\n\njulia> println(SwingEq(H=2, P=3, D=4, Ω=5))\nSwingEq[:ω](H=2, P=3, D=4, Ω=5)\n\n\n\n\n\n","category":"type"},{"location":"states_solutions/#Solutions-and-Plotting-1","page":"States, Solutions & Plotting","title":"Solutions & Plotting","text":"","category":"section"},{"location":"states_solutions/#","page":"States, Solutions & Plotting","title":"States, Solutions & Plotting","text":"PowerDynamics.PowerGridSolution","category":"page"},{"location":"error_types/#Error-Types-1","page":"Error Types","title":"Error Types","text":"","category":"section"},{"location":"error_types/#","page":"Error Types","title":"Error Types","text":"PowerDynamics.PowerDynamicsError\nPowerDynamics.NodeDynamicsError\nPowerDynamics.GridDynamicsError\nPowerDynamics.StateError\nPowerDynamics.GridSolutionError","category":"page"},{"location":"error_types/#PowerDynamics.PowerDynamicsError","page":"Error Types","title":"PowerDynamics.PowerDynamicsError","text":"Abstract super type of all PowerDynamics.jl Errors.\n\n\n\n\n\n","category":"type"},{"location":"error_types/#PowerDynamics.NodeDynamicsError","page":"Error Types","title":"PowerDynamics.NodeDynamicsError","text":"Error to be thrown if something goes wrong during the node dynamics construction.\n\n\n\n\n\n","category":"type"},{"location":"error_types/#PowerDynamics.StateError","page":"Error Types","title":"PowerDynamics.StateError","text":"Error to be thrown if something goes wrong when creating or modifying states.\n\n\n\n\n\n","category":"type"},{"location":"fullindex/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"fullindex/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"contact/#","page":"Contact","title":"Contact","text":"(Image: Build Status) (Image: Chat on Slack.) (Image: Get your Slack invitation.) (Image: Code on Github.)","category":"page"},{"location":"contact/#Contact-1","page":"Contact","title":"Contact","text":"","category":"section"},{"location":"contact/#","page":"Contact","title":"Contact","text":"In case of questions, please submit an issue on github or ask on our slack channel (get your invitation here).","category":"page"},{"location":"contact/#","page":"Contact","title":"Contact","text":"If you don't want to contact us publicly, send an email to Tim Kittel (tim.kittel@elena-international.com) or Sabine Auer (sabine.auer@elena-international.com).","category":"page"}]
}
