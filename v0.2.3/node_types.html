<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Node Types · PowerDynamics.jl</title><link rel="canonical" href="https://juliaenergy.github.io/PowerDynamics.jl/latest/node_types.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PowerDynamics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">General</a></li><li><a class="toctext" href="language_conventions.html">Language &amp; Conventions</a></li><li><a class="toctext" href="node_dynamics_types.html">Dynamics Types</a></li><li class="current"><a class="toctext" href="node_types.html">Node Types</a><ul class="internal"></ul></li><li><a class="toctext" href="custom_node_types.html">Custom Node Types</a></li><li><a class="toctext" href="states_solutions.html">States, Solutions &amp; Plotting</a></li><li><a class="toctext" href="error_types.html">Error Types</a></li><li><a class="toctext" href="fullindex.html">Index</a></li><li><a class="toctext" href="contact.html">Contact</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="node_types.html">Node Types</a></li></ul><a class="edit-page" href="https://github.com/JuliaEnergy/PowerDynamics.jl/blob/master/docs/src/node_types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Node Types</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Node-Types-1" href="#Node-Types-1">Node Types</a></h1><p>The currently implementes node types are</p><ul><li>Purely Algebraic:<ul><li><a href="node_types.html#PowerDynBase.PQAlgebraic"><code>PowerDynBase.PQAlgebraic</code></a> (PQ-bus)</li><li><a href="node_types.html#PowerDynBase.PVAlgebraic"><code>PowerDynBase.PVAlgebraic</code></a> (PV-bus)</li><li><a href="node_types.html#PowerDynBase.SlackAlgebraic"><code>PowerDynBase.SlackAlgebraic</code></a> (Slack-bus / Vφ-bus)</li></ul></li><li>Synchronous Machine Models:<ul><li><a href="node_types.html#PowerDynBase.SwingEq"><code>PowerDynBase.SwingEq</code></a> (2nd order)</li><li><a href="node_types.html#PowerDynBase.SwingEqLVS"><code>PowerDynBase.SwingEqLVS</code></a> (2nd order with an additional term for numerical voltage stability)</li><li><a href="node_types.html#PowerDynBase.FourthEq"><code>PowerDynBase.FourthEq</code></a> (4th order)</li></ul></li><li>Voltage Source Inverters:<ul><li><a href="node_types.html#PowerDynBase.VSIMinimal"><code>PowerDynBase.VSIMinimal</code></a></li><li><a href="node_types.html#PowerDynBase.VSIVoltagePT1"><code>PowerDynBase.VSIVoltagePT1</code></a></li></ul></li></ul><p>They are all subtypes of <a href="node_types.html#PowerDynBase.AbstractNodeParameters"><code>PowerDynBase.AbstractNodeParameters</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.AbstractNodeParameters" href="#PowerDynBase.AbstractNodeParameters"><code>PowerDynBase.AbstractNodeParameters</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type for all node parameter types.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.PQAlgebraic" href="#PowerDynBase.PQAlgebraic"><code>PowerDynBase.PQAlgebraic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">PQAlgebraic(;S)</code></pre><p>A node type that locally fixes the active (<span>$P$</span>) and reactive power (<span>$Q$</span>) output of the node.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>S = P + Q*im</code>: the complex power output</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>PQAlgebraic</code> for node <span>$a$</span> applies the equation</p><div>\[0 = S_a - u_a \cdot i_a^*.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.PVAlgebraic" href="#PowerDynBase.PVAlgebraic"><code>PowerDynBase.PVAlgebraic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">PVAlgebraic(;P,V)</code></pre><p>A node type that locally fixes the active power (<span>$P$</span>) and the voltage magnitude (<span>$V$</span>) of the node.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>P</code>: the active (real) power output</li><li><code>V</code>: voltage magnitude</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>PVAlgebraic</code> for node <span>$a$</span> applies the equations</p><div>\[0 = P_a - \Re\left(u_a \cdot i_a^*\right), \\
0 = V_a - \left\|u_a\right\|.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.SlackAlgebraic" href="#PowerDynBase.SlackAlgebraic"><code>PowerDynBase.SlackAlgebraic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">SlackAlgebraic(;U)</code></pre><p>A node type that locally fixes the complex voltage (<span>$U$</span>) of the node.</p><p>As the complex voltage can be represented as <span>$U=Ve^{i\phi}$</span>, this is equivlant to fixing the voltage magnitude <span>$V$</span> and the angle <span>$\phi$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>U</code>: the complex voltage</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>SlackAlgebraic</code> for node <span>$a$</span> applies the equation</p><div>\[0 = U_a - u_a.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.SwingEq" href="#PowerDynBase.SwingEq"><code>PowerDynBase.SwingEq</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">SwingEq(;H, P, D, Ω)</code></pre><p>A node type that applies the swing equation to the frequency/angle dynamics and keeps the voltage magnitude as is.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: inertia</li><li><code>P</code>: active (real) power output</li><li><code>D</code>: damping coefficient</li><li><code>Ω</code>: rated frequency of the power grid, often 50Hz</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>SwingEq</code> for node <span>$a$</span> applies the equations</p><div>\[\frac{du_a}{dt} = i u_a  \omega_a, \\
\frac{H}{2\pi\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div><p>which is equivalent to</p><div>\[\frac{d\phi_a}{dt} = \omega, \\
v = v(t=0) = \text{const.} \\
\frac{H}{2\pi\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.SwingEqLVS" href="#PowerDynBase.SwingEqLVS"><code>PowerDynBase.SwingEqLVS</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">SwingEqLVS(;H, P, D, Ω, Γ, V)</code></pre><p>A node type that applies the swing equation to the frequency/angle dynamics and has a linear voltage stability (LVS) term.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: inertia</li><li><code>P</code>: active (real) power output</li><li><code>D</code>: damping coefficient</li><li><code>Ω</code>: rated frequency of the power grid, often 50Hz</li><li><code>Γ</code>: voltage stability coefficient</li><li><code>V</code>: set voltage, usually <code>1</code></li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>SwingEq</code> for node <span>$a$</span> applies the equations</p><div>\[\frac{du_a}{dt} = i u_a \omega - \frac{u}{\|u\|} Γ_a  (v_a - V_a), \\
\frac{H}{2\pi\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div><p>which is equivalent to</p><div>\[\frac{d\phi_a}{dt} = \omega_a, \\
\frac{dv_a}{dt} = - Γ_a  (v_a - V_a) \\
\frac{H}{2\pi\Omega}\frac{d\omega_a}{dt} = P_a - D_a\omega_a - \Re\left(u_a \cdot i_a^*\right),\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.FourthEq" href="#PowerDynBase.FourthEq"><code>PowerDynBase.FourthEq</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">FourthEq(H, P, D, Ω, E_f, T_d_dash ,T_q_dash ,X_q_dash ,X_d_dash,X_d, X_q)</code></pre><p>A node type that applies the 4th-order synchronous machine model with frequency/angle and voltage dynamics.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variables</p><ul><li><span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span> and</li><li><span>$\theta$</span> representing the relative angle of the rotor with respect to the voltage angle <span>$\phi$</span>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>H</code>: inertia</li><li><code>P</code>: active (real) power output</li><li><code>D</code>: damping coefficient</li><li><code>Ω</code>: rated frequency of the power grid, often 50Hz</li><li><code>T_d_dash</code>: time constant of d-axis</li><li><code>T_q_dash</code>: time constant of q-axis</li><li><code>X_d_dash</code>: transient reactance of d-axis</li><li><code>X_q_dash</code>: transient reactance of q-axis</li><li><code>X_d</code>: reactance of d-axis</li><li><code>X_d</code>: reactance of q-axis</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>FourthEq</code> for node <span>$a$</span> applies the equations</p><div>\[    u = -je_c e^{j\theta} = -j(e_d + je_q)e^{j\theta}\\
    e_c= e_d + je_q = jue^{-j\theta}\\
    i  = -ji&#39;e^{j\theta} = -j(i_d+ j i_q )e^{j\theta} = Y^L \cdot u \\
    i_c= i_d + ji_q = jie^{-j\theta}\\
    p = \Re (i^* u)\]</div><p>The fourth-order equations read (according to Sauer, p. 140, eqs. (6110)-(6114)) and p. 35 eqs(3.90)-(3.91)</p><div>\[    \frac{d\theta}{dt} = \omega \\
     \frac{d\omega}{dt} = P-D\omega - p -(x&#39;_q-x&#39;_d)i_d i_q\\
    \frac{d e_q}{dt} = \frac{1}{T&#39;_d} (- e_q - (x_d - x&#39;_d) i_{d}+ e_f) \\
    \frac{d e_d}{dt} = \frac{1}{T&#39;_q} (- e_d + (x_q - x&#39;_q) i_{q})  \\\]</div><p>With the PowerDynamics.jl \time{naming conventions} of <span>$i$</span> and <span>$u$</span> they read as</p><div>\[   \dot u = \frac{d}{dt}(-j e_c e^{j\theta})=-j(\dot e_d + j\dot e_q)e^{j\theta} + uj\omega\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.VSIMinimal" href="#PowerDynBase.VSIMinimal"><code>PowerDynBase.VSIMinimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">VSIMinimal(;τ_P,τ_Q,K_P,K_Q,E_r,P,Q)</code></pre><p>A node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>τ_p</code>: time constant active power measurement</li><li><code>τ_Q</code>: time constant reactive power measurement</li><li><code>K_P</code>: droop constant frequency droop</li><li><code>K_Q</code>: droop constant voltage droop</li><li><code>V_r</code>: reference/ desired voltage</li><li><code>P</code>: active (real) power infeed</li><li><code>Q</code>: reactive (imag) power infeed</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>VSIMinimal</code> for node <span>$a$</span> applies the equations</p><div>\[\dot{\phi}_a=\omega_a\\
 \dot{\omega}_a=\frac{1}{\tau_{P,a}}[-\omega_a-K_{P,a} (\Re\left(u_a \cdot i_a^*\right)-P_{ref,a})]\\
\tau_Q\dot{v}_a=-v_a+V_{ref}-K_{Q,a} (\Im\left(u_a \cdot i_a^*\right)-Q_{ref,a})\\
 \dot{u}_a=\dot{v_a}e^{j\phi}+j\omega_a u_a\]</div><p>```</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerDynBase.VSIVoltagePT1" href="#PowerDynBase.VSIVoltagePT1"><code>PowerDynBase.VSIVoltagePT1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-Julia">VSIVoltagePT1(;τ_v,τ_P,τ_Q,K_P,K_Q,E_r,P,Q)</code></pre><p>A node type that applies the frequency and voltage droop control to control the frequency and voltage dynamics.</p><p>Additionally to <span>$u$</span>, it has the internal dynamic variable <span>$\omega$</span> representing the frequency of the rotator relative to the grid frequency <span>$\Omega$</span>, i.e. the real frequency <span>$\omega_r$</span> of the rotator is given as <span>$\omega_r = \Omega + \omega$</span>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>τ_v</code>: time constant voltage control delay</li><li><code>τ_p</code>: time constant active power measurement</li><li><code>τ_Q</code>: time constant reactive power measurement</li><li><code>K_P</code>: droop constant frequency droop</li><li><code>K_Q</code>: droop constant voltage droop</li><li><code>V_r</code>: reference/ desired voltage</li><li><code>P</code>: active (real) power infeed</li><li><code>Q</code>: reactive (imag) power infeed</li></ul><p><strong>Mathematical Representation</strong></p><p>Using <code>VSIVoltagePT1</code> for node <span>$a$</span> applies the equations</p><div>\[\dot{\phi}_a=\omega_a\\
 \dot{\omega}_a=\frac{1}{\tau_{P,a}}[-\omega_a-K_{P,a} (\Re\left(u_a \cdot i_a^*\right)-P_{ref,a})]\\
 \tau_v\dot{v}_{a}=-v_a+V_{ref}-K_{Q,a}(q_{m,a}-Q_{ref,a})\\
 \tau_Q \dot{q}_{m,a}=-q_{m,a}+\Im\left(u_a \cdot i_a^*\right)\\
 \dot{u}_a=\dot{v_a}e^{j\phi}+j\omega_a u_a\\\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/0d713926f85dfa3e4e0962215b909b8e47e94f48/base/#L0">source</a></section><footer><hr/><a class="previous" href="node_dynamics_types.html"><span class="direction">Previous</span><span class="title">Dynamics Types</span></a><a class="next" href="custom_node_types.html"><span class="direction">Next</span><span class="title">Custom Node Types</span></a></footer></article></body></html>
