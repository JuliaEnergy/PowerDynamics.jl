var documenterSearchIndex = {"docs":
[{"location":"networkdynamics_forward/","page":"🔗 NetworkDynamics.jl Docs","title":"🔗 NetworkDynamics.jl Docs","text":"    <meta http-equiv=\"refresh\" content=\"0; url=https://juliadynamics.github.io/NetworkDynamics.jl/stable/\">\n    <script type=\"text/javascript\">\n        window.location.href = \"https://juliadynamics.github.io/NetworkDynamics.jl/stable/\"\n    </script>\n    If you are not redirected automatically, follow this <a href='https://juliadynamics.github.io/NetworkDynamics.jl/stable/'>link to the documentation of NetworkDynamics.jl</a>.","category":"page"},{"location":"generated/getting_started/#getting-started","page":"Getting Started","title":"Getting Started with PowerDynamics.jl","text":"","category":"section"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"This tutorial introduces the core ideas behind PowerDynamics.jl and its relationship to the SciML ecosystem.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"This tutorial can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"PowerDynamics.jl is a tool for modeling and simulating dynamic powergrid models. Its main idea is to build equation-based, symbolic models for various dynamic components. Different components, such as shunts, generators or controllers are then connected to form dynamic models representing entire Buses or Lines. The dynamic Bus and Line models are then interconnected to form powergrids.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The most important distinction in contrast to other tools is that PowerDynamics.jl is a modeling framework rather than a simulation tool. At its core, a dynamic powergrid model is just a set of differential-algebraic equations (DAEs) that describe the evolution of the system over time. PowerDynamics.jl helps you to build these DAE models in a modular way, and then simulate them using the powerful solvers from the SciML ecosystem.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"PowerDynamics.jl gives you direct access to the underlying DAE structure and purposely exposes you to the \"raw\" commands from the SciML Ecosystem, most importantly DifferentialEquations.jl. While this can be a bit overwhelming at first, it really pays off to learn the API of the underlying packages directly rather than wrapping them all up in a PowerDynamics-specific API.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"This tight integration means, that it is much easier to transfer advanced SciML methods and concepts to systems defined with PowerDynamics.jl.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"In this tutorial, we will model the same physical system, a Single-Machine-Infinite-Bus (SMIB), in two different ways. First, we'll build it as a \"plain\" ModelingToolkit model using pure SciML packages. Then, we'll model the same system using PowerDynamics' component-based approach. This side-by-side comparison highlights the parallels in nomenclature and workflow between the two approaches.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The workflow for both approaches looks like this:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"╭────────────────────────╮ ╭────────────────────────────╮\n│ Pure MTK Model         │ │ PowerDynamics.jl Model     │\n╞════════════════════════╡ ╞════════════════════════════╡\n│ Equation-based model   │ │ Composite Model consisting │\n│ of the entire system.  │ │ of equation-based MTK      │\n╰─────────────────────┬──╯ │ models for Buses and Lines │\n                      │    │         ╭───────╮          │\n                      │    │     2 ┯━┿       ┿━┯ 3      │\n                      │    │       ↓ │   ╭───╯ ↓        │\n                      │    │         ┷━┯━┷ 1            │\n                      │    │          (~)               │\n                      │    ╰──────┬─────────────────────╯\n  ModelingToolkit.jl  │           │  PowerDynamics.jl\n           generates  ▾           ▾  generates\n                  ╭───┴───────────┴───╮\n                  │ DAE System        │\n                  │ M ̇x = f(x, p, t)  │\n                  ╰─────────┬─────────╯\nRHS function + Mass Matrix  ▾\n      ╭─────────────────────┴─────────────────────╮\n      │ SciML-ODEProblem                          │\n      │ Data structure for time-domain simulation │\n      ╰─────────────────────┬─────────────────────╯\n  OrdinaryDiffEq.jl solver  ▾\n     ╭──────────────────────┴──────────────────────╮\n     │ SciML-ODESolution                           │\n     │ Solution object containing the time series  │\n     │ for all components                          │\n     ╰──────────────────────┬──────────────────────╯\n         Symbolic Indexing  ▾\n ╭──────────────────────────┴──────────────────────────╮\n │ Time-series Inspection                              │\n │ Symbolic indexing allows for easy access to all     │\n │ states of all subcomponents for detailed analysis.  │\n ╰─────────────────────────────────────────────────────╯","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"info: Short description of used Packages and their relation\nTop-level Packages:PowerDynamics.jl: The main package for building powergrid models. It provides a library and modeling tools specific to power systems, such as powerflow models and component libraries.\nNetworkDynamics.jl: Our backend package that provides most of the core functionality. It is general-purpose and can model any kind of networked dynamical system.SciML Packages:ModelingToolkit.jl (MTK): A symbolic modeling framework for defining and manipulating differential equations. The key word here is symbolically – you write equations, not numerical code. MTK automatically performs simplifications and generates efficient numerical code for simulation.\nDifferentialEquations.jl: Umbrella package for everything related to differential equations, including stochastic and delay differential equations. Since it's large, we typically import specific subpackages, i.e.:\nOrdinaryDiffEq.jl: Solvers for ordinary differential equations (ODEs and DAEs). You can reduce load time even further by only importing specific solver packages like OrdinaryDiffEqRosenbrock.jl or OrdinaryDiffEqTsit5.jl.\nNonlinearSolve.jl: Solvers for nonlinear systems of equations, used for powerflow calculations and DAE initialization.Other Packages:Makie.jl: A powerful plotting package for visualizing results with its backends CairoMakie.jl for vector graphic output and GLMakie.jl/WGLMakie.jl for interactive visualizations.","category":"page"},{"location":"generated/getting_started/#Simple-ModelingToolkit-System","page":"Getting Started","title":"Simple ModelingToolkit System","text":"","category":"section"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"In this section we'll model the simplest Single-Machine-Infinite-Bus System (SMIB): a Swing equation connected to a slack bus.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"                    ω,θ\n                     ⤺\nTurbine Power  Pₘ  🭃▄▄▄🭎  Pₑ  Electrical Power\n               ─→  🭔▀▀▀🭟  ─→\n                     H\n","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The equations of the rotor connected to the infinite bus can be written as:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"beginaligned\ndottheta = omega\nMdotomega = P_mathrmm - P_mathrme - DomegatextSwing Equation with\nP_mathrme = frac1Xsinthetatextconnection to infinite bus with δ=0\nendaligned","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"where M is the inertia, omega_s is the synchronous speed, P_m is the mechanical power input, and P_e is the electrical power output. The state is described by the rotor angle theta and the angular velocity omega (deviation from synchronous speed). The ideal rotor is connected to a slack bus via a lossless transmission line with reactance X.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"To simulate this system, we first need to import some packages...","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as Dt\nusing OrdinaryDiffEqRosenbrock\nusing CairoMakie\nnothing #hide","category":"page"},{"location":"generated/getting_started/#MTK:-Model-Definition-and-Simulation","page":"Getting Started","title":"MTK: Model Definition & Simulation","text":"","category":"section"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"tip: Unicode Symbols\nJulia allows you to use unicode characters in variable names. In most Julia development environments you can insert them with LaTeX-like syntax: \\alpha<TAB> ⇒ α, \\_e<TAB> ⇒ ₑ and \\_+ ⇒ ₊. Especially ₊ is important as it is used as a separator in MTK.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"After importing the packages, we can define the symbolic system using the @mtkmodel macro:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"@mtkmodel SwingInfiniteBus begin\n    @parameters begin\n        M  = 1   # machine inertia\n        D  = 1   # machine damping\n        Pₘ = 1   # mechanical power\n        X  = 0.1 # reactance of powerline\n    end\n    @variables begin\n        θ(t)  # rotor angle\n        ω(t)  # angular velocity (rel to sync. speed)\n        Pₑ(t) # electrical power (connection to IB)\n    end\n    @equations begin\n        Pₑ ~ 1/X * sin(θ)\n        Dt(θ) ~ ω\n        M * Dt(ω) ~ Pₘ - Pₑ - D*ω\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The definition of the system is quite straightforward. Note how we defined 3 states, including one for the electrical power P_mathrme. We can instantiate the system by calling its constructor SwingInfiniteBus():","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"@named symbolic_system = SwingInfiniteBus()\nfull_equations(symbolic_system) # show all equations","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to simulate the system, we need to call mtkcompile, which will essentially perform a symbolic simplification of the system:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"compiled_system = mtkcompile(symbolic_system)\nfull_equations(compiled_system) # show all equations","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"You can see that the \"compiled\" system only consists of two states, theta and omega. This is because P_mathrme is not really a state of the system, but rather an intermediate variable, so it was thrown out. While trivial in this case, this is the symbolic simplification at work.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"To simulate the system, we need to define initial conditions for the states theta and omega. Also, we need to define a time span for the simulation.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"u0 = [\n    compiled_system.θ => 0.0,\n    compiled_system.ω => 0.0,\n]\ntspan = (0.0, 10.0)\nnothing #hide","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"Combining the compiled system, initial conditions, and time span, we can define a so-called ODEProblem.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"prob = ODEProblem(compiled_system, u0, tspan)","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The ODEProblem contains all the information needed to simulate the system. We can simulate the system using any of the solvers from OrdinaryDiffEq.jl. In this case, we decided to use the Rodas5P solver from OrdinaryDiffEqRosenbrock.jl.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"sol = solve(prob, Rodas5P())\nnothing #hide","category":"page"},{"location":"generated/getting_started/#MTK:-Solution-Handling","page":"Getting Started","title":"MTK: Solution Handling","text":"","category":"section"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The solution object we get contains all the time series in the system. For low-level access, we can look at","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"sol.t","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"to get an array of all the points in time the solver stepped to. While","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"sol.u","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"gives the full state of the system for each of the time points.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"However, this is far from all we can do with the solution object! First off, since we use dense output by default, we can interpolate the solution at any point in time:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"sol(2.5) # interpolate at t=2.5s (better than linear interpolation)","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The output, however, is still not very user friendly, since we only get a vector of values. This is where symbolic indexing comes to our help! Using the syntax","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"sol(1.0, idxs=compiled_system.θ) # get θ at t=1.0s","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"we can extract a specific state at a specific time point. This syntax has lots of variants; for example, we can efficiently interpolate multiple states at multiple time points:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"sol([0.0, 1.0], idxs=[compiled_system.θ, compiled_system.ω]) # get θ and ω at t=0.0s and t=1.0s","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"Since ModelingToolkit keeps track of all of its simplifications, we can also extract so-called \"observed\" states, i.e., states that were part of the original symbolic system but got eliminated during compilation. For this example, we can get the electrical power P_mathrme at any time point even though it is not part of the solution itself:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"sol(0.5, idxs=compiled_system.Pₑ) # get Pe at t=0.5s","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"Finally, we can use the same symbolic indexing syntax in plotting commands. The example below uses Makie.jl; however, the commands are very similar in Plots.jl.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"let\n    fig = Figure()\n    ax = Axis(fig[1,1], xlabel=\"Time (s)\", ylabel=\"States\")\n    lines!(sol, idxs=compiled_system.θ, color=:darkred)\n    lines!(sol, idxs=compiled_system.ω, color=:darkblue)\n    lines!(sol, idxs=compiled_system.Pₑ, color=:darkgreen)\n    axislegend(ax; position=:rt)\n    fig\nend","category":"page"},{"location":"generated/getting_started/#Simple-PowerDynamics-System","page":"Getting Started","title":"Simple PowerDynamics System","text":"","category":"section"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"Now, we're going to model the same physical system but this time using the component based approach of PowerDynamics.jl","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"This means, we'll define two buses with a pi-line (zero shunts) connecting them.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"        bus 1          bus 2\n          ╻              ╻\n  (═)╶────╂──────────────╂───╴(~)\nswing-eqs ╹   pi-line    ╹ slack/infinite bus","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"First, we need to load the PowerDynamics.jl package:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"using PowerDynamics\nusing PowerDynamics: Library","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"We start by loading a Swing model generator from the library.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"@named symbolic_swing = Library.Swing(V=1)\nfull_equations(symbolic_swing) # show all equations","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The equations represent a classic swing equation with no voltage dynamics. We passed the keyword argument V=1 to set the voltage magnitude to 1 p.u. So far, this is a \"pure\" MTK model, similar to the symbolic_system from above. The equations are structurally identical to the ones we defined manually above only differing in some conventions.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"We can then compile the model to get rid of intermediate variables and make it ready for simulation. We do so by calling compile_bus. The additional call to MTKBus can be ignored for now and is explained in further tutorials and the Modeling Concepts docs. Additionally, we give the bus model an index using the vidx keyword (short for vertex index).","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"bus1 = compile_bus(MTKBus(symbolic_swing); vidx=1, name=:swing)","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"This object is a so-called VertexModel. VertexModels (and EdgeModels) are the building blocks of systems in PowerDynamics.jl and NetworkDynamics.jl. From the printout you can already see that it has different variables/parameters with some default values and so on.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"For the second bus, we use a slack bus (also called infinite bus), which maintains constant voltage magnitude and angle:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"@named symbolic_slack = Library.VδConstraint(; V=1, δ=0)\nbus2 = compile_bus(MTKBus(symbolic_slack); vidx=2, name=:slack)","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The VδConstraint enforces V=1 p.u. and delta=0 at all times, which is the mathematical definition of a slack/infinite bus.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"And a powerline connecting the two:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"@named symbolic_piline = Library.PiLine()\nline = compile_line(MTKLine(symbolic_piline); src=1, dst=2)","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The powerline got the src and dst keywords. This means our line is defined from bus 1 to bus 2.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"Having defined all the components, we can now connect them to a network model.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"nw = Network([bus1, bus2], line)","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The nw object is somewhat similar to the compiled_system from above: it is a fully defined DAE system (ODE system in this case) that can be simulated. Similar to the compiled_system, it not only contains the right-hand-side function but also contains information necessary for symbolic indexing, i.e., which component has which states/parameters under which names and so on.","category":"page"},{"location":"generated/getting_started/#PD:-Symbolic-Indexing","page":"Getting Started","title":"PD: Symbolic Indexing","text":"","category":"section"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"In contrast to the MTK example above, our symbolic indices are \"hierarchical\", i.e., we have to specify the component first and then the state/parameter name.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"VIndex objects are used to reference states/parameters of vertex-entities (buses, shunts, generators, loads, etc.),","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"VIndex(  1,    :symbolic_swing₊ω)\nVIndex(:swing, :symbolic_swing₊θ)\n       ╶─┬──╴  ╶───────┬───────╴\n         ╵             │\nIndex/name of vertex   │\n                       ╵\n         Name of parameter/state","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"while EIndex objects are used to reference states/parameters of edge-entities (lines, transformers, etc.),","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"EIndex(        1,             :src₊P       )\nEIndex(     :edge,            :src₊Q       )\nEIndex(     1 => 2,           :src₊Q       )\nEIndex(:swing => :slack, :symbolic_piline₊R)\n       ╶──────┬───────╴  ╶───────┬────────╴\n              ╵                  │\n Index/name or src-dst pair      │\n                                 ╵\n                      Name of parameter/state","category":"page"},{"location":"generated/getting_started/#PD:-Manual-Definition-of-Initial-Conditions","page":"Getting Started","title":"PD: Manual Definition of Initial Conditions","text":"","category":"section"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"For large systems with possibly thousands of states and parameters, finding a suitable initial state is a hard problem which is covered in depth in later tutorials.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"For now, our system is quite simple and we can find a suitable initial state by hand. We can create a \"default\" state by calling NWState on the network object:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"@assert dim(nw) == 2 # hide\ns0 = NWState(nw)","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"This creates a state and parameter object, which is prefilled with all of the default values stored in the Network. The undefined states/parameters are set to NaN.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"!!! note Automatic State Reduction In the printout of s0 you see only two \"real\" states: omega and theta of the swing equation, everything else was simplified away, just like in the MTK example above.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"Using the symbolic indexing syntax described above, we can now set the initial conditions for all states and parameters that are not already defined.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"Similar to the example above, we start at 0 angle and a frequency of 1 p.u. (in contrast to the MTK example above, the swing model from the library is defined in terms of PU frequency not frequency deviation):","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"s0[VIndex(1, :symbolic_swing₊θ)] = 0.0\ns0[VIndex(:swing, :symbolic_swing₊ω)] = 1 # alternatively, reference vertex by unique name\nnothing #hide","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"Instead of using the symbolic indices explicitly, NWState supports a more user-friendly syntax for accessing states. We set the mechanical power input, the inertia, and the damping of the machine at bus 1:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"s0.v[1][:symbolic_swing₊Pm] =  1\ns0.v[1][:symbolic_swing₊M] = 1\ns0.v[:swing][:symbolic_swing₊D] = 1\nnothing #hide","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"It is important to understand that at its core, NWState objects are just \"wrappers\" around flat arrays. Similar to the pure-MTK example above, where our state vector u was just a vector of 2 plain values, the NWState object contains a flat vector of all states and a flat vector of all parameters. The flat vectors can be accessed using the uflat and pflat functions:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"uflat(s0)","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"pflat(s0)","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"By wrapping those flat vectors in a NWState object we make them \"human readable\" by providing symbolic indexing.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"There are lots of things you can do with NWState objects. For example, once again it is possible to inspect \"observed\" states—states which are not actually part of the state vector but rather intermediate variables. For example, we can inspect the active power at both src and destination end.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"s0.e[1=>2]([:src₊P, :dst₊P])","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"Unsurprisingly, since we start at an angle of 0 with both slack and swing, there is no active power flow.","category":"page"},{"location":"generated/getting_started/#PD:-Simulation-of-the-System","page":"Getting Started","title":"PD: Simulation of the System","text":"","category":"section"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"Similar to before, we take our model and use it to define an ODEProblem. We can then solve it using the Rodas5P solver again.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The only notable difference here is, that we need to pass both flat vectors: states and parameters.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"prob = ODEProblem(nw, uflat(s0), (0.0, 10.0), copy(pflat(s0)))\nsol = solve(prob, Rodas5P())\nnothing #hide","category":"page"},{"location":"generated/getting_started/#PD:-Solution-Handling","page":"Getting Started","title":"PD: Solution Handling","text":"","category":"section"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"The solution handling is analogous to the pure-MTK example above.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"sol(1.0, idxs=VIndex(1, :symbolic_swing₊θ)) # get θ of bus 1 at t=1.0s","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"For generating lists of symbolic indices at once, NetworkDynamics.jl provides the auxiliary functions vidxs and eidxs:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"vidxs(nw, :, :busbar₊u_arg) # create lists of VIndex objects","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"sol(1.0, idxs=vidxs(nw, :, :busbar₊u_arg)) # use vidxs get voltage angle of all buses at t=1.0s","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"tip: Tip\nCertain electrical \"bus\" states, such as :busbar₊u_arg or :busbar₊u_mag, are available at every bus regardless of the models attached to that bus. The full list of avialable symbols can be checked interatively using s0.v[1]/s0.e[1=>2].","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"Sometimes, you want to get the full NWState at a specific time point.","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"s10 = NWState(sol, 1.0) # get full NWState at t=1.0s","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"which you can then inspect as before:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"s10.e[1=>2]([:src₊P, :dst₊P]) # get active power at line 1=>2 at t=1.0s","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"We can do some plotting as before:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"let\n    fig = Figure()\n    ax = Axis(fig[1,1], xlabel=\"Time (s)\", ylabel=\"Voltage Angles\")\n    lines!(sol, idxs=VIndex(1, :symbolic_swing₊θ), color=:darkred)\n    lines!(sol, idxs=VIndex(2, :busbar₊u_arg), color=:darkblue)\n    axislegend(ax; position=:rt)\n    ax = Axis(fig[2,1], xlabel=\"Time (s)\", ylabel=\"Frequency at Swing\")\n    lines!(sol, idxs=VIndex(1, :symbolic_swing₊ω), color=:darkred)\n    axislegend(ax; position=:rt)\n    ax = Axis(fig[3,1], xlabel=\"Time (s)\", ylabel=\"Active Power in Line\")\n    lines!(sol, idxs=EIndex(1=>2, :src₊P), color=:darkgreen, label=\"P injected towards bus 1\")\n    lines!(sol, idxs=EIndex(1=>2, :dst₊P), color=:lightgreen, label=\"P injected towards bus 2\")\n    axislegend(ax; position=:rt)\n    fig\nend","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"We observe the expected behavior:","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"as in the pure MTK example, the swing node accelerates and oscillates around until it settles at a new steady state, where the angle difference between bus 1 and the slack bus (with delta=0) leads to a power flow of P_mathrme = P_mathrmm = 1 p.u.\nin steady state, the active power injected at bus 1 is equal to the active power extracted at bus 2 (lossless line)","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"generated/getting_started/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/custom_line/#custom-line","page":"Custom Transmission Line","title":"Tutorial on custom Transmission Line Models","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"This tutorial can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"In this tutorial we'll implement a custom transmission line model:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"we start by defining a PI-branch component with optional fault admittance,\nwe combine two PI-branch components into one MTKLine, to essentially model a dual-branch transmission line.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"To make it more interesting, we add protection logic to the branches:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"each branch continuously checks the current magnitude against a limit,\nif the current exceeds the limit, the branch is switched off after a delay time.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"using PowerDynamics\nusing ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\nusing NetworkDynamics\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\nusing Graphs","category":"page"},{"location":"generated/custom_line/#Basic-PI-Branch-Model","page":"Custom Transmission Line","title":"Basic PI-Branch Model","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We start by defining a basic PI-branch model, which is similar to the one in PiLine_fault.jl as an MTKModel. This model should fulfill the Branch Interface, i.e. it needs to have two Terminal, one called :src the other called :dst:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"      ┌───────────┐\n(src) │           │ (dst)\n  o←──┤  Branch   ├──→o\n      │           │\n      └───────────┘","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The PI-branch we want to describe looks like this. We have:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"two terminals :src and :dst with their\nvoltages V_mathrmsrc and V_mathrmdst,\ncurrents i_mathrmsrc and i_mathrmdst,\ntwo shunt admittances Y_mathrmsrc and Y_mathrmdst,\nan impedance Z, which is split into two parts Z_a and Z_b by the fault position mathrmpos.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"              i_src  V₁   i_a   Vₘ   i_b   V₂  i_dst\n     V_src o────←────o───Z_a─→──o───Z_b─→──o────→────o V_dst\n              r_src  │          │          │   r_dst\n                     ↓ i₁       ↓ i_f   i₂ ↓\n                     ┴          ┴          ┴\nY_src = G_src+jB_src ┬          ┬ Y_f      ┬  Y_dst = G_dst+jB_dst\n                     │          │          │\n                     ⏚          ⏚          ⏚\n                   (fault enabled by breaker)","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The fault admittance Y_f = G_f + jB_f can represent any fault impedance.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"To model this, we introduce the internal voltages V_1, V_2 and V_mathrmm. We consider the equations of the PI-branch in quasi-static-state. Therefore, we can use complex variables to describe the voltages and the currents. What we need in the end are equations for the currents at the terminals, i.e. i_mathrmsrc and i_mathrmdst as a function of all the parameters and the given node voltages. Lets start writing down the equations:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"First, we \"split\" the impedance Z into two parts Z_a and Z_b:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"beginaligned\nZ_mathrma = Z  mathrmpos\nZ_mathrmb = Z  (1-mathrmpos)\nendaligned","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Next, we can define the internal voltages V_1 and V_2 in terms of the terminal voltages and the transformation ratios:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"beginaligned\nV_1 = r_mathrmsrc  V_mathrmsrc\nV_2 = r_mathrmdst  V_mathrmdst\nendaligned","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Once we have the shunt voltages, we can directly calculate the shunt currents","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"beginaligned\ni_1 = Y_mathrmsrc  V_1\ni_2 = Y_mathrmdst  V_2\nendaligned","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"To calculate the middle voltage V_mathrmm, we need to consider the fault admittance Y_f. The fault admittance is defined as:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Y_f = G_f + jB_f","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The effective fault admittance is controlled by the shortcircuit parameter:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Y_ftexteff = mathrmshortcircuit cdot Y_f","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"When the fault is active, we apply Kirchhoff's current law at the middle node: i_mathrma = i_mathrmb + i_f, which leads to the middle voltage:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"V_mathrmm = fracV_1  (1-mathrmpos) + V_2  mathrmpos1 + Y_ftexteff  Z  mathrmpos  (1-mathrmpos)","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Once we have the middle voltage defined, we can calculate the currents i_mathrma, i_mathrmb, and i_f:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"beginaligned\ni_mathrma = fracV_1 - V_mathrmmZ_a\ni_mathrmb = fracV_mathrmm - V_2Z_b\ni_f = Y_ftexteff  V_mathrmm\nendaligned","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Finally, we can calculate the terminal currents using Kirchhoff law and the transformation ratios:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"beginaligned\ni_mathrmsrc = (-i_mathrma - i_1)  r_mathrmsrc\ni_mathrmdst = (i_mathrmb - i_2)  r_mathrmdst\nendaligned","category":"page"},{"location":"generated/custom_line/#Implement-the-CustomPiBranch-MTKModel","page":"Custom Transmission Line","title":"Implement the CustomPiBranch MTKModel","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"<details class=\"admonition is-details\">\n<summary class=\"admonition-header\">Excursion: Complex Variables in MTK Models</summary>\n<div class=\"admonition-body\">","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"warning: Complex variables are not supported in MTK Models (at least not in PowerDynamics.jl)\nIn the end, all parameters and variables of NetworkDynamic models are real-valued, therefore, we cannot use complex parameters or states in our MTK Models.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"However, there is a \"hack\" to prevent this issue. Lets say we want to model the complex equation","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"U = Z cdot I","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We could expand everything in real and imaginary parts and rewrite the equations. However, we can also use ModelingToolkits capability to have complex terms even without having complex variables.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"@variables u_r u_i i_r i_i\n@parameters R, X\nIc = i_r + im * i_i","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Z = R + im * X","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Here, Ic and Z are not a symbolic variables, they are julia variables which points to a complex term/expression.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Using Symboics/ModelingToolkit, we can also multiply complex terms:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Uc = Z * Ic","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"By applying real and imag to the complex term, we can extract the real and imaginary parts to form separate equations for real and imaginary part:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"eqs = [\n    u_r ~ real(Uc),\n    u_i ~ imag(Uc)\n]","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"This trick can be used inside @mtkmodel as well, by just defining those complex terms in a begin...end block.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"</div>\n</details>","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"With the equations and the knowledge on how to use complex terms within MTK Models the definition is relatively straight forward:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"@mtkmodel CustomPiBranch begin\n    @parameters begin\n        R, [description=\"Resistance of branch in pu\"]\n        X, [description=\"Reactance of branch in pu\"]\n        G_src, [description=\"Conductance of src shunt\"]\n        B_src, [description=\"Susceptance of src shunt\"]\n        G_dst, [description=\"Conductance of dst shunt\"]\n        B_dst, [description=\"Susceptance of dst shunt\"]\n        r_src=1, [description=\"src end transformation ratio\"]\n        r_dst=1, [description=\"dst end transformation ratio\"]\n        # fault parameters\n        pos=0.5, [description=\"Fault Position (from src, percent of the line)\"]\n        G_f=1, [description=\"Fault conductance in pu\"]\n        B_f=0, [description=\"Fault susceptance in pu\"]\n        shortcircuit=0, [description=\"shortcircuit on line\"]\n        # parameter to \"switch off\" the line\n        active=1, [description=\"Line active or switched off\"]\n    end\n    @components begin\n        src = Terminal()\n        dst = Terminal()\n    end\n    begin\n        # define complex variables\n        Z = R + im*X\n        Ysrc = G_src + im*B_src\n        Ydst = G_dst + im*B_dst\n        Yf = G_f + im*B_f\n        Vsrc = src.u_r + im*src.u_i\n        Vdst = dst.u_r + im*dst.u_i\n        # define Z_a and Z_b in terms of Z\n        Z_a = Z * pos\n        Z_b = Z * (1-pos)\n        # define internal voltages using the\n        V₁ = r_src * Vsrc\n        V₂ = r_dst * Vdst\n        # currents through the shunt admittances\n        i₁ = Ysrc * V₁\n        i₂ = Ydst * V₂\n        # effective fault admittance (controlled by shortcircuit)\n        Yf_eff = shortcircuit * Yf\n        # middle voltage with fault admittance effect\n        V_m = (V₁*(1-pos) + V₂*pos) / (1 + Yf_eff * Z * pos * (1-pos))\n        # fault current to ground\n        i_f = Yf_eff * V_m\n        # current through the two Z parts\n        i_a = (V₁ - V_m) / Z_a\n        i_b = (V_m - V₂) / Z_b\n        # terminal currents\n        isrc = (-i_a - i₁)*r_src\n        idst = (i_b - i₂)*r_dst\n    end\n    @equations begin\n        src.i_r ~ active * real(isrc)\n        src.i_i ~ active * imag(isrc)\n        dst.i_r ~ active * real(idst)\n        dst.i_i ~ active * imag(idst)\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Additionally to the equations defined above, we multiply the currents by active. This is equivalent of opening two ideal breakers on both ends of the branch when active=false.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Lastly lets ensure that our model satisfies the Branch Interface:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"@named pibranch = CustomPiBranch()\nisbranchmodel(pibranch)","category":"page"},{"location":"generated/custom_line/#Extending-the-model-for-dynamic-over-current-Protection","page":"Custom Transmission Line","title":"Extending the model for dynamic over-current Protection","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Now that we have a working basic PI-branch model, let's extend it with dynamic protection capabilities.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"In order to implement the overcurrent protection, we need to make a plan in terms of callbacks. Callbacks are a neat feature of DifferentialEquations.jl, which allow you to stop the solver under certain conditions and trigger a user-defined affect function to change the state of the system. Their general capability is extended in NetworkDynamics.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We want to implement the following behavior:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Continuously monitor the current magnitude and compare to the maximal current threshold.\nIf the maximum current is reached at time t, mark the line as to be switched off at time t_mathrmcutoff = t + Delta t.\nContinuously monitor time of the simulation and switch off the line at t_mathrmcutoff.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The way to implement this is by introducing 3 new parameters:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"I_max, the maximum current magnitude,\nt_cutoff=Inf, the time when the line should be switched off, which defaults to infinity and\nt_delay, the delay time after which the line should be switched off.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"For robust overcurrent protection, we need to implement multiple complementary callbacks:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"A continuous callback that detects smooth threshold crossings using root-finding\nA discrete callback that catches instantaneous jumps above the threshold\nA cutoff callback that switches off the line at the scheduled time","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"This dual detection approach is necessary because discrete events (like short circuits) can cause the current to jump above the threshold without crossing it smoothly, which continuous callbacks might miss. Both overcurrent callbacks share the same affect function that schedules the line cutoff, while the cutoff callback actually switches off the line.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"note: Note\nNetworkDynamics currently does not support Events defined in MTK models. So we need to split the implementation: The new parameters need to be introduced to the MTKModel (extending CustomPiBranch), the callbacks need to be defined for the compiled EdgeModel.","category":"page"},{"location":"generated/custom_line/#Extension-of-the-CustomPiBranch-MTKModel","page":"Custom Transmission Line","title":"Extension of the CustomPiBranch MTKModel","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Let's add the new parameters to the CustomPiBranch model by extending the model. Extend means that we essentially copy-paste the whole model definitions and are able to add new parameters, equations, variables and so on.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We add an additional \"observed\" state I_mag, which always contains the current magnitude at the src or dst terminal (whatever is higher).","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"@mtkmodel ProtectedPiBranch begin\n    @extend CustomPiBranch()\n    @parameters begin\n        I_max=Inf, [description=\"Maximum current magnitude\"]\n        t_cutoff=Inf, [description=\"Time when the line should be switched off\"]\n        t_delay=0.1, [description=\"Delay time after which the line should be switched off\"]\n    end\n    @variables begin\n        I_mag(t), [description=\"Current magnitude at src or dst terminal\"]\n    end\n    @equations begin\n        I_mag ~ max(sqrt(src.i_r^2 + src.i_i^2), sqrt(dst.i_r^2 + dst.i_i^2))\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Once the model is defined, we can go through the building hierarchy outlined in Modeling Concepts. First, we need to form something satisfying the MTKLine Interface.","category":"page"},{"location":"generated/custom_line/#Creating-the-Dual-Branch-MTKLine","page":"Custom Transmission Line","title":"Creating the Dual-Branch MTKLine","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Here we implement our dual-branch architecture by creating two separate ProtectedPiBranch instances and combining them into a single MTKLine. This creates a transmission line model with two parallel branches:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":" ┌───────────────────────────────────────────┐\n │MTKLine   ┌─────────────────────┐          │\n │         ┌┤ ProtectedPiBranch A ├┐         │\n │┌───────┐│└─────────────────────┘│┌───────┐│\n ││LineEnd├o                       o┤LineEnd││\n │└───────┘│┌─────────────────────┐│└───────┘│\n │  :src   └┤ ProtectedPiBranch B ├┘  :dst   │\n │          └─────────────────────┘          │\n └───────────────────────────────────────────┘","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The end terminals of both branches are connected to the same physical line end. However, the branches operate independently:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Each branch monitors its own current magnitude (pibranchA₊I_mag, pibranchB₊I_mag)\nEach has independent protection parameters (I_max, t_delay, t_cutoff)\nEach can be individually switched off (pibranchA₊active, pibranchB₊active)\nElectrical parameters are adjusted so that parallel combination matches the original single-branch behavior","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"branchA = ProtectedPiBranch(; name=:pibranchA)\nbranchB = ProtectedPiBranch(; name=:pibranchB)\nmtkline = MTKLine(branchA, branchB)\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Then, we take the mtkline and put it into a compiled EdgeModel by calling the compile_line constructor","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"\n       ╔═══════════════════════════════════════════════╗\n       ║ EdgeModel (compiled)                          ║\n       ║ ┌───────────────────────────────────────────┐ ║\n   src ║ │MTKLine   ┌─────────────────────┐          │ ║ dst\nvertex ║ │         ┌┤ ProtectedPiBranch A ├┐         │ ║ vertex\n   u ───→│┌───────┐│└─────────────────────┘│┌───────┐│←─── u\n       ║ ││LineEnd├o                       o┤LineEnd││ ║\n   i ←───│└───────┘│┌─────────────────────┐│└───────┘│───→ i\n       ║ │  :src   └┤ ProtectedPiBranch B ├┘  :dst   │ ║\n       ║ │          └─────────────────────┘          │ ║\n       ║ └───────────────────────────────────────────┘ ║\n       ╚═══════════════════════════════════════════════╝","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"protected_template = compile_line(mtkline; name=:protected_piline)","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"tip: Reduced complexity of compiled Model\nNote, that the compiled model still has no states, i.e. it directly calculates the terminal currents from the terminal voltages and the parameters. This is a perfect showcase of why equation based modeling matters: we still can access all of the internal variables, like the currents per branch. However those are all just \"observed\" and don't add to the numeric dimensionality of our model. (Even though the complexity of calculating the output currents is slightly higher than that of the simple PI-Line model).","category":"page"},{"location":"generated/custom_line/#Definition-of-the-Callbacks","page":"Custom Transmission Line","title":"Definition of the Callbacks","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We implement the callbacks as outlined in the NetworkDynamic docs on Callbacks.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"For robust overcurrent protection, we need two complementary callbacks:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"A continuous callback that detects smooth threshold crossings using root-finding\nA discrete callback that catches instantaneous jumps above the threshold","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"This dual approach is necessary because discrete events (like short circuits) can cause the current to jump above the threshold without crossing it smoothly, which continuous callbacks might miss.","category":"page"},{"location":"generated/custom_line/#Overcurrent-Detection-Callbacks","page":"Custom Transmission Line","title":"Overcurrent Detection Callbacks","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"For ComponentCondition, we need to specify which symbols to monitor. We've explicitly added I_mag as an observed state to our ProtectedPiBranch model, which contains the maximum current magnitude between the src and dst terminals for each branch.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Since our dual-branch transmission line has two independent branches (:pibranchA and :pibranchB), we define callback functions that take the branch name as a parameter. This allows us to automatically create identical callbacks for both branches without code duplication.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Condition Definitions:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The continuous condition uses root-finding, returning the difference between limit and current magnitude (zero when the limit is reached):","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"function continuous_overcurrent_condition(branchname)\n    I_mag = Symbol(branchname, \"₊\", :I_mag) # pilineX₊I_mag\n    I_max = Symbol(branchname, \"₊\", :I_max) # pilineX₊I_max\n    t_cutoff = Symbol(branchname, \"₊\", :t_cutoff) # pilineX₊t_cutoff\n\n    ComponentCondition([I_mag], [I_max, t_cutoff]) do u, p, t\n        p[t_cutoff] != Inf && return Inf # return Inf if cutoff already scheduled\n        p[I_max] - u[I_mag]\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The discrete condition uses a boolean check that triggers whenever the current exceeds the threshold:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"function discrete_overcurrent_condition(branchname)\n    I_mag = Symbol(branchname, \"₊\", :I_mag) # pilineX₊I_mag\n    I_max = Symbol(branchname, \"₊\", :I_max) # pilineX₊I_max\n    t_cutoff = Symbol(branchname, \"₊\", :t_cutoff) # pilineX₊t_cutoff\n\n    ComponentCondition([I_mag], [I_max, t_cutoff]) do u, p, t\n        p[t_cutoff] != Inf && return false # return false if cutoff already scheduled\n        u[I_mag] ≥ p[I_max]\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Shared Affect Function:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Both callbacks use the same affect function. When triggered, it schedules the line cutoff by setting t_cutoff and tells the integrator to step to that time:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"function overcurrent_affect(branchname)\n    t_cutoff = Symbol(branchname, \"₊\", :t_cutoff) # pilineX₊t_cutoff\n    t_delay = Symbol(branchname, \"₊\", :t_delay)   # pilineX₊t_delay\n\n    ComponentAffect([], [t_cutoff, t_delay]) do u, p, ctx\n        p[t_cutoff] != Inf && return # return early if already scheduled for cutoff\n        tcutoff = ctx.t + p[t_delay]\n        println(\"$branchname of line $(ctx.src)→$(ctx.dst) overcurrent at t=$(ctx.t), scheduling cutoff at t=$tcutoff\")\n        # update the parameter of the edge to store the cutoff time\n        p[t_cutoff] = tcutoff\n        # tell the integrator to explicitly step to the cutoff time\n        add_tstop!(ctx.integrator, tcutoff)\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/#Line-Cutoff-Callback","page":"Custom Transmission Line","title":"Line Cutoff Callback","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"The cutoff callback switches off the line when the scheduled cutoff time is reached. Since we expect the solver to explicitly hit the cutoff time (via add_tstop!), we only need a discrete callback:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"function cutoff_condition(branchname)\n    t_cutoff = Symbol(branchname, \"₊\", :t_cutoff) # pilineX₊t_cutoff\n    ComponentCondition([], [t_cutoff]) do u, p, t\n        t == p[t_cutoff]\n    end\nend\nfunction cutoff_affect(branchname)\n    active = Symbol(branchname, \"₊\", :active) # pilineX₊active\n    ComponentAffect([], [active]) do u, p, ctx\n        println(\"$branchname of line $(ctx.src)→$(ctx.dst) cutoff at t=$(ctx.t)\")\n        p[active] = 0 # switch off the line\n    end\nend\nfunction cutoff_callback(branchname)\n    DiscreteComponentCallback(cutoff_condition(branchname), cutoff_affect(branchname))\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/#Adding-Callbacks-to-Template","page":"Custom Transmission Line","title":"Adding Callbacks to Template","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We build both callbacks by combining their respective conditions and affects. Finally, we add all three callbacks to the protected template:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"function branch_callbacks(branchname)\n    oc_affect = overcurrent_affect(branchname)\n    oc1 = ContinuousComponentCallback(\n        continuous_overcurrent_condition(branchname),\n        oc_affect\n    )\n    oc2 = DiscreteComponentCallback(\n        discrete_overcurrent_condition(branchname),\n        oc_affect\n    )\n    cut = DiscreteComponentCallback(\n        cutoff_condition(branchname),\n        cutoff_affect(branchname)\n    )\n    (oc1, oc2, cut)\nend\nset_callback!(protected_template, branch_callbacks(:pibranchA))\nadd_callback!(protected_template, branch_callbacks(:pibranchB))\nprotected_template #hide","category":"page"},{"location":"generated/custom_line/#Simulate-the-IEEE39-Grid-with-the-ProtectedLine","page":"Custom Transmission Line","title":"Simulate the IEEE39 Grid with the ProtectedLine","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"In the last part of this tutorial, we want to see our protected transmission line in action. The third part of the IEEE39 Grid Tutorial simulates a short circuit on a line. To do so, it uses two callbacks: one to enable the short circuit and one to disable the line. We can do this much more elegantly now by just using the ProtectedPiBranch model.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Lets load the first part of that tutorial to get the IEEE39 Grid model. Also, we initialize the model (the quintessence of part II).","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"EXAMPLEDIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\")\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part1.jl\"))\nformula = @initformula :ZIPLoad₊Vset = sqrt(:busbar₊u_r^2 + :busbar₊u_i^2)\nset_initformula!(nw[VIndex(31)], formula)\nset_initformula!(nw[VIndex(39)], formula)\ns0 = initialize_from_pf!(nw; verbose=false)\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Now, we should have a fully initialized network available as nw:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"nw","category":"page"},{"location":"generated/custom_line/#Derive-Network-with-Protected-Line-Models","page":"Custom Transmission Line","title":"Derive Network with Protected Line Models","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Now we'll demonstrate the protected line model in action by applying it to the IEEE39 test system.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We need to build our own network model by replacing the transmission line models with our ProtectedPiBranch. For that, we create a helper function that takes an edge model from the old network and creates a protected transmission line model with equivalent electrical parameters.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Our protected transmission line model uses two parallel branches (A and B), so we need to adjust the parameters. For two parallel branches to behave like the original single branch:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Impedances (R, X): 2× original (parallel combination gives original)\nShunt admittances (G, B): 0.5× original (parallel combination gives original)\nTransformation ratios (r): same as original","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"function protected_line_from_line(e::EdgeModel)\n    new = copy(protected_template)\n    # copy src and destination information\n    src_dst = get_graphelement(e)\n    set_graphelement!(new, src_dst)\n    for branch in [:pibranchA, :pibranchB]\n        # Impedances: double them (2× original)\n        set_default!(new, Symbol(branch, \"₊\", :R), 2 * get_default(e, :piline₊R))\n        set_default!(new, Symbol(branch, \"₊\", :X), 2 * get_default(e, :piline₊X))\n        # Shunt admittances: halve them (0.5× original)\n        set_default!(new, Symbol(branch, \"₊\", :G_src), 0.5 * get_default(e, :piline₊G_src))\n        set_default!(new, Symbol(branch, \"₊\", :B_src), 0.5 * get_default(e, :piline₊B_src))\n        set_default!(new, Symbol(branch, \"₊\", :G_dst), 0.5 * get_default(e, :piline₊G_dst))\n        set_default!(new, Symbol(branch, \"₊\", :B_dst), 0.5 * get_default(e, :piline₊B_dst))\n        # Transformation ratios: keep same\n        set_default!(new, Symbol(branch, \"₊\", :r_src), get_default(e, :piline₊r_src))\n        set_default!(new, Symbol(branch, \"₊\", :r_dst), get_default(e, :piline₊r_dst))\n    end\n    new\nend\nold_edgemodels = [nw[EIndex(i)] for i in 1:ne(nw)];\nvertexmodels = [nw[VIndex(i)] for i in 1:nv(nw)];\nnew_edgemodels = protected_line_from_line.(old_edgemodels);\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We can then build a new Network with those modified edgemodels:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"nw_protected = Network(vertexmodels, new_edgemodels)","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"... and initialize it!","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"s0_protected = initialize_from_pf!(nw_protected; verbose=false)","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"As a short sanity check, lets compare the initialized values of both networks: we do so by extracting the interface_values for both solutions (a dictionary of all currents and voltages (inputs and outputs of the models))) Then we compare their values.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"@assert collect(values(interface_values(s0))) ≈ collect(values(interface_values(s0_protected))) #hide\ncollect(values(interface_values(s0))) ≈ collect(values(interface_values(s0_protected)))","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"They are identical! If we would have made an error in our transmission line model, the steady state would be most certainly different.","category":"page"},{"location":"generated/custom_line/#Simulate-with-the-Protected-Line-Models","page":"Custom Transmission Line","title":"Simulate with the Protected Line Models","text":"","category":"section"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Now that we have our protected transmission line models ready, we need to configure them for the simulation. First, we set the current threshold I_max for overcurrent protection.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We set the threshold to 130% of the power flow solution:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"AFFECTED_LINE = 24\n\nfor i in 1:46\n    i_at_steadys = s0_protected[EIndex(i, :pibranchA₊I_mag)]\n    s0_protected[EIndex(i, :pibranchA₊I_max)] = 1.3*i_at_steadys\n    i_at_steadys = s0_protected[EIndex(i, :pibranchB₊I_mag)]\n    s0_protected[EIndex(i, :pibranchB₊I_max)] = 1.3*i_at_steadys\nend\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Next, we need to introduce a perturbation to test our protection system. We'll introduce a shortcircuit with Y_mathrmfault=1mathrmpu on branch A of line 24. Notably, we only need to start the short circuit, as the protection is now \"baked into\" the transmission line model.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"_enable_short = ComponentAffect([], [:pibranchA₊shortcircuit]) do u, p, ctx\n    @info \"Short circuit activated on branch A of line $(ctx.src)→$(ctx.dst) at t = $(ctx.t)s\"\n    p[:pibranchA₊shortcircuit] = 1\nend\nshortcircuit_cb = PresetTimeComponentCallback(0.1, _enable_short)\nknown_cbs = filter(cb -> !(cb isa PresetTimeComponentCallback), get_callbacks(nw_protected[EIndex(AFFECTED_LINE)]))\nset_callback!(nw_protected, EIndex(AFFECTED_LINE), (shortcircuit_cb, known_cbs...))\nnw_protected[EIndex(AFFECTED_LINE)] #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"With all those callbacks set, we can go ahead simulating the system.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"prob = ODEProblem(\n    nw_protected,\n    uflat(s0_protected),\n    (0.0, 15),\n    copy(pflat(s0_protected));\n    callback=get_callbacks(nw_protected),\n    dtmax=0.01,\n)\nsol = solve(prob, Rodas5P());\nnothing #hide","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"When we run this simulation, the console output will show that the short circuit on Branch A activates at t=0.1s and leads to a line shutdown at t=0.2s (after the 0.1s delay), which clears the fault. However, due to the introduced dynamics in the system, branch B of the affected line also experiences a current magnitude exceeding the threshold, which leads to a shutdown of the line at around 1.5 seconds.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"Let's look at the current magnitude evolution during the simulation:","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"fig = let fig = Figure()\n    ax = Axis(fig[1, 1];\n        title=\"Current Magnitude Across All Lines\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Current Magnitude (reltive to steady state)\")\n\n    # Full simulation time range\n    ts = range(sol.t[begin], sol.t[end], length=3000)\n\n    # Plot current magnitude for but the failing line\n    for i in 1:46\n        i == AFFECTED_LINE && continue\n        # Factor of 2: total transmission line current is double the branch current\n        # since we have two identical parallel branches (A and B)\n        current = 2*sol(ts, idxs=EIndex(i, :pibranchA₊I_mag)).u\n        current = current ./ current[begin]\n        lines!(ax, ts, current)\n    end\n\n    A_current = sol(ts, idxs=EIndex(AFFECTED_LINE, :pibranchA₊I_mag)).u\n    B_current = sol(ts, idxs=EIndex(AFFECTED_LINE, :pibranchB₊I_mag)).u\n    A_current = A_current ./ A_current[begin]\n    B_current = B_current ./ B_current[begin]\n\n    lines!(ax, ts, A_current; linewidth=2, color=:blue, label=\"Branch A\")\n    lines!(ax, ts, B_current; linewidth=2, color=:red, label=\"Branch B\")\n\n    hlines!(ax, [1.3]; color=:black, linestyle=:dot)\n    xlims!(ax, ts[begin], ts[end])\n    axislegend(ax; pos=:tr)\n    fig\nend","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"We can also zoom into the time range around the short circuit to see how the current of branch B crosses the threshold and the branch is disabled shortly after.","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"xlims!(0, 2)\nylims!(0.8, 1.5)\nfig","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"","category":"page"},{"location":"generated/custom_line/","page":"Custom Transmission Line","title":"Custom Transmission Line","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/ieee39_part2/#ieee39-part2","page":"IEEE39 Part II: Initialization","title":"IEEE39 Bus Tutorial - Part II: Initialization","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"This tutorial can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"This is the second part of a four-part tutorial series for the IEEE 39-bus test system:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Part I: Model Creation - Build the network structure with buses, lines, and components\nPart II: Initialization (this tutorial) - Perform power flow calculations and dynamic initialization\nPart III: Dynamic Simulation - Run time-domain simulations and analyze system behavior\nPart IV: Advanced Modeling & Parameter Optimization - Create custom components and optimize system parameters","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The goal of this tutorial is to get an understanding of the initialization process in PowerDynamics.jl.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"For comprehensive documentation on initialization, see:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"NetworkDynamics.jl initialization docs\nPowerDynamics.jl initialization docs","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"tip: Quick Start\nIf you're looking for the practical initialization approach without diving into implementation details, jump directly to the Initialize all Components section at the end.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"This tutorial goes deep into the initialization internals for educational purposes. In practice, you'll typically use the high-level functions shown at the end rather than the detailed step-by-step process demonstrated here.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"As a prerequisite, we load part I of the tutorial, which contains the network model:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"using PowerDynamics\nEXAMPLEDIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\")\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part1.jl\"))\nnw # nw object now available","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The initialization process in PowerDynamics.jl is a two-step process: first we solve the power flow, then we use the power flow results to initialize the individual network components.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"There are shortcut functions to do this (as shown later), but we will go through the steps in detail for educational purposes.","category":"page"},{"location":"generated/ieee39_part2/#Power-Flow","page":"IEEE39 Part II: Initialization","title":"Power Flow","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"To solve the power flow, we first need to get the power flow model. We can use the function powerflow_model.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"pfnw = powerflow_model(nw)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The power flow model is a Network object like the original network. It is built from the original network, by calling powerflow_model on the individual components. For example, we have this rather complex dynamic model at bus 30:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"nw[VIndex(30)]","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"From the printout, we can see that a power flow model :pvbus is attached to the generator model.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"We can extract the attached PV power flow model by calling powerflow_model","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"powerflow_model(nw[VIndex(30)])","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The function powerflow_model checks if there is a power flow model attached (it checks the :pfmodel metadata).","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Per component, the powerflow_model function will do the following:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"If the model has the :pfmodel metadata set (see Metadata), it will return the VertexModel stored in the metadata. In Part I we set the :pfmodel metadata using the pf keyword to the [compile_bus].\nIf the model does not have the :pfmodel metadata set, PowerDynamics will check if the model itself is a valid power flow model. If so, it'll just use the dynamic model as the power flow model.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"What is a valid power flow model?: A valid power flow model is a model that has no internal dynamics, i.e. it either has dim(model) == 0 OR it has a zero mass matrix (i.e. only constraints).","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"For example, the PiLine models are completely static:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"nw[EIndex(1)]","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"This model has no internal states and no :pfmodel metadata.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"@assert ispfmodel(nw[EIndex(1)]) # is pf model itself\npowerflow_model(nw[EIndex(1)]) === nw[EIndex(1)]","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"As a result, when we call powerflow_model(nw), we get a completely static network, i.e. only constraints, no dynamics.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"all(iszero, pfnw.mass_matrix)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The fully static network has the form","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"dotx = 0 = f_mathrmnw(x p t)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Where x are the network states (mainly voltages u_r and u_i at the buses) and p are all the parameters such as P, V and Q values for bus models and line parameters for branch models.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"To solve this root-finding problem, we first need to find an initial guess. The initial guess is prefilled with all the default values from the components. In our case, all parameters and states have default values attached, so the initial state is fully determined.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"pfs0 = NWState(pfnw)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"With the default state, we can call find_fixpoint, which keeps p constant and tries to find an x such that the root-finding problem stated above is fulfilled:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"pfs = find_fixpoint(pfnw, pfs0)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"As a result, we get a NWState object which contains the full state for the power flow model.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Since power flow model and dynamic model share the same topology and the same network interface (i.e. nodes create voltages, edges create currents), we can extract the interface values from the power flow model state and apply them to the dynamic model:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"interf = interface_values(pfs)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The interface values give us the inputs and outputs for every component in the network, i.e. for all buses we get values for","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"busbar₊i_r and busbar₊i_i: current input\nbusbar₊u_r and busbar₊u_i: voltage output","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"For all branches we get:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"src₊u_r and src₊u_i: source side voltage input\ndst₊u_r and dst₊u_i: destination side voltage input\nsrc₊i_r and src₊i_i: source side current output\ndst₊i_r and dst₊i_i: destination side current output","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"With those interface values fixed, we can go over to the second step of the initialization process: the initialization of the dynamic component.","category":"page"},{"location":"generated/ieee39_part2/#Initialization-of-Dynamic-Components","page":"IEEE39 Part II: Initialization","title":"Initialization of Dynamic Components","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Initialization of a bus model means, we want to find a steady state of the dynamics given the interface values from the power flow model.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Therefore, the equations for the bus models (recall from Modeling Concepts) become","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"beginaligned\nM_mathrm vfracmathrmdmathrmdtx_mathrm v = colorred0 = f^mathrm vleft(x^mathrm v colorredsum_kbeginbmatrixi^k_r i^k_iendbmatrix p_mathrm v tright)\ncolorredbeginbmatrixu_r u_iendbmatrix = g^mathrm v(x^mathrmvp_mathrm v t)\nendaligned","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"where red symbols are fixed by either the power flow solution or our steady state condition (i.e. dotx=0). This leaves us with a system of N=mathrmdim(x) + mathrmdim(u) equations – we can solve for N unknowns.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"details: Edge Initialization Equations\nbeginaligned\nM_mathrm efracmathrmdmathrmdtx_mathrm e = colorred0 = f_mathrm eleft(x_mathrm e colorredbeginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix colorredbeginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrixp_mathrme tright)\ncolorredbeginbmatrixi_r^mathrmsrci_i^mathrmsrcendbmatrix = g^mathrmsrc_mathrm eleft(x_mathrm ecolorred beginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix colorredbeginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrix p_mathrme tright)\ncolorredbeginbmatrixi_r^mathrmdsti_i^mathrmdstendbmatrix = g^mathrmdst_mathrm eleft(x_mathrm e colorredbeginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix colorredbeginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrix p_mathrme tright)\nendaligned","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Notably, the unknowns can come from either the set of states or the set of parameters. We divide the set of symbols into two sets:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"fixed symbols have a default metadata set. They are considered fixed in the solution of the nonlinear system.\nfree symbols only have a guess metadata set. They are considered free in the solution of the nonlinear system.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Let's take a look at the bus model at bus 30:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"gen = nw[VIndex(30)]","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"We have a system with 15 States and 42 parameters. Of those, most are fixed, i.e. have a default metadata set. In the VertexModel printout, defaults are shown with = while guesses are shown with ≈. We can use dump_initial_state to get an overview of the free and set states:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"dump_initial_state(gen; obs=false)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Right now, we have 2 free parameters, 2 free inputs, 2 free outputs and 15 free states. We can use initialize_component to find values for the free symbols:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"try #hide\ninitialize_component(gen)\ncatch e #hide\n    @error e.msg #hide\nend #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Wait! The initialization failed! Why? Well, we need to apply additional defaults, so called default_overwrites for the inputs/outputs to make the system solvable.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"interf_v30 = Dict( # manually define interface values for demonstration\n    :busbar₊u_r => 1.04573,\n    :busbar₊u_i => -0.0609188,\n    :busbar₊i_i => 1.53174,\n    :busbar₊i_r => -2.30145,\n)\ninitialize_component(gen; default_overrides=interf_v30)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"note: Mutating vs non-mutating Initialization\nThe non mutating initialize_component returns a dictionary containing a full initialized component state. That can be useful for certain purposes, often it is easier to work with the mutating version of initialization function, which will write the initialized values back to the component metadata (i.e setting the :init property for the symbols).","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Let's call the mutating initialize_component! function to write the initialized values back to the component and inspect the initial state using dump_initial_state:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"initialize_component!(gen; default_overrides=interf_v30)\ndump_initial_state(gen; obs=false)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"In the state dump we see how the initialization successfully set all the previously unknown values, including the control parameters avr₊vref and gov₊p_ref. We have our first initialized component!","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"However, in practice it's not always so easy.","category":"page"},{"location":"generated/ieee39_part2/#Handling-Structurally-Underconstrained-Components","page":"IEEE39 Part II: Initialization","title":"Handling Structurally Underconstrained Components","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Recalling from Part 1, we have an uncontrolled machine together with a load on bus 39.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"            ╔════════════════════════════════╗\n            ║ Unctr. Ma. Load Bus (compiled) ║\n            ║  ┌────────────────────────┐    ║\n  Network   ║  │MTKBus      ┌─────────┐ │    ║\n interface  ║  │          ┌─┤ Machine │ │    ║\n  current ────→│ ┌──────┐ │ └─────────┘ │    ║\n            ║  │ │BusBar├─o             │    ║\n  voltage ←────│ └──────┘ │ ┌──────┐    │    ║\n            ║  │          └─┤ Load │    │    ║\n            ║  │            └──────┘    │    ║\n            ║  └────────────────────────┘    ║\n            ╚════════════════════════════════╝","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"If we try to initialize this component as before, we run into a problem:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"interf_v39 = Dict(\n  :busbar₊u_r => 1.01419,\n  :busbar₊u_i => -0.179795,\n  :busbar₊i_i => -1.72223,\n  :busbar₊i_r => 0.720135,\n)\ntry #hide\ninitialize_component!(nw[VIndex(39)]; default_overrides=interf_v39)\ncatch e #hide\n    @error e.msg #hide\nend #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Even though we set the interface values, the problem is still underconstrained! Let's check the free symbols:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"println(\"free u: \", free_u(nw[VIndex(39)]))\nprintln(\"free p: \", free_p(nw[VIndex(39)]))\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"We see 8 free states and 3 free parameters, however we only have 8 state + 2 output equations:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"nw[VIndex(39)] #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Even though we have enough set parameters to initialize machine and load on its own, we cannot do it simultaneously. Intuitively speaking, it's just not clear for the solver which of the two components provides how much power.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"To solve this, we have essentially 3 methods:","category":"page"},{"location":"generated/ieee39_part2/#Method-1:-Manual-setting-of-defaults","page":"IEEE39 Part II: Initialization","title":"Method 1: Manual setting of defaults","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The simplest solution is to manually set more defaults. For example, we know that we want to initialize the ZIP load around the initialization point, i.e. V_mathrmset should be the same as the bus voltage magnitude.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"vm_manual = copy(nw[VIndex(39)])\nu_r = get_initial_state(vm_manual, :busbar₊u_r)\nu_i = get_initial_state(vm_manual, :busbar₊u_i)\nset_default!(vm_manual, :ZIPLoad₊Vset, sqrt(u_r^2 + u_i^2))\ninitialize_component!(vm_manual)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The initialization succeeded now!","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"note: No more default_overrides\nNote how we can skip the default_overrides keyword argument, since the first (failing) call of initialize_component! already \"burned in\" the default overrides! Mutating state is a powerful tool, but it needs care!","category":"page"},{"location":"generated/ieee39_part2/#Method-2:-Adding-an-init_formula","page":"IEEE39 Part II: Initialization","title":"Method 2: Adding an init_formula","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The problem with the previous method is that it is quite manual. In reality, we would never go through this very manual initialization process. The fact that the model is structurally underconstrained is a property of the model and should therefore be handled by the model. To do so, NetworkDynamics.jl provides the InitFormula mechanism.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"An InitFormula is a symbolic formula that is evaluated during the initialization process. It is attached to the VertexModel so it can be evaluated automatically during the initialization process. The \"formula\" we want to apply is simply the equation","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"V_mathrmset = sqrtu_r^2 + u_i^2","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"vm_formula = copy(nw[VIndex(39)])\nformula = @initformula :ZIPLoad₊Vset = sqrt(:busbar₊u_r^2 + :busbar₊u_i^2)\nset_initformula!(vm_formula, formula)\nvm_formula #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The printout shows 1 additional initialization equation was attached to the model.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The initialization works now:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"initialize_component!(vm_formula)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"The init formula is applied early in the initialization process, essentially writing a new default for ZIPLoad₊Vset based on the other defaults.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"This reduced the number of free variables to 10, thus the system was solvable.","category":"page"},{"location":"generated/ieee39_part2/#Method-3:-Using-an-InitConstraint","page":"IEEE39 Part II: Initialization","title":"Method 3: Using an InitConstraint","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Sometimes, your additional initialization needs are more complicated. Similar to defining a formula, which is evaluated before the actual initialization, NetworkDynamics provides a mechanism for injecting additional constraints into the initialization process.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"In contrast to the formula, the constraint does not need to be explicitly solvable, as it defines a residual equation","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"0 = c(x) = V_mathrmset - sqrtu_r^2 + u_i^2","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"vm_constraint = copy(nw[VIndex(39)])\nconstraint = @initconstraint begin\n  :ZIPLoad₊Vset - sqrt(:busbar₊u_r^2 + :busbar₊u_i^2)\nend\nset_initconstraint!(vm_constraint, constraint)\nvm_constraint #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"With this added constraint, the initialization process is solvable again, since we now have 11 equations for the 11 free variables.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"initialize_component!(vm_constraint)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"For this particular case, method (2) is the way to go. However there are cases where the constraint is more complex and cannot be expressed as a formula.","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"See NetworkDynamics docs on Advanced Component Initialization: Formulas and Constraints and the PowerDynamics specific extension Advanced Component Initialization for more information on method 2 and 3.","category":"page"},{"location":"generated/ieee39_part2/#initialize-all-components","page":"IEEE39 Part II: Initialization","title":"Automatic Initialization of Full Network","text":"","category":"section"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Let's return from our excursion into individual component initialization and focus on the whole network again. As we've just seen, we have structurally underconstrained components in the network. Let's define the init formulas for the two buses which have loads and machines:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"formula = @initformula :ZIPLoad₊Vset = sqrt(:busbar₊u_r^2 + :busbar₊u_i^2)\nset_initformula!(nw[VIndex(31)], formula)\nset_initformula!(nw[VIndex(39)], formula)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"With that, the componentwise initialization of the whole network is possible:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"initialize_componentwise!(nw; default_overrides=interf)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"Even shorter, we can just use initialize_from_pf! to do everything from exporting the power flow model, finding the fixpoint and initializing all components:","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"s0 = initialize_from_pf!(nw)","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"","category":"page"},{"location":"generated/ieee39_part2/","page":"IEEE39 Part II: Initialization","title":"IEEE39 Part II: Initialization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"julia_setup/#julia-setup","page":"Julia Setup for New Users","title":"Julia Setup for PowerDynamics","text":"","category":"section"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"In this document we'll provide a very brief overview on how to set up your development environment with Julia. The goal of this document is to get you ready to follow our examples in this documentation.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"If you've worked with Julia before, you can probably skip this part and jump to the getting started tutorial.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"We recommend checking out further resources, like the excellent","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"community provided Modern Julia Workflows blog and the\nofficial Julia documentation.","category":"page"},{"location":"julia_setup/#Install-Julia","page":"Julia Setup for New Users","title":"Install Julia","text":"","category":"section"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"First you need to install Julia. Check out the install instructions on the official Julia homepage. It is recommended to install Julia using juliaup.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"note: Note\njuliaup is a Julia version multiplexer, you can use it to manage different Julia versions on the same system using commands like juliaup update (update installed versions), juliaup add 1.11 (add a new version), juliaup default 1.11 (tell your computer which version to start when you invoke the julia command).","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"In general, Julia can be installed and run without any administrator privileges.","category":"page"},{"location":"julia_setup/#Windows","page":"Julia Setup for New Users","title":"Windows","text":"","category":"section"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"You can install Julia on Windows using the Microsoft Store. Instead of searching manually, you can invoke this installation in the terminal. Search for powershell in the start menu and execute","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"winget install --name Julia --id 9NJNWW8PVKMN -e -s msstore","category":"page"},{"location":"julia_setup/#Linux/Mac","page":"Julia Setup for New Users","title":"Linux/Mac","text":"","category":"section"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Execute the following code in your terminal:","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"curl -fsSL https://install.julialang.org | sh","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"The installer will ask you some questions, you won't need to change any defaults.","category":"page"},{"location":"julia_setup/#Verify-installation","page":"Julia Setup for New Users","title":"Verify installation","text":"","category":"section"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"After the installation, run the julia command in your terminal. You should get an output like this:","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"(Image: image)","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"tip: Stick to Julia 1.11 for now\nBy default, juliaup will install the latest stable version of Julia. As of 10/2025, that is 1.12. However there are some minor problems in 1.12 which might make it less stable. For now, I'd advise you to stay at Julia 1.11. To do so, runjuliaup add 1.11\njuliaup default 1.11after which your julia command should point to Julia 1.11 by default.","category":"page"},{"location":"julia_setup/#The-Julia-REPL","page":"Julia Setup for New Users","title":"The Julia-REPL","text":"","category":"section"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Julia's main interface is the REPL (read-eval-print-loop). It is similar to ipython or the Matlab command window. You can execute code in the REPL by typing it. Try julia> println(\"hello world\")<RETURN> to run your first Julia command. Exit the REPL by pressing CTRL + d or typing exit()<RETURN>.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"tip: Tip\nThe REPL has lots of great features. For example:hit ] to enter package manager mode (see Environment Basics below)\nhit ? to enter help mode: search for functions or concepts to get documentation\nscroll through history using arrow up and arrow down.","category":"page"},{"location":"julia_setup/#Install-VSCode-with-the-Julia-extension","page":"Julia Setup for New Users","title":"Install VSCode with the Julia extension","text":"","category":"section"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"The REPL is great, but we also need an editor for writing code. The best editor for most people will be Visual Studio Code. Please download and install it.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Within VSCode, you need to install the julia-extension. You should be able to click the \"install\" link in any browser, it'll open VSCode and install the extension. Alternatively, you can search for \"Julia\" in the VSCode extension store.","category":"page"},{"location":"julia_setup/#env-basics","page":"Julia Setup for New Users","title":"Environment and Package Manager Basics","text":"","category":"section"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Julia has a built-in package manager. It lets you install, update and manage dependencies across your projects. Often, different projects require different dependencies and different versions.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"note: Example\nLet's say you have a research project A using PowerDynamics at version v1.0.0 and it's working great. However, you want to start a new project B, which requires a new feature introduced in version v2.2.0! Environments help you to set up two different folders, one of which uses v1.0.0 and one uses v2.2.0. This approach helps you to try out new stuff in B without the fear of breaking your already working project A due to incompatible updates.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"To create your first environment, create a new folder somewhere (for example /home/Documents/powerdynamics_playground). You can open this (empty) folder in VSCode and create a new file for your first script:","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"(Image: image)","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Open the newly created file, hit CTRL + SHIFT + P to bring up the VSCode \"command palette\", search for \"Start REPL\" and launch your Julia REPL.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"In the REPL, you can execute pwd() (print working directory) to see the directory where your REPL was launched. Hit ] to launch the package manager. Your REPL changes:","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"(@v1.11) pkg>","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"This output means your active environment is the global environment for Julia v1.11. If you were to add packages here, you would add them globally. Normally, that's not what we want. So instead we activate the current folder (.) as our working environment:","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"(@v1.11) pkg> activate .","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"After activation, we can add PowerDynamics to our newly created environment using","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"(powerdynamics_playground) pkg> add PowerDynamics","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"This will install PowerDynamics and all its dependencies. It will also precompile all of that. This may take a while...","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"(Image: image)","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Once you've added a package, you'll see that two new files appeared: Project.toml and Manifest.toml. The Project.toml lists all of your dependencies. This is the file you change when adding new packages. It is relatively short and human readable. It only lists the top level dependencies, in this case just PowerDynamics. The Manifest.toml on the other hand lists all packages in the current environment. It is a full snapshot containing all versions of every dependency and also the dependencies of your dependencies. Never edit it by hand!","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"ProjectRoot\n├╴example_script.jl\n├╴Project.toml\n╰╴Manifest.toml","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"The existence of a Project.toml file marks a folder as a project. You can activate such a folder. When executing code in a file using the Julia VSCode extension, it will automatically activate the environment for you.","category":"page"},{"location":"julia_setup/#Executing-Code-in-VSCode","page":"Julia Setup for New Users","title":"Executing Code in VSCode","text":"","category":"section"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Working with Julia is much like working in a notebook (Jupyter, Google Colab or similar), due to the persistent REPL. Because of how Julia works internally, everything you do will take much more time the first time you do it. Therefore, it is always preferred to have a persistent REPL over relaunching Julia. That is:","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"opening a REPL,\nexecuting a script in REPL,\nchanging script and\nrun script again in same REPL","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"is much preferred to","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"executing a script by calling julia myscript.jl\nchanging the script\nexecuting it again by calling julia myscript.jl","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"in which case you'd pay the startup costs on every new run.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Besides executing an entire script (play button up top), you can execute single lines and code blocks in VSCode:","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Put the VSCode cursor on a line and hit SHIFT + RETURN to \"send\" that line of code to the REPL. If the line is part of a multiline expression (like a function), it'll \"send\" the entire block.\nSelect multiple lines and hit SHIFT + RETURN to \"send\" all selected lines.\nHit ALT + RETURN (or CMD + RETURN) to execute an entire code cell, where a code cell is everything between lines starting with ##.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"note: Execute your first Script\nInstall ModelingToolkit in addition to PowerDynamics in your environment and copy the following code to your script:using PowerDynamics\nusing ModelingToolkit\nusing PowerDynamics: Library\n\n@named swing = Library.Swing(V=1)\nbusmodel = MTKBus(swing)\nswingbus = compile_bus(busmodel)Execute it line by line using SHIFT + RETURN and enjoy your first bus model!(Image: image)","category":"page"},{"location":"julia_setup/#Running-PowerDynamics-Examples","page":"Julia Setup for New Users","title":"Running PowerDynamics Examples","text":"","category":"section"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Now you know everything you need to know to run our examples locally.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"At the beginning of each example, there is a link:","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"This tutorial can be downloaded as a normal Julia script here.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Go to the getting started tutorial, download the script, put it in your directory and go through it, executing it block by block.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"tip: Tip\nFor the script to work you need to install additional packages. You can install multiple packages at once:julia> ] add OrdinaryDiffEqRosenbrock, CairoMakie","category":"page"},{"location":"julia_setup/#Defining-Functions-and-Revise.jl","page":"Julia Setup for New Users","title":"Defining Functions and Revise.jl","text":"","category":"section"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Eventually, you'll grow out of putting everything into a script. The obvious next step is to put parts of your code in functions. You could put those functions in the script, however if you change the code you need to evaluate them again. Alternatively, you can create a new file, for example myfunctions.jl:","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"# contents of myfunctions.jl\nfunction foo()\n    println(\"Hello World\")\nend","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Then, you can use Revise.jl to track changes in that file. In your main script, write","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Revise.includet(\"myfunctions.jl\") # <- execute this line SHIFT+RETURN\n\nfoo() # <- prints \"hello world\"","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Then, you can update your myfunctions.jl file","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"# contents of myfunctions.jl\nfunction foo()\n    println(\"Hello World, but different.\")\nend","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"and save it. If you evaluate foo() again (either in REPL directly or in your script), it'll print \"Hello World, but different.\" – Revise automatically updates the function definition.","category":"page"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"At some point, you might want to put your project in a Julia Package, but that's beyond the scope of this tutorial. Consult the documentation and your favorite Chatbot for help. Especially check out ] dev MyPackage in contrast to ] add MyPackage.","category":"page"},{"location":"julia_setup/#Additional-Remarks-and-Tips","page":"Julia Setup for New Users","title":"Additional Remarks & Tips","text":"","category":"section"},{"location":"julia_setup/","page":"Julia Setup for New Users","title":"Julia Setup for New Users","text":"Embrace the interactivity of the REPL: it really is (one of) Julia's superpowers. Play around with objects, make use of the help mode and use functions like propertynames() to explore structures.\nGet to know the package manager. It is really good! However, package management is not a trivial problem so package managers tend to be non-trivial. Read the docs and try to understand it. Just using it by trial and error will lead to major frustration down the road. Especially the option to ] dev packages and define local sources are very powerful tools.\nSeek help. The julia discourse and the Julia Slack and the Julia Zulip are great platforms to post your problems and get help from the community.","category":"page"},{"location":"generated/typical_simulation_workflow/#typical-simulation-workflow","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"The goal of this tutorial is to get you started with PowerDynamics.jl. We'll walk you through the different \"stages\" of a typical simulation workflow while introducing key terminology along the way.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"This tutorial can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"The system to model is a simple 3 bus system:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Bus 1: ideal droop inverter\nBus 2: a constant Y load\nBus 3: a second constant Y load","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"All buses are connected with standard pi-model power lines.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"    ╭───────╮\n2 ┯━┿       ┿━┯ 3\n  ↓ │   ╭───╯ ↓\n    ┷━┯━┷ 1\n      │\n     (~)","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"using PowerDynamics\nusing PowerDynamics: Library\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie","category":"page"},{"location":"generated/typical_simulation_workflow/#Stage-I:-Defining-Dynamical-Models","page":"Typical Simulation Workflow","title":"Stage I: Defining Dynamical Models","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"The first phase of the workflow is typically to define your dynamical models. Models may either come from a library (like the IdealDroopInverter and ConstantYLoad below) or they can be defined by the user.","category":"page"},{"location":"generated/typical_simulation_workflow/#Inverter-Model","page":"Typical Simulation Workflow","title":"Inverter Model","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"In this case, we want the first bus to be an ideal droop inverter.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Often, model definition will be a multi step process:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"First: we define an \"injector model\", in this case our inverter:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"(t) ┌────────────────┐\n o──┤ Droop Inverter │\n    └────────────────┘","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"inverter_model = Library.IdealDroopInverter(; name=:droop, Vset=1)\nnothing #hide","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"This model is an equation-based/symbolic model representing the dynamics. It is based on the great ModelingToolkit.jl Library.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Second: we build a \"Bus Model\", which connects the injector to a Busbar. This model still lives in the equation-based/symbolic domain.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"┌───────────────────────────────┐\n│BusModel                       │\n│┌────────┐   ┌────────────────┐│\n││ BusBar ├─o─┤ Droop inverter ││\n│└────────┘   └────────────────┘│\n└───────────────────────────────┘","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"bus_model = MTKBus(inverter_model; name=:invbus)\nnothing #hide","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Third: we compile the symbolic model into a julia function for numeric simulation. Doing so, we get a VertexModel, which is an object from our backend NetworkDynamics.jl","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"           ╔════════════════════════════════╗\n Network   ║ VertexModel (compiled)         ║\ninterface  ║  ┌───────────────────────────┐ ║\n           ║  │BusModel                   │ ║\n current ────→│┌──────┐ ┌────────────────┐│ ║\n           ║  ││BusBar├o┤ Droop inverter ││ ║\n voltage ←────│└──────┘ └────────────────┘│ ║\n           ║  └───────────────────────────┘ ║\n           ╚════════════════════════════════╝","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"bus1 = compile_bus(MTKBus(inverter_model); vidx=1)","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Note that this model is no longer symbolic. The equations have been reduced and transformed into a nonlinear descriptor model. For more information on the different model types, see the Modeling Concepts docs. You can check out the NetworkDynamics.jl doc on the underlying mathematical model.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"In the printout above, you can see that we consider different types of variables in our models:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"the input is always the current flowing from the attached power lines into the bus,\nthe output is always the voltage at the busbar,\nthe states are dynamical or algebraic states in the sense of a Differential-Algebraic-Equation (DAE) model,\nand parameters are static values that stay mostly constant during simulation and define the system behavior.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"There is a 5th class of states not shown above: observables. Observables are time dependent values, which are not states in the sense of a DAE but can be reconstructed from the states, inputs, outputs and parameters. Thus, they don't need to be \"solved\" for numerically, but they can be reconstructed in post-processing. A simple example of an \"observed\" state would be a voltage angle or the active and reactive power at some bus.","category":"page"},{"location":"generated/typical_simulation_workflow/#Load-Models","page":"Typical Simulation Workflow","title":"Load Models","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"For the two loads, we use the predefined ConstantYLoad model from the Library and compile them:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"load_model = Library.ConstantYLoad(; name=:load)\nbus2 = compile_bus(MTKBus(load_model); name=:loadbus, vidx=2)\nbus3 = compile_bus(MTKBus(load_model); name=:loadbus, vidx=3)","category":"page"},{"location":"generated/typical_simulation_workflow/#Power-Line-Models","page":"Typical Simulation Workflow","title":"Power Line Models","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Lastly, we need to define three power lines. The workflow is similar to the bus models:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"l = MTKLine(Library.PiLine(; name=:piline))\nline12 = compile_line(l; src=1, dst=2, piline₊R=0.01)\nline13 = compile_line(l; src=1, dst=3, piline₊R=0.01)\nline23 = compile_line(l; src=2, dst=3, piline₊R=0.01)","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Now we're all set for the next stage.","category":"page"},{"location":"generated/typical_simulation_workflow/#Stage-II:-Initialization","page":"Typical Simulation Workflow","title":"Stage II: Initialization","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"When simulating power systems (or any large dynamical system for that matter), it is quite typical to start from a steady state/equilibrium point. In general, it is not trivial to find such a point for a large nonlinear system. In power systems specifically, it is common to solve a simpler system first – the so-called \"power flow\" problem.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"In the power flow problem, we neglect all the node dynamics and consider only 4 variables at each bus:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"the active power P,\nthe reactive power Q,\nthe voltage magnitude V and\nthe voltage angle theta.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"In the simplest power flow, each bus can then be classified into one of three types:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Slack Bus: The voltage magnitude and angle are fixed (typically used for one bus in the system), P and Q is considered free.\nPV Bus P and V are fixed, Q and theta are free. Often used for generator buses or any buses with active voltage control.\nPQ Bus P and Q are fixed, V and theta are free. Typically used for load buses.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"So each component essentially introduces two algebraic equations and two free variables – the system is then solved for the free variables such that all equations are satisfied.","category":"page"},{"location":"generated/typical_simulation_workflow/#Attaching-Power-Flow-Models","page":"Typical Simulation Workflow","title":"Attaching Power Flow Models","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"In PowerDynamics.jl, we can attach the power flow models to the dynamic bus models using the set_pfmodel! function.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"set_pfmodel!(bus1, pfSlack(V=1))\nset_pfmodel!(bus2, pfPQ(P=-0.4, Q=-0.3))\nset_pfmodel!(bus3, pfPQ(P=-0.6, Q=-0.2))\nnothing #hide","category":"page"},{"location":"generated/typical_simulation_workflow/#Building-the-Network","page":"Typical Simulation Workflow","title":"Building the Network","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Now we can build the network using the Network constructor from NetworkDynamics.jl This constructor takes a list of VertexModels (the buses) and a list of EdgeModels (the powerlines) and connects them to a network. In general, we also need to define the topology of the undelying graph. In this case however, this is not necessary because we told each component at the compile step where it is placed in the network (see the vidx, src and dst arguments above)","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"nw = Network([bus1, bus2, bus3], [line12, line13, line23])","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"The Network object tells us that we've just defined a system with 7 States and 39 parameters. We have 3 vertices of 2 unique types (the inverter bus and the load bus) and 3 edges of a single unique type (all power lines are the same pi-line type).","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"The \"states\" and \"parameters\" already hint at a very important property of PowerDynamics/NetworkDynamics: in the end, the whole network is just a big DAE system of the form","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"mathbfMdotmathbfx = f(mathbfx mathbfp t)","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"where mathbfx are the states and mathbfp the parameters. This is very important to keep in mind, because it allows us to integrate seamlessly with the whole SciML ecosystem and, most importantly, DifferentialEquations.jl.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"@assert dim(nw) == 7 #hide\n@assert pdim(nw) == 39 #hide\n@assert dim(bus1) == 3 #hide\n@assert pdim(bus1) == 8 #hide\n@assert dim(bus2) == dim(bus2) == 2 #hide\n@assert pdim(bus2) == pdim(bus3) == 2 #hide\n@assert dim(line12) == dim(line13) == dim(line23) == 0 #hide\n@assert pdim(line12) == pdim(line13) == pdim(line23) == 9 #hide","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"The 7 states are essentially just the states of our models stacked on top of eachother. Look at the representation of our Vertex and EdgeModels above to see their contribution:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Bus 1: 3 states, 8 parameters\nBus 2 & 3: 2 states, 2 parameters each\nLines 1,2 and 3: 0 states, 9 parameters each","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"In sum, we get the 7 states and 39 parameters.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"tip: Advanced: State and Parameter Ordering\nEven though the states and parameters are essential \"just stacked\" on top of eachother, the ordering is not trivial due to performance reasons. Never rely on the ordering of states or parameters in the full system! PowerDynamics and NetworkDynamics provides lots of helper functions for so-called \"SymbolicIndexing\" to circumvent this.","category":"page"},{"location":"generated/typical_simulation_workflow/#Initializing-the-System-via-Power-Flow","page":"Typical Simulation Workflow","title":"Initializing the System via Power Flow","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"With the network constructed, we can finally find our equilibrium point. We do so using initialize_from_pf:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"s0 = initialize_from_pf(nw; verbose=true, subverbose=true)\nnothing #hide","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"This function actually does quite a lot.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"It extracts the powerflow model for each component constructing the powerflow problem.\nIt solves the powerflow problem.\nFrom the solution, we know the voltages and powers at each bus. Consequently, we also know the currents at each bus. This means we can directly \"map\" the powerflow solution to the inputs and outputs of each dynamic model.\nFor each dynamic model, we \"fix\" the inputs and outputs and try to find values for the states (and potentially parameters) such that the component model is in equilibrium. This is done using a nonlinear solver.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"@assert Set(free_p(nw[VIndex(1)])) == Set([:droop₊Pset, :droop₊Qset]) # hide\n@assert Set(free_u(nw[VIndex(1)])) == Set([:droop₊δ, :droop₊Qfilt, :droop₊Pfilt]) # hide","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"In the log statements, we see which variables/parameters were considered free during the initialization of each component. This behavior can be fine-tuned in a lot of ways, which are beyond the scope of this tutorial. However, here we see that, for example, the complex parameter Y = B + jG of the constant Y-load was initially left free but then initialized from the powerflow solution. This means that Y is now set in a way that it draws the correct amount of power at the given voltage.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Similarly, we see that the inverter bus had the parameters P_set and Q_set free, which were also initialized from the powerflow solution. This is important, because we need to achieve power balance in the system, and due to the losses in the lines it's not possible to know the exact power injections a priori.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"The return value of the initialize_from_pf function is a so-called NWState object, which wraps flat x and p vectors and provides a lot of helper functions to access and modify states (including observables) and parameters.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Lets inspect this object further:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"s0","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"At the highest level, we see the values of the 7 states in the network and their symbolic indices. Those indices can be used to access values directly:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"s0[VIndex(1, :droop₊Pfilt)]","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"tip: Tip\nIn most julia dev environments you can type \\_+<TAB> to autocomplete the MTK namespace separator ₊.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Often, you want to access observables or parameters instead of states. There is a whole filtering and access mechanism you can use for that. For example, in PD.jl, each bus has the states :busbar₊P and :busbar₊Q. We can inspect them on all vertices using:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"s0.v(:, [:busbar₊P, :busbar₊Q])","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"In the output, we clearly see how the load buses draw exactly the amount of power we specified in the power flow models. On the inverter bus, however, we inject slightly more power than the loads demand to compensate for the line losses.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Similarly, we can access all node parameters at initial state using","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"s0.v.p","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Here we see how P_set and Q_set of the inverter were initialized in a way, that they match the powerflow solution.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"There is a lot more functionality in the NWState objects, see the Symbolic Indexing docs of ND.jl and especially the FilteringProxy for more details.","category":"page"},{"location":"generated/typical_simulation_workflow/#Stage-III:-Time-Domain-Simulation","page":"Typical Simulation Workflow","title":"Stage III: Time Domain Simulation","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"With the initialized state, we can finally simulate the system in time domain.","category":"page"},{"location":"generated/typical_simulation_workflow/#Perturbing-the-System","page":"Typical Simulation Workflow","title":"Perturbing the System","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Since we start from an equilibrium point, we expect the system to stay there if we don't perturb it. Therefore, to get interesting results, we need to perturb the system.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"The simplest way to perturb the system is to change a parameter. For example, let's increase the admittance at bus 2 by 10% after 0.1 seconds.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"For that, we define a so-called \"callback function\", more specifically a preset time callback, which is triggered at a specific simulation time and modifies the parameters. The simulation then continues. General information on callbacks in Differential Equations can be found in the DiffEq.jl docs. Specific extensions for NetworkDynamics.jl can be found in the NetworkDynamics.jl callback docs.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"We define the callback and attach it to bus 2 (our first load) like this:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"affect = ComponentAffect([], [:load₊G, :load₊B]) do u, p, ctx\n    @info \"Increase load admittance Y by 10% at t=$(ctx.t)\"\n    p[:load₊G] = p[:load₊G] * 1.1\n    p[:load₊B] = p[:load₊B] * 1.1\nend\ncb = PresetTimeComponentCallback(0.1, affect)\nset_callback!(bus2, cb)\nbus2 #hide","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"With the callback defined, we can finally create and solve the ODEProblem:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"prob = ODEProblem(nw, uflat(s0), (0.0, 5.0), copy(pflat(s0)), callback=get_callbacks(nw))\nsol = solve(prob, Rodas5P());\nnothing #hide","category":"page"},{"location":"generated/typical_simulation_workflow/#Stage-IV:-Postprocessing-and-Visualization","page":"Typical Simulation Workflow","title":"Stage IV: Postprocessing and Visualization","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Once we have the solution object, we can use it like any other solution from DifferentialEquations.jl. Most importantly, we can use symbolic indices to access states, parameters and observables.","category":"page"},{"location":"generated/typical_simulation_workflow/#Plotting-Results","page":"Typical Simulation Workflow","title":"Plotting Results","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"For example, we can quickly plot the frequency response of the droop using","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"lines(sol, idxs=VIndex(1, :droop₊ω); axis=(;xlabel=\"Time [s]\", ylabel=\"Frequency ω [pu]\"))","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"We clearly see how the increased active power leads to a drop in frequency. This drop is then compensated by the droop control (i.e., we stabilize at a lower frequency).","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Of course, we can also create more complex plots, such as this one showing the active and reactive power at each bus:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"let\n    fig = Figure(size=(1000,600))\n    ax = Axis(fig[1, 1]; xlabel=\"Time [s]\", ylabel=\"Active Power Load [pu]\")\n    for i in 2:3\n        lines!(ax, sol, idxs=VIndex(i, :busbar₊P), color=Cycled(i))\n    end\n    axislegend(ax)\n    ax = Axis(fig[1,2]; xlabel=\"Time [s]\", ylabel=\"Reactive Power Load [pu]\")\n    for i in 2:3\n        lines!(ax, sol, idxs=VIndex(i, :busbar₊Q), color=Cycled(i))\n    end\n    axislegend(ax)\n    ax = Axis(fig[2,1]; xlabel=\"Time [s]\", ylabel=\"Active Power Injection [pu]\")\n    lines!(ax, sol, idxs=VIndex(1, :busbar₊P))\n    axislegend(ax)\n    ax = Axis(fig[2,2]; xlabel=\"Time [s]\", ylabel=\"Reactive Power Injection [pu]\")\n    lines!(ax, sol, idxs=VIndex(1, :busbar₊Q))\n    axislegend(ax)\n    fig\nend","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Here we see that the active and reactive power demand shoots up in the beginning after we increase Y. The power demand then slowly decreases again. This is probably due to a drop in voltage, which leads to lower power demand on constant Y loads.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Let's plot the voltage to verify this:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"let\n    fig = Figure()\n    ax = Axis(fig[1, 1]; xlabel=\"Time [s]\", ylabel=\"Voltage [pu]\")\n    for i in 1:3\n        lines!(ax, sol, idxs=VIndex(i, :busbar₊u_mag), color=Cycled(i))\n    end\n    axislegend(ax; position=:rc)\n    fig\nend","category":"page"},{"location":"generated/typical_simulation_workflow/#Programmatic-Access-to-Variables","page":"Typical Simulation Workflow","title":"Programmatic Access to Variables","text":"","category":"section"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Instead of plotting, we can also always use the solution interpolation to access values programmatically. For example","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"sol(1.0, idxs=VIndex(1,:droop₊ω))","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"gives us the frequency of the droop inverter at time t=1.0s.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"Similarly, we can extract time series by passing a vector of time points rather than a single point:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"sol([0.1,0.2,0.3], idxs=VIndex(1:3, :busbar₊u_mag))","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"This code gives us the voltage magnitude at all three buses at the time points 0.1s, 0.2s, and 0.3s.","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"To deeply inspect a single point, we can also construct a NWState object from the solution for a specific time:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"s095 = NWState(sol, 0.95)","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"gives us the state at t=0.95s. We can use the state object for inspection as we did before. For example, we can inspect the power at the destination end of all lines at this point in time:","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"s095.e(:, :dst₊P)","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"","category":"page"},{"location":"generated/typical_simulation_workflow/","page":"Typical Simulation Workflow","title":"Typical Simulation Workflow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/ieee9bus/#ieee9bus","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"This tutorial can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"In this example, we're going to model the IEEE 9 bus system.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"The parameters are mainly adopted from the RTDS data.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"using PowerDynamics\nusing PowerDynamics.Library\nusing ModelingToolkit\nusing NetworkDynamics\nusing Graphs\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie","category":"page"},{"location":"generated/ieee9bus/#Generator-Buses","page":"IEEE 9-Bus Example","title":"Generator Buses","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"The 3 generator buses are modeled using a SauerPai 6th order machine model with variable field voltage and mechanical torque input. The field voltage is provided by an AVRTypeI, the torque is provided by a TGOV1 model.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"function GeneratorBus(; machine_p=(;), avr_p=(;), gov_p=(;))\n    @named machine = SauerPaiMachine(;\n        vf_input=true,\n        τ_m_input=true,\n        S_b=100,\n        V_b=1,\n        ω_b=2π*60,\n        R_s=0.000125,\n        T″_d0=0.01,\n        T″_q0=0.01,\n        machine_p... # unpack machine parameters\n    )\n    @named avr = AVRTypeI(; vr_min=-5, vr_max=5,\n        Ka=20, Ta=0.2,\n        Kf=0.063, Tf=0.35,\n        Ke=1, Te=0.314,\n        E1=3.3, Se1=0.6602, E2=4.5, Se2=4.2662,\n        tmeas_lag=false,\n        avr_p... # unpack AVR parameters\n    )\n    @named gov = TGOV1(; R=0.05, T1=0.05, T2=2.1, T3=7.0, DT=0, V_max=5, V_min=-5,\n        gov_p... # unpack governor parameters\n    )\n    # generate the \"injector\" as combination of multiple components\n    injector = CompositeInjector([machine, avr, gov]; name=:generator)\n\n    # generate the MTKBus (i.e. the MTK model containg the busbar and the injector)\n    mtkbus = MTKBus(injector)\nend\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Load-Buses","page":"IEEE 9-Bus Example","title":"Load Buses","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"The dynamic loads are modeled as static Y-loads. Those have 2 parameters: G and B which form the complex admittance","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"Y = G + jB","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"For now, those parameters will be left free. We'll initialize them later on from the powerflow results.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"function ConstantYLoadBus()\n    @named load = ConstantYLoad()\n    MTKBus(load; name=:loadbus)\nend\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Generate-Dynamical-models","page":"IEEE 9-Bus Example","title":"Generate Dynamical models","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"The parameters of the machines are obtained from the data table from the RTDS datasheet.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"gen1p = (;X_ls=0.01460, X_d=0.1460, X′_d=0.0608, X″_d=0.06, X_q=0.1000, X′_q=0.0969, X″_q=0.06, T′_d0=8.96, T′_q0=0.310, H=23.64)\ngen2p = (;X_ls=0.08958, X_d=0.8958, X′_d=0.1198, X″_d=0.11, X_q=0.8645, X′_q=0.1969, X″_q=0.11, T′_d0=6.00, T′_q0=0.535, H= 6.40)\ngen3p = (;X_ls=0.13125, X_d=1.3125, X′_d=0.1813, X″_d=0.18, X_q=1.2578, X′_q=0.2500, X″_q=0.18, T′_d0=5.89, T′_q0=0.600, H= 3.01)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"We instantiate all models as modeling toolkit models.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"mtkbus1 = GeneratorBus(; machine_p=gen1p)\nmtkbus2 = GeneratorBus(; machine_p=gen2p)\nmtkbus3 = GeneratorBus(; machine_p=gen3p)\nmtkbus4 = MTKBus() # <- bus with no injectors, essentially\nmtkbus5 = ConstantYLoadBus()\nmtkbus6 = ConstantYLoadBus()\nmtkbus7 = MTKBus()\nmtkbus8 = ConstantYLoadBus()\nmtkbus9 = MTKBus()\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"After this, we can build the NetworkDynamics components using the Bus-constructor.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"The Bus constructor is essentially a thin wrapper around the VertexModel constructor which, per default, adds some metadata. For example the vidx property which later on allows for \"graph free\" network dynamics instantiation.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"We use the pf keyword to specify the models which should be used in the powerflow calculation. Here, generator 1 is modeled as a slack bus while the other two generators are modeled as PV buses. The loads are modeled as PQ buses.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"@named bus1 = compile_bus(mtkbus1; vidx=1, pf=pfSlack(V=1.04))\n@named bus2 = compile_bus(mtkbus2; vidx=2, pf=pfPV(V=1.025, P=1.63))\n@named bus3 = compile_bus(mtkbus3; vidx=3, pf=pfPV(V=1.025, P=0.85))\n@named bus4 = compile_bus(mtkbus4; vidx=4)\n@named bus5 = compile_bus(mtkbus5; vidx=5, pf=pfPQ(P=-1.25, Q=-0.5))\n@named bus6 = compile_bus(mtkbus6; vidx=6, pf=pfPQ(P=-0.9, Q=-0.3))\n@named bus7 = compile_bus(mtkbus7; vidx=7)\n@named bus8 = compile_bus(mtkbus8; vidx=8, pf=pfPQ(P=-1.0, Q=-0.35))\n@named bus9 = compile_bus(mtkbus9; vidx=9)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Branches","page":"IEEE 9-Bus Example","title":"Branches","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"Branches and Transformers are built from the same PILine model with optional transformer on both ends. However, the data is provided in a way that the actual transformer values are 1.0. Apparently, the transforming action has been absorbed into the line parameters according to the base voltage on both ends.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"For the lines we again make use of the src and dst metadata of the EdgeModel objects for automatic graph construction.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"function piline(; R, X, B)\n    @named pibranch = PiLine(;R, X, B_src=B/2, B_dst=B/2, G_src=0, G_dst=0)\n    MTKLine(pibranch)\nend\nfunction transformer(; R, X)\n    @named transformer = PiLine(;R, X, B_src=0, B_dst=0, G_src=0, G_dst=0)\n    MTKLine(transformer)\nend\n\n@named l45 = compile_line(piline(; R=0.0100, X=0.0850, B=0.1760), src=4, dst=5)\n@named l46 = compile_line(piline(; R=0.0170, X=0.0920, B=0.1580), src=4, dst=6)\n@named l57 = compile_line(piline(; R=0.0320, X=0.1610, B=0.3060), src=5, dst=7)\n@named l69 = compile_line(piline(; R=0.0390, X=0.1700, B=0.3580), src=6, dst=9)\n@named l78 = compile_line(piline(; R=0.0085, X=0.0720, B=0.1490), src=7, dst=8)\n@named l89 = compile_line(piline(; R=0.0119, X=0.1008, B=0.2090), src=8, dst=9)\n@named t14 = compile_line(transformer(; R=0, X=0.0576), src=1, dst=4)\n@named t27 = compile_line(transformer(; R=0, X=0.0625), src=2, dst=7)\n@named t39 = compile_line(transformer(; R=0, X=0.0586), src=3, dst=9)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Build-Network","page":"IEEE 9-Bus Example","title":"Build Network","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"Finally, we can build the network by providing the vertices and edges.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"vertexfs = [bus1, bus2, bus3, bus4, bus5, bus6, bus7, bus8, bus9];\nedgefs = [l45, l46, l57, l69, l78, l89, t14, t27, t39];\nnw = Network(vertexfs, edgefs; warn_order=false)","category":"page"},{"location":"generated/ieee9bus/#System-Initialization","page":"IEEE 9-Bus Example","title":"System Initialization","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"To initialize the system for dynamic simulation, we use initialize_from_pf! which performs a unified powerflow solving and component initialization process.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"Internally, this function:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"Builds an equivalent static powerflow network from the dynamic models\nSolves the static powerflow equations using the specified powerflow models (pfSlack, pfPV, pfPQ)\nUses the powerflow solution to initialize all dynamic component states and parameters","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"This ensures that the dynamic model starts from a steady-state condition that matches the powerflow solution. Specifically, it determines:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"Bus voltages and currents from the powerflow solution\nUnknown G and B parameters for load buses\nInternal machine states (flux linkages, rotor angles, etc.)\nController states and references for AVRs and governors","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"For example, we use constant Y-loads for the dynamic load models. Those have a fixed admittance","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"Y = G+jB","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"which is not known a priori. However, from the powerflow (where the loads are modeled as PQ loads) we know both voltage and current at steady state. With this knowledge, we can determine the missing parameters G and B such that the dynamic load model matches the static load model in the initial state.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"u0 = initialize_from_pf(nw);\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"To verify what we've just said, we can check the initial values of the active and reactive power of our constant Y load model at bus 5 to see if it matches the setpoints of our powerflow model:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"u0[VIndex(5, :load₊P)] ≈ -1.25 && u0[VIndex(5, :load₊Q)] ≈ -0.5","category":"page"},{"location":"generated/ieee9bus/#Disturbance","page":"IEEE 9-Bus Example","title":"Disturbance","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"To see some dynamics, we need to introduce some disturbance. For that we use a PresetTimeComponentCallback to deactivate a line at a certain time.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"deactivate_line = ComponentAffect([], [:pibranch₊active]) do u, p, ctx\n    @info \"Deactivate line $(ctx.src)=>$(ctx.dst) at t=$(ctx.t)\"\n    p[:pibranch₊active] = 0\nend\ncb = PresetTimeComponentCallback([1.0], deactivate_line)\nset_callback!(l46, cb)\nl46 # printout shows that the callback is set","category":"page"},{"location":"generated/ieee9bus/#Dynamic-Simulation","page":"IEEE 9-Bus Example","title":"Dynamic Simulation","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"With the system properly initialized, we can now set up and run the dynamic simulation. We create an ODE problem using the initialized state and simulate the system response to the line outage disturbance.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"prob = ODEProblem(nw, uflat(u0), (0,15), pflat(u0); callback=get_callbacks(nw))\nsol = solve(prob, Rodas5P())\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Plotting-the-Solution","page":"IEEE 9-Bus Example","title":"Plotting the Solution","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"Finally, we visualize the simulation results showing the system response to the line outage at t=1.0 seconds. The plots show active power, voltage magnitudes, and generator frequencies across the simulation time.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"fig = Figure(size=(600,800));\n\n# Active power at selected buses\nax = Axis(fig[1, 1]; title=\"Active Power\", xlabel=\"Time [s]\", ylabel=\"Power [pu]\")\nfor i in [1,2,3,5,6,8]\n    lines!(ax, sol; idxs=VIndex(i,:busbar₊P), label=\"Bus $i\", color=Cycled(i))\nend\naxislegend(ax)\n\n# Voltage magnitude at all buses\nax = Axis(fig[2, 1]; title=\"Voltage Magnitude\", xlabel=\"Time [s]\", ylabel=\"Voltage [pu]\")\nfor i in 1:9\n    lines!(ax, sol; idxs=VIndex(i,:busbar₊u_mag), label=\"Bus $i\", color=Cycled(i))\nend\n\n# Generator frequencies\nax = Axis(fig[3, 1]; title=\"Generator Frequency\", xlabel=\"Time [s]\", ylabel=\"Frequency [pu]\")\nfor i in 1:3\n    lines!(ax, sol; idxs=VIndex(i,:generator₊machine₊ω), label=\"Gen $i\", color=Cycled(i))\nend\naxislegend(ax)\n\nfig #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9-Bus Example","title":"IEEE 9-Bus Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/ieee39_part1/#ieee39-part1","page":"IEEE39 Part I: Modeling","title":"IEEE39 Bus Tutorial - Part I: Model Creation","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"This tutorial can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"This is the first part of a four-part tutorial series for the IEEE 39-bus test system:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Part I: Model Creation (this tutorial) - Build the network structure with buses, lines, and components\nPart II: Initialization - Perform power flow calculations and dynamic initialization\nPart III: Dynamic Simulation - Run time-domain simulations and analyze system behavior\nPart IV: Advanced Modeling & Parameter Optimization - Create custom components and optimize system parameters","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"In this first part, we'll construct the complete IEEE 39-bus network model using PowerDynamics.jl, including generators, loads, transmission lines, and control systems.","category":"page"},{"location":"generated/ieee39_part1/#System-Structure","page":"IEEE39 Part I: Modeling","title":"System Structure","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The system consists of 39 buses (with 10 generators and 19 loads) and 46 branches (12 of which are transformers).","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The buses fall into the following categories:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Junction: pure transient buses without dynamic components\nLoad: buses with loads only\nControlled Machine: buses with controlled machines (generators with AVR and GOV)\nControlled Machine + Load: buses with controlled machines and loads\nUncontrolled Machine + Load: buses with uncontrolled machines and loads","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"For the power flow solution, we have a slack bus, PV buses and PQ buses.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"For the dynamic simulation, we will use the following models:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"ZIP Load for loads,\n6th Order Sauer-Pai Machine and\nAVR Type I and TGOV1 for controlled machines.","category":"page"},{"location":"generated/ieee39_part1/#Setup-and-Data-Loading","page":"IEEE39 Part I: Modeling","title":"Setup and Data Loading","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"warning: No Standardized Data Import\nAs of now, PowerDynamics.jl does not support any advanced import mechanisms for power grids. Therefore, this tutorial loads the data from some custom CSV files.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"First, we'll load the required packages and read the system data from CSV files. The IEEE 39-bus system data is organized into separate files for different components.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"using PowerDynamics\nusing PowerDynamics.Library\nusing ModelingToolkit\nusing NetworkDynamics\nusing DataFrames\nusing CSV\n\nDATA_DIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\", \"ieee39data\")\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The system data is stored in CSV files containing:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"details: bus.csv - Bus Configuration Data\nParameter Description\nbus Bus number (unique identifier)\nbus_type Power flow bus type: \"PQ\" (load), \"PV\" (generator), \"Slack\" (reference)\ncategory Component category: \"junction\", \"load\", \"ctrld_machine\", \"ctrld_machine_load\", \"unctrld_machine_load\"\nP Active power injection [pu] (positive = generation, negative = load)\nQ Reactive power injection [pu] (positive = generation, negative = load)\nV Voltage magnitude [pu] (for PV and Slack buses)\nbase_kv Base voltage level [kV]\nhas_load Boolean flag indicating presence of load component\nhas_gen Boolean flag indicating presence of generator component\nhas_avr Boolean flag indicating presence of automatic voltage regulator\nhas_gov Boolean flag indicating presence of turbine governor","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"details: branch.csv - Transmission Line and Transformer Data\nParameter Description\nsrc_bus Source bus number\ndst_bus Destination bus number\ntransformer Transformer flag (0 = line, 1 = transformer)\nr_src Source end transformation ratio [pu]\nR Series resistance [pu]\nX Series reactance [pu]\nG_src Source end shunt conductance [pu]\nG_dst Destination end shunt conductance [pu]\nB_src Source end shunt susceptance [pu]\nB_dst Destination end shunt susceptance [pu]","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"details: load.csv - ZIP Load Model Parameters\nParameter Description\nbus Bus number where load is connected\nPset Active power at operation point [pu]\nQset Reactive power at operation point [pu]\nKpZ Active power constant impedance fraction\nKqZ Reactive power constant impedance fraction\nKpI Active power constant current fraction\nKqI Reactive power constant current fraction\nKpC Active power constant power fraction (1-KpZ-KpI)\nKqC Reactive power constant power fraction (1-KqZ-KqI)Note: ZIP loads combine constant impedance (Z), constant current (I), and constant power (P) components.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"details: machine.csv - Generator (Sauer-Pai Machine) Parameters\nParameter Description\nbus Bus number where generator is connected\nSn Machine power rating [MVA]\nV_b System voltage basis [kV]\nVn Machine voltage rating [kV]\nR_s Stator resistance [pu]\nX_ls Stator leakage reactance [pu]\nX_d d-axis synchronous reactance [pu]\nX_q q-axis synchronous reactance [pu]\nX′_d d-axis transient reactance [pu]\nX′_q q-axis transient reactance [pu]\nX″_d d-axis subtransient reactance [pu]\nX″_q q-axis subtransient reactance [pu]\nT′_d0 d-axis transient time constant [s]\nT′_q0 q-axis transient time constant [s]\nT″_d0 d-axis subtransient time constant [s]\nT″_q0 q-axis subtransient time constant [s]\nH Inertia constant [s]\nD Direct shaft damping coefficient","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"details: avr.csv - Automatic Voltage Regulator (AVR Type I) Parameters\nParameter Description\nbus Bus number where AVR-controlled generator is located\nKa Amplifier gain\nKe Field circuit integral deviation\nKf Stabilizer gain\nTa Amplifier time constant [s]\nTf Stabilizer time constant [s]\nTe Field circuit time constant [s]\nTr Measurement time constant [s]\nvr_min Minimum regulator voltage [pu]\nvr_max Maximum regulator voltage [pu]\nE1 First ceiling voltage [pu]\nSe1 First ceiling saturation factor\nE2 Second ceiling voltage [pu]\nSe2 Second ceiling saturation factor","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"details: gov.csv - Turbine Governor (TGOV1) Parameters\nParameter Description\nbus Bus number where governor-controlled generator is located\nV_min Minimum valve position [pu]\nV_max Maximum valve position [pu]\nR Governor droop [Machine PU]\nT1 First transient time constant [s]\nT2 Second transient time constant [s]\nT3 Third transient time constant [s]\nDT Turbine damping coefficient\nω_ref Reference frequency [pu]","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"branch_df = CSV.read(joinpath(DATA_DIR, \"branch.csv\"), DataFrame)\nbus_df = CSV.read(joinpath(DATA_DIR, \"bus.csv\"), DataFrame)\nload_df = CSV.read(joinpath(DATA_DIR, \"load.csv\"), DataFrame)\nmachine_df = CSV.read(joinpath(DATA_DIR, \"machine.csv\"), DataFrame)\navr_df = CSV.read(joinpath(DATA_DIR, \"avr.csv\"), DataFrame)\ngov_df = CSV.read(joinpath(DATA_DIR, \"gov.csv\"), DataFrame)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"System base values follow the IEEE 39-bus standard:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"BASE_MVA = 100.0\nBASE_FREQ = 60.0\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/#Subcomponent-Definition","page":"IEEE39 Part I: Modeling","title":"Subcomponent Definition","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"As stated above, our buses fall into 5 different categories. We will define a \"template\" for each of those categories and then create the individual buses from those templates. By doing so, we can reach substantial performance improvements, as we do not have to repeatedly compile the same models (the symbolic simplification is quite costly). Instead, we copy the templates and adjust parameters.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"However, before we can define the bus templates, we need to define the individual subcomponents. Those subcomponents are MTK models and not yet compiled node models. See Modeling Concepts and the custom bus tutorial.","category":"page"},{"location":"generated/ieee39_part1/#Load-Model","page":"IEEE39 Part I: Modeling","title":"Load Model","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"We use the ZIP load model to represent loads. This model satisfies the Injector Interface.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"(t) ┌──────────┐\n o──┤ ZIP Load │\n    └──────────┘","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"load = ZIPLoad(;name=:ZIPLoad)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/#Generator-Models","page":"IEEE39 Part I: Modeling","title":"Generator Models","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"For generators, we use the Sauer-Pai machine model, which is a 6th-order synchronous machine model. We create two variants:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Uncontrolled Machine: No external control inputs for mechanical torque or field voltage. This model satisfies the Injector Interface directly.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"(t) ┌─────────┐\n o──┤ Machine │\n    └─────────┘","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"uncontrolled_machine = SauerPaiMachine(;\n    τ_m_input=false,  ## No external mechanical torque input\n    vf_input=false,   ## No external field voltage input\n    name=:machine,\n)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Controlled Machine: Includes automatic voltage regulator (AVR) and turbine governor controls.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The controlled machine is modeled as a composite injector. It consists of 3 subcomponents: the machine, the AVR and the governor. The AVR receives the voltage magnitude measurement from the terminal of the machine and sets the field voltage. The governor receives the frequency measurement and sets the mechanical torque. Together, they satisfy the Injector Interface.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"      ┌───────────────────────────────┐\n      │ CtrldMachine  u_mag_meas      │\n      │              ╭─────→────╮     │\n      │    ┌─────────┴─┐      ┌─┴───┐ │\n  (t) │    │           ├───←──┤ AVR │ │\n   o──┼────┤ Sauer-Pai │ vf   └─────┘ │\n      │    │ Machine   │ τ_m  ┌─────┐ │\n      │    │           ├───←──┤ Gov │ │\n      │    └─────────┬─┘      └─┬───┘ │\n      │              ╰─────→────╯     │\n      │                 ω_meas        │\n      └───────────────────────────────┘","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"_machine = SauerPaiMachine(;\n    name=:machine,\n)\n_avr = AVRTypeI(;\n    name=:avr,\n    ceiling_function=:quadratic,\n)\n_gov = TGOV1(; name=:gov,)\n\ncontrolled_machine = CompositeInjector(\n    [_machine, _avr, _gov],\n    name=:ctrld_gen\n)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/#Bus-Template-Creation","page":"IEEE39 Part I: Modeling","title":"Bus Template Creation","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Now we have all the components (i.e., the MTK models) so we can combine them into full bus models and compile the methods.","category":"page"},{"location":"generated/ieee39_part1/#Junction-Bus","page":"IEEE39 Part I: Modeling","title":"Junction Bus","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Pure transmission buses with no generation or load","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"           ╔══════════════════════╗\n           ║ Junction (compiled)  ║\n Network   ║  ┌─────────────────┐ ║\ninterface  ║  │MTKBus           │ ║\n current ────→│┌──────┐         │ ║\n           ║  ││BusBar│(nothing)│ ║\n voltage ←────│└──────┘         │ ║\n           ║  └─────────────────┘ ║\n           ╚══════════════════════╝","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"@named junction_bus_template = compile_bus(MTKBus())\nstrip_defaults!(junction_bus_template)  ## Clear default parameters for manual setting\njunction_bus_template #hide","category":"page"},{"location":"generated/ieee39_part1/#Load-Bus","page":"IEEE39 Part I: Modeling","title":"Load Bus","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Buses with only load components","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"           ╔═════════════════════╗\n           ║ Load (compiled)     ║\n Network   ║  ┌────────────────┐ ║\ninterface  ║  │MTKBus          │ ║\n current ────→│┌──────┐ ┌────┐ │ ║\n           ║  ││BusBar├o┤Load│ │ ║\n voltage ←────│└──────┘ └────┘ │ ║\n           ║  └────────────────┘ ║\n           ╚═════════════════════╝","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"@named load_bus_template = compile_bus(MTKBus(load))\nstrip_defaults!(load_bus_template)\nload_bus_template #hide","category":"page"},{"location":"generated/ieee39_part1/#Generator-Bus-(Controlled)","page":"IEEE39 Part I: Modeling","title":"Generator Bus (Controlled)","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Buses with controlled generators (machine + AVR + governor)","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"            ╔════════════════════════════════════════════════╗\n            ║ Ctrld Machine Bus (compiled)                   ║\n            ║  ┌───────────────────────────────────────────┐ ║\n            ║  │MTKBus                                     │ ║\n            ║  │         ┌───────────────────────────────┐ │ ║\n  Network   ║  │         │CtrldMachine  ╭─────→────╮     │ │ ║\n interface  ║  │         │    ┌─────────┴─┐      ┌─┴───┐ │ │ ║\n  current ────→│┌──────┐ │    │           ├───←──┤ AVR │ │ │ ║\n            ║  ││BusBar├o┼────┤ Sauer-Pai │      └─────┘ │ │ ║\n  voltage ←────│└──────┘ │    │ Machine   │      ┌─────┐ │ │ ║\n            ║  │         │    │           ├───←──┤ Gov │ │ │ ║\n            ║  │         │    └─────────┬─┘      └─┬───┘ │ │ ║\n            ║  │         │              ╰─────→────╯     │ │ ║\n            ║  │         └───────────────────────────────┘ │ ║\n            ║  └───────────────────────────────────────────┘ ║\n            ╚════════════════════════════════════════════════╝","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"@named ctrld_machine_bus_template = compile_bus(\n    MTKBus(controlled_machine);\n)\nstrip_defaults!(ctrld_machine_bus_template)\n# Set system-wide base values for all generators\nset_default!(ctrld_machine_bus_template, r\"S_b$\", BASE_MVA)\nset_default!(ctrld_machine_bus_template, r\"ω_b$\", 2π*BASE_FREQ)\nctrld_machine_bus_template #hide","category":"page"},{"location":"generated/ieee39_part1/#Generator-Load-Bus-(Controlled)","page":"IEEE39 Part I: Modeling","title":"Generator + Load Bus (Controlled)","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Buses with both controlled generators and loads","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"            ╔═════════════════════════════════════════════════╗\n            ║ Ctrld Machine Load Bus (compiled)               ║\n            ║  ┌────────────────────────────────────────────┐ ║\n            ║  │MTKBus    ┌───────────────────────────────┐ │ ║\n            ║  │          │CtrldMachine  ╭─────→────╮     │ │ ║\n            ║  │          │    ┌─────────┴─┐      ┌─┴───┐ │ │ ║\n            ║  │          │    │           ├───←──┤ AVR │ │ │ ║\n  Network   ║  │        ┌─┼────┤ Sauer-Pai │      └─────┘ │ │ ║\n interface  ║  │        │ │    │ Machine   │      ┌─────┐ │ │ ║\n  current ────→│┌──────┐│ │    │           ├───←──┤ Gov │ │ │ ║\n            ║  ││BusBar├o │    └─────────┬─┘      └─┬───┘ │ │ ║\n  voltage ←────│└──────┘│ │              ╰─────→────╯     │ │ ║\n            ║  │        │ └───────────────────────────────┘ │ ║\n            ║  │        │ ┌──────┐                          │ ║\n            ║  │        └─┤ Load │                          │ ║\n            ║  │          └──────┘                          │ ║\n            ║  └────────────────────────────────────────────┘ ║\n            ╚═════════════════════════════════════════════════╝","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"@named ctrld_machine_load_bus_template = compile_bus(\n    MTKBus(controlled_machine, load);\n)\nstrip_defaults!(ctrld_machine_load_bus_template)\nset_default!(ctrld_machine_load_bus_template, r\"S_b$\", BASE_MVA)\nset_default!(ctrld_machine_load_bus_template, r\"ω_b$\", 2π*BASE_FREQ)\nctrld_machine_load_bus_template #hide","category":"page"},{"location":"generated/ieee39_part1/#Generator-Load-Bus-(Uncontrolled)","page":"IEEE39 Part I: Modeling","title":"Generator + Load Bus (Uncontrolled)","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Buses with uncontrolled generators and loads","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"            ╔════════════════════════════════╗\n            ║ Unctr. Ma. Load Bus (compiled) ║\n            ║  ┌────────────────────────┐    ║\n  Network   ║  │MTKBus      ┌─────────┐ │    ║\n interface  ║  │          ┌─┤ Machine │ │    ║\n  current ────→│ ┌──────┐ │ └─────────┘ │    ║\n            ║  │ │BusBar├─o             │    ║\n  voltage ←────│ └──────┘ │ ┌──────┐    │    ║\n            ║  │          └─┤ Load │    │    ║\n            ║  │            └──────┘    │    ║\n            ║  └────────────────────────┘    ║\n            ╚════════════════════════════════╝","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"@named unctrld_machine_load_bus_template = compile_bus(\n    MTKBus(uncontrolled_machine, load);\n)\nstrip_defaults!(unctrld_machine_load_bus_template)\nset_default!(unctrld_machine_load_bus_template, r\"S_b$\", BASE_MVA)\nset_default!(unctrld_machine_load_bus_template, r\"ω_b$\", 2π*BASE_FREQ)\nunctrld_machine_load_bus_template #hide","category":"page"},{"location":"generated/ieee39_part1/#Bus-Instantiation-and-Parameter-Setting","page":"IEEE39 Part I: Modeling","title":"Bus Instantiation and Parameter Setting","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Now we create the actual bus instances by copying templates and applying specific parameters from the CSV data files.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"# Helper function to apply CSV parameters to bus components\nfunction apply_csv_params!(bus, table, bus_index)\n    row_idx = findfirst(table.bus .== bus_index)\n\n    # Apply all parameters except \"bus\" column\n    row = table[row_idx, :]\n    for col_name in names(table)\n        if col_name != \"bus\"\n            set_default!(bus, Regex(col_name*\"\\$\"), row[col_name])\n        end\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"For each bus in the system, we:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Select the appropriate template based on its category\nCreate a bus instance with the correct vertex index and name\nApply component-specific parameters from CSV files\nSet the power flow model (PQ, PV, or Slack)","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"busses = []\nfor row in eachrow(bus_df)\n    i = row.bus\n\n    # Select template based on bus category\n    bus = if row.category == \"junction\"\n        compile_bus(junction_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    elseif row.category == \"load\"\n        compile_bus(load_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    elseif row.category == \"ctrld_machine\"\n        compile_bus(ctrld_machine_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    elseif row.category == \"ctrld_machine_load\"\n        compile_bus(ctrld_machine_load_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    elseif row.category == \"unctrld_machine_load\"\n        compile_bus(unctrld_machine_load_bus_template; vidx=i, name=Symbol(\"bus$i\"))\n    end\n\n    # Apply component parameters from CSV files\n    row.has_load && apply_csv_params!(bus, load_df, i)\n    row.has_gen && apply_csv_params!(bus, machine_df, i)\n    row.has_avr && apply_csv_params!(bus, avr_df, i)\n    row.has_gov && apply_csv_params!(bus, gov_df, i)\n\n    # Set power flow model based on bus type\n    pf_model = if row.bus_type == \"PQ\"\n        pfPQ(P=row.P, Q=row.Q)  ## Load bus: fixed P and Q\n    elseif row.bus_type == \"PV\"\n        pfPV(P=row.P, V=row.V)  ## Generator bus: fixed P and V\n    elseif row.bus_type == \"Slack\"\n        pfSlack(V=row.V, δ=0)   ## Slack bus: fixed V and angle\n    end\n    set_pfmodel!(bus, pf_model)\n\n    push!(busses, bus)\nend","category":"page"},{"location":"generated/ieee39_part1/#Transmission-Line-Creation","page":"IEEE39 Part I: Modeling","title":"Transmission Line Creation","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The IEEE 39-bus system includes both transmission lines and transformers, all modeled using the π-line equivalent circuit model.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The model consists of several layers:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The PiModel, which satisfies the Branch Interface as it has two terminals\nThe MTKLine constructor, which creates a MTK model fulfilling the MTKLine Interface\nThe compiled EdgeModel created by calling the compile_line constructor","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"       ╔══════════════════════════════════╗\n       ║ EdgeModel (compiled)             ║\n   src ║ ┌──────────────────────────────┐ ║ dst\nvertex ║ │MTKLine                       │ ║ vertex\n   u ───→│┌───────┐ ┌────────┐ ┌───────┐│←─── u\n       ║ ││LineEnd├o┤ PiLine ├o┤LineEnd││ ║\n   i ←───│└───────┘ └────────┘ └───────┘│───→ i\n       ║ └──────────────────────────────┘ ║\n       ╚══════════════════════════════════╝","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"(We used the PiLine_fault model since we plan on simulating short circuits later.)","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"@named piline_template = compile_line(MTKLine(PiLine_fault(;name=:piline)))","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Each transmission element is created by:","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Instantiating a line from the template with source and destination buses\nSetting electrical parameters (resistance, reactance, susceptance) from CSV data","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"branches = []\nfor row in eachrow(branch_df)\n    # Create line instance with topology\n    line = compile_line(piline_template; src=row.src_bus, dst=row.dst_bus)\n\n    # Apply electrical parameters from CSV data\n    for col_name in names(branch_df)\n        if col_name ∉ [\"src_bus\", \"dst_bus\", \"transformer\"]\n            set_default!(line, Regex(col_name*\"\\$\"), row[col_name])\n        end\n    end\n\n    push!(branches, line)\nend","category":"page"},{"location":"generated/ieee39_part1/#Network-Assembly","page":"IEEE39 Part I: Modeling","title":"Network Assembly","text":"","category":"section"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"Finally, we combine all buses and transmission lines into a complete network model. This creates the IEEE 39-bus test system ready for initialization and simulation.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"nw = Network(busses, branches)","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"The network nw now contains the complete IEEE 39-bus model structure. In Part 2 of this tutorial series, we'll initialize this network by solving the power flow and setting up the dynamic initial conditions.","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"","category":"page"},{"location":"generated/ieee39_part1/","page":"IEEE39 Part I: Modeling","title":"IEEE39 Part I: Modeling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Library/#Component-Library","page":"Component Library","title":"Component Library","text":"","category":"section"},{"location":"Library/","page":"Component Library","title":"Component Library","text":"This page documents all the pre-built components available in the PowerDynamics.jl library.","category":"page"},{"location":"Library/","page":"Component Library","title":"Component Library","text":"warning: PowerDynamics.Library Under Active Development\nThe PowerDynamics.Library component library is currently excluded from semantic versioning and is under heavy development.While PowerDynamics itself follows semantic versioning, the Library submodule's API is highly unstable and variable names, function signatures, and model interfaces may change frequently without notice. If you are using specific models from PowerDynamics.Library in their current state, we strongly recommend copying them to your own source code to avoid breaking changes in future updates.","category":"page"},{"location":"Library/#Slack-Models","page":"Component Library","title":"Slack Models","text":"","category":"section"},{"location":"Library/#Algebraic-and-Differential-Slack","page":"Component Library","title":"Algebraic and Differential Slack","text":"","category":"section"},{"location":"Library/#Machine-Models","page":"Component Library","title":"Machine Models","text":"","category":"section"},{"location":"Library/#Synchronous-Machine-Models","page":"Component Library","title":"Synchronous Machine Models","text":"","category":"section"},{"location":"Library/#PowerDynamics.Library.PSSE_GENCLS","page":"Component Library","title":"PowerDynamics.Library.PSSE_GENCLS","text":"PSSE_GENCLS\n\nThis model is a port of the OpenIPSL Electrical.Machines.PSSE.GENCLS model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Machines.PSSE.GENCLS. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_GENROU","page":"Component Library","title":"PowerDynamics.Library.PSSE_GENROU","text":"PSSE_GENROU\n\nThis model is a port of the OpenIPSL Electrical.Machines.PSSE.GENROU model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Machines.PSSE.GENROU. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"function"},{"location":"Library/#PowerDynamics.Library.PSSE_GENROE","page":"Component Library","title":"PowerDynamics.Library.PSSE_GENROE","text":"PSSE_GENROE\n\nThis model is a port of the OpenIPSL Electrical.Machines.PSSE.GENROE model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Machines.PSSE.GENROE. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"function"},{"location":"Library/#PowerDynamics.Library.PSSE_GENSAL","page":"Component Library","title":"PowerDynamics.Library.PSSE_GENSAL","text":"PSSE_GENSAL\n\nThis model is a port of the OpenIPSL Electrical.Machines.PSSE.GENSAL model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Machines.PSSE.GENSAL. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"function"},{"location":"Library/#PowerDynamics.Library.PSSE_GENSAE","page":"Component Library","title":"PowerDynamics.Library.PSSE_GENSAE","text":"PSSE_GENSAE\n\nThis model is a port of the OpenIPSL Electrical.Machines.PSSE.GENSAE model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Machines.PSSE.GENSAE. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"function"},{"location":"Library/#Control-Systems","page":"Component Library","title":"Control Systems","text":"","category":"section"},{"location":"Library/#Exciters-and-AVRs","page":"Component Library","title":"Exciters & AVRs","text":"","category":"section"},{"location":"Library/#PowerDynamics.Library.PSSE_EXST1","page":"Component Library","title":"PowerDynamics.Library.PSSE_EXST1","text":"PSSE_EXST1\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.ES.EXST1 model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.ES.EXST1. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_ESST4B","page":"Component Library","title":"PowerDynamics.Library.PSSE_ESST4B","text":"PSSE_ESST4B\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.ES.ESST4B model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.ES.ESST4B. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\nwarning: Slight deviations from OpenIPSL behavior\nThere are still some slight deviations, likely due to differences in the initialization/steady state (see the current integrator state in the validation plot).\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_ESST1A","page":"Component Library","title":"PowerDynamics.Library.PSSE_ESST1A","text":"PSSE_ESST1A\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.ES.ESST1A model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.ES.ESST1A. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_SCRX","page":"Component Library","title":"PowerDynamics.Library.PSSE_SCRX","text":"PSSE_SCRX\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.ES.SCRX model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.ES.SCRX. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_IEEET1","page":"Component Library","title":"PowerDynamics.Library.PSSE_IEEET1","text":"PSSE_IEEET1\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.ES.IEEET1 model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.ES.IEEET1. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#Governors-and-Turbines","page":"Component Library","title":"Governors and Turbines","text":"","category":"section"},{"location":"Library/#PowerDynamics.Library.PSSE_IEEEG1","page":"Component Library","title":"PowerDynamics.Library.PSSE_IEEEG1","text":"PSSE_IEEEG1\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.TG.IEEEG1 model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.TG.IEEEG1. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\nwarning: Slight deviations from OpenIPSL behavior\nThere are still some slight deviations, likely due to differences in the initialization/steady state (see P_MECH output of the validation plot).\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_HYGOV","page":"Component Library","title":"PowerDynamics.Library.PSSE_HYGOV","text":"PSSE_HYGOV\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.TG.HYGOV model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.TG.HYGOV. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#PowerDynamics.Library.PSSE_GGOV1_EXPERIMENTAL","page":"Component Library","title":"PowerDynamics.Library.PSSE_GGOV1_EXPERIMENTAL","text":"PSSE_GGOV1_EXPERIMENTAL\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.TG.GGOV1 model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nwarning: Warning\nThis model does not support delay! It is validaded against a modified version of the OpenIPSL SMIB testcase Tests.Controls.PSSE.TG.GGOV1 without delay (see reference data generation script in /test/OpenIPSL/GGOV1 for modified version). Also, the OpenIPSL testcase does not start in a steady state, so we have some deviation in the validation still.     See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#Power-System-Stabilizers-(PSS)","page":"Component Library","title":"Power System Stabilizers (PSS)","text":"","category":"section"},{"location":"Library/#PowerDynamics.Library.PSSE_IEEEST","page":"Component Library","title":"PowerDynamics.Library.PSSE_IEEEST","text":"PSSE_IEEEST\n\nThis model is a port of the OpenIPSL Electrical.Controls.PSSE.PSS.IEEEST model, maintaining the same mathematical formulation while adapting to PowerDynamics/ModelingToolkit conventions.\n\nValidation\n\nValidated against the OpenIPSL SMIB testcase Tests.Controls.PSSE.PSS.IEEEST. See validation plot generated by automatic validation script in /test/OpenIPSL_test.\n\n\n\n\n\n","category":"constant"},{"location":"Library/#Load-Models","page":"Component Library","title":"Load Models","text":"","category":"section"},{"location":"Library/#Static-Load-Models","page":"Component Library","title":"Static Load Models","text":"","category":"section"},{"location":"Library/#Line-Models","page":"Component Library","title":"Line Models","text":"","category":"section"},{"location":"Library/#Transmission-Line-Models","page":"Component Library","title":"Transmission Line Models","text":"","category":"section"},{"location":"Library/#Fault-Models","page":"Component Library","title":"Fault Models","text":"","category":"section"},{"location":"Library/#Ground-Fault-Models","page":"Component Library","title":"Ground Fault Models","text":"","category":"section"},{"location":"generated/ieee39_part3/#ieee39-part3","page":"IEEE39 Part III: Simulation","title":"IEEE39 Bus Tutorial - Part III: Dynamic Simulation","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"This tutorial can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"This is the third part of the IEEE 39-bus tutorial series:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Part I: Model Creation - Build the network structure with buses, lines, and components\nPart II: Initialization - Perform power flow calculations and dynamic initialization\nPart III: Dynamic Simulation (this tutorial) - Run time-domain simulations and analyze system behavior\nPart IV: Advanced Modeling & Parameter Optimization - Create custom components and optimize system parameters","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"In this tutorial, we'll demonstrate how to perform dynamic simulations of power system disturbances using PowerDynamics.jl. We'll simulate a short circuit fault followed by line disconnection and analyze the system's dynamic response.","category":"page"},{"location":"generated/ieee39_part3/#Short-Circuit-Disturbance-Scenario","page":"IEEE39 Part III: Simulation","title":"Short Circuit Disturbance Scenario","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"We will simulate a three-phase short circuit fault on a transmission line, which is a common and severe disturbance in power systems. The disturbance scenario consists of:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"t = 0.1s: A short circuit occurs on line 11, drastically reducing its impedance\nt = 0.2s: The protective relay trips the line, completely disconnecting it from the system\nt = 0.2s onwards: The system operates with the line permanently out of service","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"This scenario tests the system's ability to:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Survive the initial fault (maintain synchronism)\nStabilize after the line disconnection\nOperate reliably with reduced transmission capacity","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"# Loading required packages and setup\nusing PowerDynamics\nusing PowerDynamics.Library\nusing ModelingToolkit\nusing NetworkDynamics\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\n\n# Load the network model from Part I\nEXAMPLEDIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\")\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part1.jl\"))","category":"page"},{"location":"generated/ieee39_part3/#Network-Initialization","page":"IEEE39 Part III: Simulation","title":"Network Initialization","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Before we can run dynamic simulations, we need to initialize the network as described in Part II. This involves solving the power flow and initializing all dynamic components.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"For buses with both generators and loads (buses 31 and 39), we need to add initialization formulas to resolve structural underconstraints by setting the load voltage setpoint equal to the bus voltage magnitude.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"# Add initialization formulas as described in Part II\nformula = @initformula :ZIPLoad₊Vset = sqrt(:busbar₊u_r^2 + :busbar₊u_i^2)\nset_initformula!(nw[VIndex(31)], formula)\nset_initformula!(nw[VIndex(39)], formula)\n\n# Initialize the complete network from power flow solution\ns0 = initialize_from_pf!(nw; verbose=false)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part3/#Short-Circuit-Disturbance-Definition","page":"IEEE39 Part III: Simulation","title":"Short Circuit Disturbance Definition","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"To simulate realistic power system dynamics, we need to introduce a disturbance that will excite the system's dynamic behavior. We'll simulate a short circuit fault on transmission line 11, which connects buses 5 and 8.","category":"page"},{"location":"generated/ieee39_part3/#Understanding-Line-Models-with-Fault-Capability","page":"IEEE39 Part III: Simulation","title":"Understanding Line Models with Fault Capability","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The transmission line models in our network include built-in parameters for fault simulation:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"pibranch₊shortcircuit: When set to 1, this simulates a three-phase to ground short circuit along the line. The position in percentage can be given as a parameter too.\npibranch₊active: When set to 0, this completely disconnects the line from the network (no current flowing into line or out of line, i.e., the line is disconnected at both ends)","category":"page"},{"location":"generated/ieee39_part3/#Callback-Functions-for-Disturbance-Events","page":"IEEE39 Part III: Simulation","title":"Callback Functions for Disturbance Events","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"In order to simulate discrete perturbations, such as enabling a short circuit or disabling a line, we need to use callbacks. Callbacks are a neat feature of DifferentialEquations.jl, which allow you to stop the solver under certain conditions and trigger a user-defined affect function to change the state of the system.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"NetworkDynamics inherits this functionality as well. In addition, ND.jl provides a new type of callback: component callbacks. Those are callbacks which are attached to a single component rather than the full network, bringing the effect handling to the component level.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Here we'll define two component callbacks: one to enable a short circuit at a given time and one to disable the line at a given time.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"# Select the line to be affected by the short circuit\nAFFECTED_LINE = 11\nnothing #hide","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Let's examine the transmission line that will experience the short circuit. This line connects two important buses in the network and its outage will test the system's stability.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Now we define callback functions to model the disturbance sequence:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"# Define callback to enable short circuit at t=0.1s\nVERBOSE_CALLBACK = true #hide\n_enable_short = ComponentAffect([], [:piline₊shortcircuit]) do u, p, ctx\n    if VERBOSE_CALLBACK #hide\n    @info \"Short circuit activated on line $(ctx.src)→$(ctx.dst) at t = $(ctx.t)s\"\n    end #hide\n    p[:piline₊shortcircuit] = 1\nend\nshortcircuit_cb = PresetTimeComponentCallback(0.1, _enable_short)\n\n# Define callback to disconnect line at t=0.2s (fault clearing)\n_disable_line = ComponentAffect([], [:piline₊active]) do u, p, ctx\n    if VERBOSE_CALLBACK #hide\n    @info \"Line $(ctx.src)→$(ctx.dst) disconnected at t = $(ctx.t)s\"\n    end #hide\n    p[:piline₊active] = 0\nend\ndeactivate_cb = PresetTimeComponentCallback(0.2, _disable_line)\n\n# Attach both callbacks to the selected line\nset_callback!(nw, EIndex(AFFECTED_LINE), (shortcircuit_cb, deactivate_cb))\nnothing #hide","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The callbacks are now attached to line 11. During simulation:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"At t=0.1s, the short circuit callback activates, simulating the fault\nAt t=0.2s, the line disconnection callback activates, simulating relay action","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Let's verify the callbacks are properly attached:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"nw[EIndex(AFFECTED_LINE)]","category":"page"},{"location":"generated/ieee39_part3/#Dynamic-Simulation","page":"IEEE39 Part III: Simulation","title":"Dynamic Simulation","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Now we're ready to perform the dynamic simulation. We'll set up and solve an ordinary differential equation (ODE) problem that represents the network's dynamic behavior.","category":"page"},{"location":"generated/ieee39_part3/#Simulation-Setup","page":"IEEE39 Part III: Simulation","title":"Simulation Setup","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The simulation process involves:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Creating the initial state vector from our initialized network\nSetting up the ODE problem with appropriate time span and callbacks\nSolving the ODE using a suitable numerical method\nAnalyzing the results","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Note that we use get_callbacks to collect the component callbacks, transform them into a CallbackSet compatible with the DifferentialEquations.jl ecosystem and pass them to the ODEProblem.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"u0 = NWState(nw) # state is stored in metadata because of mutating init function!\nprob = ODEProblem(nw, uflat(u0), (0.0, 15.0), copy(pflat(u0)); callback=get_callbacks(nw))\n# Solve the ODE using Rodas5P (suitable for stiff differential-algebraic systems)\nsol = solve(prob, Rodas5P());\n@assert SciMLBase.successful_retcode(sol) # ensure the simulation was successful","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The simulation is complete! The sol object contains the time-domain solution of all network variables. We can now analyze how the system responded to the short circuit disturbance.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"tip: Tip\nThe ODEProblem contains a reference to exactly one copy of the flat parameter array. If you use callbacks to change those parameters (as we do), it is advised to copy the parameter array before passing it to the ODEProblem! Otherwise the callback will change our u0 object. Also, this means you need to be careful when using the same prob for multiple subsequent solve calls, as the initial state of the prob object might have changed!","category":"page"},{"location":"generated/ieee39_part3/#Simulation-Results-Overview","page":"IEEE39 Part III: Simulation","title":"Simulation Results Overview","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The solution object contains:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Time-domain trajectories of all state variables (generator angles, voltages, etc.)\nNetwork interface variables (bus voltages, line currents and power flows)\nFull system response from t=0 to t=15 seconds","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Let's examine some key aspects of the system response through various plots.","category":"page"},{"location":"generated/ieee39_part3/#Results-Analysis","page":"IEEE39 Part III: Simulation","title":"Results Analysis","text":"","category":"section"},{"location":"generated/ieee39_part3/#Power-Flow-in-the-Affected-Line","page":"IEEE39 Part III: Simulation","title":"Power Flow in the Affected Line","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"First, let's examine how the power flow through the faulted line changes during the disturbance. This plot shows the most direct impact of our short circuit and line disconnection events.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"let fig = Figure(; size=(800, 400))\n    ax = Axis(fig[1, 1];\n        title=\"Active Power Flow in Line $AFFECTED_LINE During Short Circuit\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Active Power [pu]\")\n\n    # Focus on the disturbance period to see the fault clearly\n    ts = range(0, 0.35, length=1000)\n\n    # Plot power flow at the destination end of the line\n    lines!(ax, ts, sol(ts; idxs=EIndex(AFFECTED_LINE, :src₊P)).u;\n           label=\"Active Power towards src\", linewidth=2)\n    lines!(ax, ts, sol(ts; idxs=EIndex(AFFECTED_LINE, :dst₊P)).u;\n           label=\"Active Power towards dst\", linewidth=2)\n\n    axislegend(ax; position=:rt)\n\n    fig\nend","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Observations:","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Normal operation (t < 0.1s): Steady power flow through the line. Power towards destination is positive while power towards source is negative. This means we have net transmission from bus 5 to bus 8.\nShort circuit (0.1s < t < 0.2s): Dramatic power flow change due to the short circuit. Both source and destination show negative power, which means we have active power flowing from both sides towards the short circuit.\nLine disconnection (t > 0.2s): Zero power flow as the line is permanently out of service","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The power absorption during the fault demonstrates the severe electrical stress that short circuits place on the system. The protective relay action at t=0.2s successfully isolates the fault.","category":"page"},{"location":"generated/ieee39_part3/#Voltage-Response-at-Adjacent-Buses","page":"IEEE39 Part III: Simulation","title":"Voltage Response at Adjacent Buses","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Next, let's examine how the buses directly connected to the faulted line respond to the disturbance. These buses experience the most severe voltage impacts during the fault.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"let fig = Figure(; size=(800, 500))\n    ax = Axis(fig[1, 1];\n        title=\"Voltage Magnitudes at Buses Adjacent to Faulted Line\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Voltage Magnitude [pu]\")\n\n    # Full simulation time to see both disturbance and recovery\n    ts = range(0, 15, length=1000)\n\n    # Get the source and destination buses of the affected line\n    src_bus, dst_bus = get_graphelement(nw[EIndex(AFFECTED_LINE)])\n\n    # Plot voltage magnitudes at both ends of the faulted line\n    lines!(ax, ts, sol(ts; idxs=VIndex(src_bus, :busbar₊u_mag)).u;\n           label=\"Bus $src_bus (source)\", linewidth=2)\n    lines!(ax, ts, sol(ts; idxs=VIndex(dst_bus, :busbar₊u_mag)).u;\n           label=\"Bus $dst_bus (destination)\", linewidth=2)\n\n    axislegend(ax; position=:rb)\n    ylims!(ax, 0.85, 1.15)\n\n    fig\nend","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Observations: Both buses experience voltage depression during the short circuit but are able to recover after the short circuit is cleared by disconnection of the line.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"The voltage recovery demonstrates the system's ability to adapt to the new network topology after the line outage. The generators' automatic voltage regulators help maintain voltage stability.","category":"page"},{"location":"generated/ieee39_part3/#System-Wide-Voltage-Response","page":"IEEE39 Part III: Simulation","title":"System-Wide Voltage Response","text":"","category":"section"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"To get a complete picture of the system's response, let's examine the voltage profiles across all 39 buses. This \"spaghetti plot\" shows how the disturbance propagates through the entire network.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"let fig = Figure(; size=(800, 600))\n    ax = Axis(fig[1, 1];\n        title=\"Voltage Magnitudes Across All 39 Buses\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Voltage Magnitude [pu]\")\n\n    # Full simulation time range\n    ts = range(0, 15, length=1000)\n\n    # Plot voltage magnitude for all buses\n    for i in 1:39\n        voltage_data = sol(ts; idxs=VIndex(i, :busbar₊u_mag)).u\n        lines!(ax, ts, voltage_data; linewidth=2)\n    end\n    ylims!(ax, 0.85, 1.15)\n    fig\nend","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"Once again, we see how all bus voltages are affected by the short circuit and the overall voltage drops. However, after the fault is cleared, the system achieves a synchronous steady-state again.","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"","category":"page"},{"location":"generated/ieee39_part3/","page":"IEEE39 Part III: Simulation","title":"IEEE39 Part III: Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"initialization/#Powergrid-Initialization","page":"Initialization","title":"Powergrid Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Initialization of power grid simulations follows a multi-step approach that combines steady-state power flow analysis with dynamic component initialization. PowerDynamics.jl provides a structured framework for this process, building on the initialization capabilities of NetworkDynamics.jl.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"For general background on NetworkDynamics initialization concepts, see the NetworkDynamics Initialization Guide.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This document is a technical description of the process, for a hands-on example which goes through the initialization process of a full network check out the Part II of the  the IEEE39 Bus Example.","category":"page"},{"location":"initialization/#Overview","page":"Initialization","title":"Overview","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Power grid initialization involves finding valid initial conditions that satisfy both:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Power flow constraints: Electrical power balance equations (steady-state)\nDynamic constraints: Initial conditions for dynamic components (generators, controllers, etc.)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This is typically achieved through a two-step process:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Solve the power flow problem to determine steady-state electrical conditions\nInitialize dynamic components using the power flow solution as boundary conditions, i.e. find the initial states/parameters of the dynamical models in a way, that they are in a steady state at the powerflow solution.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This follows the Two-Step Initialization Pattern described in NetworkDynamics.jl, specialized for power grid applications.","category":"page"},{"location":"initialization/#Multi-Step-Initialization-Process","page":"Initialization","title":"Multi-Step Initialization Process","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"nw = get_dynamic_network(...)\n\n# extract powerflow model       # ⎫                 ⎫\npfnw = powerflow_model(nw)      # │                 │\n# initial guess for powerflow   # ⎬ solve_powerflow │\npfs0 = NWState(pfnw)            # │                 │\n# find fixpoint for pf model    # │                 │\npfs = find_fixpoint(pfnw, pfs0) # ⎭                 ⎬ initialize_from_pf[!]\n# extract interface (u/i values)#                   │\ninterf = interface_values(pfs)  #                   │\n# initialize around powerflow   #                   │\ninitialize_componentwise[!](    #                   │\n    nw;                         #                   │\n    default_overrides = interf  #                   │\n)                               #                   ⎭","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This low-level step-wise interface allows users full control and complete management of the initialization process. However, PowerDynamics.jl also provides higher-level wrapper functions solve_powerflow and initialize_from_pf that combine these steps for common use cases.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Note: This workflow above is slightly simplified, see Integration with Initialization Process below for the full set of commands.","category":"page"},{"location":"initialization/#Step-1:-Power-Flow-Model-Extraction","page":"Initialization","title":"Step 1: Power Flow Model Extraction","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The first step creates a simplified, algebraic representation of the power grid that captures the essential power flow relationships:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"pfnw = powerflow_model(nw)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This function extracts the power flow network from the full dynamic network model, creating a steady-state representation. The power flow network itself is also a Network in the NetworkDynamics.jl sense.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The powerflow_model function determines the appropriate power flow representation for each dynamic Node and LineModel by: checking if :pfmodel metadata is set, which points to a different component model specifically designed for power flow analysis","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"If the :pfmodel is not set, it assumes that the same model is used for both power flow and dynamic simulation. This is the case for purely static models such as PiLines or PQ-Loads.","category":"page"},{"location":"initialization/#Step-2:-Power-Flow-Solution","page":"Initialization","title":"Step 2: Power Flow Solution","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The power flow problem is solved using NetworkDynamics.jl's find_fixpoint function, which internally uses NonlinearSolve.jl:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"pfs0 = NWState(pfnw)            # Initial guess for power flow state\npfs = find_fixpoint(pfnw, pfs0) # Solve power flow equations","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This step finds the steady-state solution where:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Active and reactive power are balanced at each bus\nGeneration and load are in equilibrium","category":"page"},{"location":"initialization/#Step-3:-Interface-Value-Extraction","page":"Initialization","title":"Step 3: Interface Value Extraction","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The power flow solution provides boundary conditions for dynamic component initialization:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"interf = interface_values(pfs)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This extracts voltage magnitudes, voltage angles, and current flows at each network node, which serve as interface constraints for the dynamic components.","category":"page"},{"location":"initialization/#Step-4:-Component-wise-Dynamic-Initialization","page":"Initialization","title":"Step 4: Component-wise Dynamic Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Finally, each dynamic component is initialized individually using the power flow solution as boundary conditions:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"initialize_componentwise!(nw; default_overrides = interf)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This step leverages NetworkDynamics.jl's component-wise initialization to determine free internal states and parameters (such as rotor angles or controller setpoints), such that the steady state of the overall network matches the flows from the power flow solution (i.e. all currents and voltages match).","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"For details on how component initialization works, see the Single Component Initialization section in NetworkDynamics.jl.","category":"page"},{"location":"initialization/#Advanced-Component-Initialization","page":"Initialization","title":"Advanced Component Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"In some cases, the standard initialization process may not be sufficient. For example, when component initialization constraints cannot be expressed solely in terms of interface variables (voltages and currents), but need access to other variables from the complete power flow solution.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"NetworkDynamics.jl provides general InitFormulas and InitConstraints for advanced component initialization. PowerDynamics.jl extends these concepts with power flow-aware variants that can access the complete power flow solution.","category":"page"},{"location":"initialization/#PFInitConstraints-vs-PFInitFormulas","page":"Initialization","title":"PFInitConstraints vs PFInitFormulas","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Method Purpose Usage\nPFInitConstraint Add constraint equations that must be satisfied When you need to enforce specific relationships between variables\nPFInitFormula Set default initial values directly When you need to initialize variables based on power flow results","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Both methods can access any variable from the solved power flow state, not just interface variables. You get access to states, parameters and observables from the power flow model of the same component.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Key difference: Constraints increase the number of equations that must be satisfied during initialization, while formulas reduce the number of free variables by setting additional default values.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"These are power flow-aware extensions of NetworkDynamics.jl's standard InitConstraint and InitFormula mechanisms.","category":"page"},{"location":"initialization/#Power-Flow-Dependent-Initialization-Constraints","page":"Initialization","title":"Power Flow Dependent Initialization Constraints","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"PFInitConstraint adds constraint equations to the initialization problem. Unlike regular InitConstraints from NetworkDynamics.jl, PFInitConstraints can access power flow variables.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The @pfinitconstraint macro provides convenient syntax for defining these constraints:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"# Single constraint accessing both component and power flow variables\nconstraint = @pfinitconstraint :dynamicload₊P - @pf(:PQ₊Pset)\n\n# Multiple constraints in a single block\nconstraints = @pfinitconstraint begin\n    :pibranch₊X - @pf(:pibranch₊X) # \"copy\" parameters from pf\n    :P_gen - @pf(:P_load)          # Power balance constraint\n    :AVR₊Vset - :busbar₊u_mag      # init controller setpoints\nend\n\n# Attach to a component\nset_pfinitconstraint!(my_generator, constraints)","category":"page"},{"location":"initialization/#Power-Flow-Dependent-Initialization-Formulas","page":"Initialization","title":"Power Flow Dependent Initialization Formulas","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"PFInitFormula sets default initial values for variables using both component and power flow variables. Unlike constraints, formulas directly assign values without adding equations to solve.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The @pfinitformula macro provides convenient syntax:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"# Single formula - set variable from component variables\n@pfinitformula :Vset = sqrt(:u_r^2 + :u_i^2)\n\n# Formula using power flow variables\n@pfinitformula :Pset = @pf(:generator_power)\n\n# Multiple formulas in a block\n@pfinitformula begin\n    :Vset = sqrt(:u_r^2 + :u_i^2)\n    :Pset = @pf(:generator_power)\nend\n\n# Attach to a component\nset_pfinitformula!(my_generator, formulas)","category":"page"},{"location":"initialization/#Integration-with-Initialization-Process","page":"Initialization","title":"Integration with Initialization Process","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Both PFInitConstraints and PFInitFormulas are automatically handled during initialize_from_pf[!]:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Power flow solution: The power flow equations are solved first\nSpecialization: All PFInitConstraints and PFInitFormulas are converted to regular InitConstraints and InitFormulas by \"specializing\" them with the power flow solution (i.e. the @pf(:x) blocks are replaced by the actual values)\nComponent initialization: The specialized constraints and formulas are passed to NetworkDynamics.jl's component initialization","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This process is transparent to the user - simply define your power flow dependent initialization methods and use initialize_from_pf[!] as usual.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The underlying mechanism follows NetworkDynamics.jl's component initialization pipeline, with the power flow solution providing additional context for constraint and formula evaluation.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The extended initialization workflow (automatically done in initialize_from_pf[!]) looks like this:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"nw = get_dynamic_network(...)\npfnw = powerflow_model(nw)\npfs0 = NWState(pfnw)\npfs = find_fixpoint(pfnw, pfs0)\ninterf = interface_values(pfs)\n\n# specialize the constraints and formulas and pass them down\npfconstraints = specialize_pfinitconstraints(nw, pfs)\npfformulas    = specialize_pfinitformulas(nw, pfs)\ninitialize_componentwise[!](\n    nw;\n    default_overrides = interf,\n    additional_initconstraints = pfconstraints,\n    additional_initformulas = pfformulas,\n)","category":"page"},{"location":"generated/ieee39_part4/#ieee39-part4","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Bus Tutorial - Part IV: Advanced Modeling & Parameter Optimization","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"This tutorial can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"This is the fourth and final part of the IEEE 39-bus tutorial series:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Part I: Model Creation - Build the network structure with buses, lines, and components\nPart II: Initialization - Perform power flow calculations and dynamic initialization\nPart III: Dynamic Simulation - Run time-domain simulations and analyze system behavior\nPart IV: Advanced Modeling & Parameter Optimization (this tutorial) - Create custom components and optimize system parameters","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"In this tutorial, we'll demonstrate advanced PowerDynamics.jl capabilities by:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Creating a custom droop-controlled inverter component\nIntegrating it into the IEEE 39-bus system\nOptimizing its parameters to improve system performance","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"This tutorial showcases custom component creation and the integration with Julia's optimization ecosystem for parameter tuning.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"note: Note\nThis tutorial is designed as a pedagogical example. It does not necessarily represent a realistic power system model and analysis, but rather serves to demonstrate the available tools while remaining relatively simple and concise.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"# Loading required packages and setup\nusing PowerDynamics\nusing PowerDynamics.Library\nusing ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\nusing NetworkDynamics\nusing NetworkDynamics: SII\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing SciMLSensitivity\nusing Optimization\nusing OptimizationOptimisers\nusing CairoMakie\nusing LinearAlgebra\nusing Graphs\nusing SparseConnectivityTracer\nusing Sparspak\n\n# Load the network models from previous parts\nEXAMPLEDIR = joinpath(pkgdir(PowerDynamics), \"docs\", \"examples\")\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part1.jl\"))  # Creates the basic network model\ninclude(joinpath(EXAMPLEDIR, \"ieee39_part3.jl\"))  # Provides initialized network and reference solution\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/#Integration-of-a-Droop-Controlled-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Integration of a Droop-Controlled Inverter","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"In this section, we'll modify our network by adding a droop-controlled inverter.","category":"page"},{"location":"generated/ieee39_part4/#Mathematical-Background","page":"IEEE39 Part IV: Parameter Tuning","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"The droop-controlled inverter implements a decentralized control strategy commonly used in microgrids and renewable energy integration. It establishes the following relationships:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Power Measurement:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"beginaligned\nP_meas = u_r cdot i_r + u_i cdot i_i\nQ_meas = u_i cdot i_r - u_r cdot i_i\nendaligned","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Power Filtering (Low-pass filtering for measurement noise reduction):","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"beginaligned\ntau cdot fracdP_filtdt = P_meas - P_filt \ntau cdot fracdQ_filtdt = Q_meas - Q_filt\nendaligned","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Droop Control:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"beginaligned\nomega = omega_0 - K_p cdot (P_filt - P_set) \nV = V_set - K_q cdot (Q_filt - Q_set)\nendaligned","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Voltage Angle Dynamics:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"fracddeltadt = omega - omega_0","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Output Voltage:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"beginaligned\nu_r = V cdot cos(delta) \nu_i = V cdot sin(delta)\nendaligned","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"These equations implement:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Frequency-Active Power Coupling (f-P): Frequency decreases when active power exceeds setpoint\nVoltage-Reactive Power Coupling (V-Q): Voltage decreases when reactive power exceeds setpoint","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"This mimics the natural behavior of synchronous generators and enables stable power sharing in islanded operation.","category":"page"},{"location":"generated/ieee39_part4/#Definition-of-the-Droop-Inverter-Component","page":"IEEE39 Part IV: Parameter Tuning","title":"Definition of the Droop Inverter Component","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Network components in PowerDynamics must follow the Injector Interface - they connect to the network through a single Terminal:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"      ┌──────────────────────────┐\n(t)   │                          │\n o←───┤ Droop Inverter Equations │\n      │                          │\n      └──────────────────────────┘","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We can define the following MTKModel to represent the droop inverter:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"@mtkmodel DroopInverter begin\n    @components begin\n        terminal = Terminal()\n    end\n\n    @parameters begin\n        Pset, [description=\"Active power setpoint\", guess=1]\n        Qset, [description=\"Reactive power setpoint\", guess=0]\n        Vset, [description=\"Voltage magnitude setpoint\", guess=1]\n        ω₀=1, [description=\"Nominal frequency\"]\n        Kp=1, [description=\"Active power droop coefficient\"]\n        Kq=0.1, [description=\"Reactive power droop coefficient\"]\n        τ_p = 1, [description=\"Active Power filter time constant\"]\n        τ_q = 1, [description=\"Reactive Power filter time constant\"]\n    end\n\n    @variables begin\n        Pmeas(t), [description=\"Measured active power\", guess=1]\n        Qmeas(t), [description=\"Measured reactive power\", guess=0]\n        Pfilt(t), [description=\"Filtered active power\", guess=1]\n        Qfilt(t), [description=\"Filtered reactive power\", guess=1]\n        ω(t), [description=\"Frequency\"]\n        δ(t), [description=\"Voltage angle\", guess=0]\n        V(t), [description=\"Voltage magnitude\"]\n    end\n\n    @equations begin\n        # Power measurement from terminal quantities\n        Pmeas ~ terminal.u_r*terminal.i_r + terminal.u_i*terminal.i_i\n        Qmeas ~ terminal.u_i*terminal.i_r - terminal.u_r*terminal.i_i\n\n        # First-order low-pass filtering\n        τ_p * Dt(Pfilt) ~ Pmeas - Pfilt\n        τ_q * Dt(Qfilt) ~ Qmeas - Qfilt\n\n        # Droop control equations\n        ω ~ ω₀ - Kp * (Pfilt - Pset)  # Frequency decreases with excess power\n        V ~ Vset - Kq * (Qfilt - Qset)  # Voltage decreases with excess reactive power\n\n        # Voltage angle dynamics\n        Dt(δ) ~ ω - ω₀\n\n        # Output voltage components\n        terminal.u_r ~ V*cos(δ)\n        terminal.u_i ~ V*sin(δ)\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/#Creating-a-Bus-with-the-Droop-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Creating a Bus with the Droop Inverter","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Following the descriptions in Modeling Concepts, we build an MTKBus using the droop as the single injector and then compile the bus model, similar to how we define the templates in part I:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"           ╔═════════════════════════╗\n           ║ Droop (compiled)        ║\n Network   ║  ┌────────────────────┐ ║\ninterface  ║  │ MTKBus             │ ║\n current ────→│┌──────┐ ┌────────┐ │ ║\n           ║  ││BusBar├o┤Inverter│ │ ║\n voltage ←────│└──────┘ └────────┘ │ ║\n           ║  └────────────────────┘ ║\n           ╚═════════════════════════╝","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"@named inverter = DroopInverter()\nmtkbus = MTKBus(inverter)\ndroop_bus_template = compile_bus(mtkbus; name=:DroopInverter)","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We see that the droop inverter has 3 free parameters (you can check free_p(droop_bus_template) or dump_initial_state(droop_bus_template)). Therefore, similar to what we did in Part II, we need to help the initialization by attaching an additional initialization formula to the bus:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"set_initformula!(\n    droop_bus_template,\n    @initformula(:inverter₊Vset = sqrt(:busbar₊u_r^2 + :busbar₊u_i^2))\n)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/#Network-Modification-with-Droop-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Network Modification with Droop Inverter","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We'll replace bus 32 (originally a controlled generator bus) with our new droop inverter bus.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"DROOP_BUS_IDX = 32\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"To do so, we first collect all the \"old\" vertex and edge models.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"tip: Tip\nWe copy the components, to create individual instances for the new network. Since all the metadata (like the default values, initialize values and so on) are stored in the component models, we would otherwise share metadata between the old and the new network, which can lead to unexpected results.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"vertex_models = [copy(nw[VIndex(i)]) for i in 1:nv(nw)];\nedge_models = [copy(nw[EIndex(i)]) for i in 1:ne(nw)];\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Now we need to replace the original bus model at index DROOP_BUS_IDX with our new droop inverter bus. However, we don't want to lose the original power flow model associated with this bus, so we need to attach it to the droop bus model:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"original_pfmodel = get_pfmodel(vertex_models[DROOP_BUS_IDX])\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We can then use the Bus constructor to essentially copy the droopbustemplate and adjust some properties, like the powerflow model and the vertex index.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"droop_bus = compile_bus(droop_bus_template; pf=original_pfmodel, vidx=DROOP_BUS_IDX)","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We then replace the original bus model in the array with our droop bus and build a network again:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"vertex_models[DROOP_BUS_IDX] = droop_bus\nnw_droop = Network(vertex_models, edge_models)\nset_jac_prototype!(nw_droop; remove_conditions=true)","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Additionally, we've set the jacobian prototype for performance gains during simulation and optimization, see NetworkDynamics docs on Sparsity Detection.","category":"page"},{"location":"generated/ieee39_part4/#Network-Initialization-with-Droop-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Network Initialization with Droop Inverter","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"The modified network requires the same initialization steps as the original:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Power flow solution\nDynamic component initialization","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"This all happens within initialize_from_pf!:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"s0_droop = initialize_from_pf!(nw_droop; verbose=false)\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Let's examine the initialized state of our droop inverter:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"dump_initial_state(nw_droop[VIndex(DROOP_BUS_IDX)]; obs=false)","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We see that the filtered powers match the setpoints (steady state), and both P and V_mathrmset are initialized according to the parameters of the PV powerflow model.","category":"page"},{"location":"generated/ieee39_part4/#Simulation-with-Droop-Inverter","page":"IEEE39 Part IV: Parameter Tuning","title":"Simulation with Droop Inverter","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Now we'll simulate the modified network and compare it with the original system response:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"prob_droop = ODEProblem(nw_droop, uflat(s0_droop), (0.0, 15.0), copy(pflat(s0_droop));\n                       callback=get_callbacks(nw_droop))\nsol_droop = solve(prob_droop, Rodas5P())\n@assert SciMLBase.successful_retcode(sol_droop)","category":"page"},{"location":"generated/ieee39_part4/#Comparison-of-System-Responses","page":"IEEE39 Part IV: Parameter Tuning","title":"Comparison of System Responses","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Let's compare how the droop inverter affects the system's response to the short circuit disturbance:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"let fig = Figure(; size=(1000, 600))\n    selected_buses = [3, 4, 25, DROOP_BUS_IDX]  # Representative buses including the droop bus\n    ts = range(0, 10, length=1000)\n\n    for (i, bus) in enumerate(selected_buses)\n        row, col = divrem(i-1, 2) .+ (1, 1)\n        ax = Axis(fig[row, col];\n                  title=\"Voltage Magnitude at Bus $bus\" * (bus==DROOP_BUS_IDX ? \" (droop bus)\" : \"\"),\n                  xlabel=\"Time [s]\",\n                  ylabel=\"Voltage [pu]\")\n\n        # Original system response\n        lines!(ax, ts, sol(ts; idxs=VIndex(bus, :busbar₊u_mag)).u;\n               label=\"Original System\", color=:blue, linewidth=2)\n\n        # Droop inverter system response\n        lines!(ax, ts, sol_droop(ts; idxs=VIndex(bus, :busbar₊u_mag)).u;\n               label=\"With Droop Inverter\", color=:red, linewidth=2)\n\n        ylims!(ax, 0.85, 1.15)\n        i == 1 && axislegend(ax; position=:rb)\n    end\n\n    fig\nend","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We see that the overall system reacts similarly but distinctly differently to the identical disturbance.","category":"page"},{"location":"generated/ieee39_part4/#Parameter-Optimization","page":"IEEE39 Part IV: Parameter Tuning","title":"Parameter Optimization","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"To showcase advanced capabilities of the SciML-ecosystem and the integration with PowerDynamics.jl, we now want to try to tune the droop inverter parameters so that the overall system behavior more closely resembles the original behavior, i.e., to reduce the difference between the system with generator and the system with droop inverter.","category":"page"},{"location":"generated/ieee39_part4/#Optimization-Problem-Formulation","page":"IEEE39 Part IV: Parameter Tuning","title":"Optimization Problem Formulation","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We define a loss function that measures the deviation between the original system response and the modified system response:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"L(p) = sum_it x_ref(t)_i - x(tp)_i^2","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Where we have","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Parameters p = K_p K_q tau to be optimized\nthe reference solution x_ref(t) (original system)\nthe solution of the modified system x(tp) with updated parameters p","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Goal: Find parameters p that minimize this loss function, making the droop inverter system behave as closely as possible to the original system.","category":"page"},{"location":"generated/ieee39_part4/#Setting-Up-the-Optimization","page":"IEEE39 Part IV: Parameter Tuning","title":"Setting Up the Optimization","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"First, we define the reference solution and identify the tunable parameters.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We probe the original solution at fixed timepoints, exporting u_r and u_i for every bus:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"opt_ref = sol(0.3:0.1:10, idxs=[VIndex(1:39, :busbar₊u_r), VIndex(1:39, :busbar₊u_i)])\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Next, we need to identify the \"tunable\" parameters. This is a bit tricky, because the overall nw_droop has 1271 parameters, so we need to find the indices of the parameters we want to tune in the flat parameter array. We can do so, by leveraging NetworkDynamics implementation of the SymbolicIndexingInterface: tunable_parameters = [:inverter₊Kp, :inverter₊Kq, :inverter₊τ]","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"tunable_parameters = [:inverter₊Kp, :inverter₊Kq, :inverter₊τ_p, :inverter₊τ_q]\ntp_idx = SII.parameter_index(sol_droop, VIndex(DROOP_BUS_IDX, tunable_parameters))","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We also get their initial values, which we use as the starting point for the optimization.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"p0 = sol_droop(sol_droop.t[begin], idxs=collect(VIndex(DROOP_BUS_IDX, tunable_parameters)))","category":"page"},{"location":"generated/ieee39_part4/#Loss-Function-Implementation","page":"IEEE39 Part IV: Parameter Tuning","title":"Loss Function Implementation","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"The loss function simulates the system with given parameters and compares the result to the reference:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"function loss(p)\n    # Create parameter vector for the full system\n    # allp = similar(p, pdim(nw_droop)) # create a vector of the full length\n    allp = similar(p, length(s0_droop.p)) # create a vector of the full length\n    allp .= pflat(s0_droop.p) # copy all \"initial\" parameters to that vector\n    allp[tp_idx] .= p  # Update only the tunable parameters with the parameters for the given optimization iteration\n\n    # Solve the system with new parameters\n    _sol = solve(prob_droop, Rodas5P(autodiff=true);\n        p = allp,\n        saveat = opt_ref.t,\n        tspan=(0.0, opt_ref.t[end]),\n        initializealg = SciMLBase.NoInit(),\n        abstol=0.01,\n        reltol=0.01\n    )\n\n    # Return infinite loss if simulation failed\n    if !SciMLBase.successful_retcode(_sol)\n        @warn \"Retcode $(_sol.retcode) indicates a failed simulation, returning Inf loss\"\n        return Inf\n    end\n\n    # Extract solution at reference time points\n    x = _sol(opt_ref.t; idxs=[VIndex(1:39, :busbar₊u_r), VIndex(1:39, :busbar₊u_i)])\n\n    # Compute L2 norm of the difference\n    res = opt_ref.u - x.u\n    l2loss = sum(abs2, reduce(vcat, res))\nend\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/#Optimization-Execution","page":"IEEE39 Part IV: Parameter Tuning","title":"Optimization Execution","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"We use the Optimization.jl ecosystem with the Adam optimizer:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"# Create optimization function with automatic differentiation\noptf = Optimization.OptimizationFunction((x, p) -> loss(x), Optimization.AutoForwardDiff())\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"To better monitor the optimization progress, we want to store the optimized parameters at every iteration of the optimizer. We can do so by defining a callback function for the optimizer:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"optimization_states = Any[] # global variable to store the optimization parameters at each step\ncallback = function (state, l)\n    push!(optimization_states, state)\n    println(\"Iteration $(state.iter): loss = $l\\t p = $(state.u)\")\n    return false  # Continue optimization\nend\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"That callback will snapshot the current parameter values at every step of the gradient descent.","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"With that, we can run the optimization:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"optprob = Optimization.OptimizationProblem(optf, p0; callback)\nVERBOSE_CALLBACK = false #hide\n\n@time optsol = Optimization.solve(optprob, Optimisers.Adam(0.06), maxiters = 50)\n\nprintln(\"\\nOptimization completed!\")\nprintln(\"Initial parameters: \", p0)\nprintln(\"Optimized parameters: \", optsol.u)\nprintln(\"Initial loss: \", loss(p0))\nprintln(\"Final loss: \", loss(optsol.u))\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/#Optimization-Results-Analysis","page":"IEEE39 Part IV: Parameter Tuning","title":"Optimization Results Analysis","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Let's visualize how the optimization improved the system behavior:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"function plot_optimization_comparison(p_initial, p_current)\n    fig = Figure(; size=(1200, 800))\n    selected_buses = [3, 4, 25, DROOP_BUS_IDX]\n    ts = range(0, 10, length=1000)\n\n    # Simulate with optimized parameters\n    allp_opt = @lift let\n        _p = copy(pflat(s0_droop))\n        _p[tp_idx] .= $p_current\n        _p\n    end\n    sol_opt = @lift solve(prob_droop, Rodas5P(); p=$allp_opt)\n\n\n    for (i, bus) in enumerate(selected_buses)\n        row, col = divrem(i-1, 2) .+ (1, 1)\n        ax = Axis(fig[row, col];\n                  title=\"Voltage Magnitude at Bus $bus\" * (bus==DROOP_BUS_IDX ? \" (droop bus)\" : \"\"),\n                  xlabel=\"Time [s]\",\n                  ylabel=\"Voltage [pu]\")\n\n        # Reference (original system)\n        lines!(ax, ts, sol(ts; idxs=VIndex(bus, :busbar₊u_mag)).u;\n               label=\"Reference\", linestyle=:solid, color=:blue, linewidth=2)\n\n        # Initial droop parameters\n        lines!(ax, ts, sol_droop(ts; idxs=VIndex(bus, :busbar₊u_mag)).u;\n               label=\"Initial Droop\", linestyle=:dash, color=:red, linewidth=2)\n\n        # Optimized droop parameters\n        dat = @lift $(sol_opt)(ts; idxs=VIndex(bus, :busbar₊u_mag)).u\n        lines!(ax, ts, dat; label=\"Optimized Droop\", color=:green, linewidth=2)\n\n        ylims!(ax, 0.85, 1.15)\n        i == 1 && axislegend(ax; position=:rb)\n    end\n\n    fig\nend\n\npobs = Observable(p0)\ncomparison_fig = plot_optimization_comparison(p0, pobs)\nrecord(comparison_fig, \"parameter_evolution.mp4\", optimization_states; framerate=10) do s\n    pobs[] = s.u\nend\nnothing #hide","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"(Image: timeseries evolution animation)","category":"page"},{"location":"generated/ieee39_part4/#Parameter-Evolution-During-Optimization","page":"IEEE39 Part IV: Parameter Tuning","title":"Parameter Evolution During Optimization","text":"","category":"section"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"Let's see how each parameter changed during the optimization process:","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"let fig = Figure(; size=(1000, 800))\n    param_names = [\"Kp\", \"Kq\", \"τ_p\", \"τ_q\"]\n    for (i, param_name) in enumerate(param_names)\n        row = (i-1) ÷ 2 + 1\n        col = (i-1) % 2 + 1\n        ax = Axis(fig[row, col];\n                  title=\"Parameter Evolution: $param_name\",\n                  xlabel=\"Iteration\",\n                  ylabel=\"Parameter Value\")\n\n        # Extract parameter values over iterations\n        param_values = [state.u[i] for state in optimization_states[1:end-1]]\n        iterations = [state.iter for state in optimization_states[1:end-1]]\n\n        scatterlines!(ax, iterations, param_values; linewidth=3, markersize=6, color=:blue)\n\n        # Mark initial and final values\n        hlines!(ax, [p0[i]]; linestyle=:dash, color=:gray, alpha=0.7)\n        text!(ax, 1, p0[i]; text=\"Initial: $(round(p0[i], digits=3))\",\n              fontsize=10, color=:gray)\n\n        lossax = Axis(fig[row, col],\n            yticklabelcolor=:black,\n            yaxisposition = :right,\n            ylabel=\"loss\", yscale=log10,\n            xgridvisible=false, ygridvisible=false\n        )\n        scatterlines!(\n            lossax,\n            iterations,\n            [loss(s.u) for s in optimization_states[1:end-1]],\n            color=:black, linewidth=1, markersize=3,\n        )\n    end\n    fig\nend","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"","category":"page"},{"location":"generated/ieee39_part4/","page":"IEEE39 Part IV: Parameter Tuning","title":"IEEE39 Part IV: Parameter Tuning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ModelingConcepts/#Modeling-Concepts","page":"Modeling Concepts","title":"Modeling Concepts","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"In general, PowerDynamics models power grids as a set of dynamical systems for both nodes and edges on a graph. Check out the Mathematical Model documentation of NetworkDynamics for the underlying concepts.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The simulation happens entirely in a synchronous dq-frame. Due to their conceptual similarity to complex phasors, variables in this global dq-frame are referenced by subscripts _r and _i (for real and imaginary). This helps distinguish the variables from local dq frames, e.g. a generator model might transform u_r and u_i into u_d and u_q.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Both edge and node models are so-called input-output-systems: the edges receive the voltage of adjacent nodes as an input, the nodes receive the currents on adjacent edges as an input. In general, this leads to the following structure of a bus/node model:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"beginaligned\nM_mathrm vfracmathrmdmathrmdtx_mathrm v = f_mathrm vleft(x_mathrm v sum_kbeginbmatrixi^k_r i^k_iendbmatrix p_mathrm v tright)\nbeginbmatrixu_r u_iendbmatrix = g_mathrm v(x_mathrm vp_mathrm v t)\nendaligned","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"where M_mathrm v is the (possibly singular) mass-matrix, x_mathrm v are the internal states and p_mathrm v are parameters. Function f_mathrm v describes the time evolution of the internal states while output equation g_mathrm v defines the output voltage. The input for the system is the sum of all inflowing currents from adjacent lines k. Note how vertices are modeled as one-port systems; i.e., they receive the accumulated current from all connected lines, they can't distinguish which line provides which current. For special cases, this limitation might be mitigated using External Inputs.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"note: Nodal dynamics include injectors\nAn important distinction between our modeling and the modeling in many other libraries is that we include the injector dynamics inside the node dynamics. I.e. if you have a bus with a load and a generator, the overall node dynamics will include both machine and load dynamics within their equations. The modularity and model reuse on the bus level is provided by ModelingToolkit.jl integration.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The edge model on the other hand looks like this:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"beginaligned\nM_mathrm efracmathrmdmathrmdtx_mathrm e = f_mathrm eleft(x_mathrm e beginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix beginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrixp_mathrme tright)\nbeginbmatrixi_r^mathrmsrci_i^mathrmsrcendbmatrix = g^mathrmsrc_mathrm eleft(x_mathrm e beginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix beginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrix p_mathrme tright)\nbeginbmatrixi_r^mathrmdsti_i^mathrmdstendbmatrix = g^mathrmdst_mathrm eleft(x_mathrm e beginbmatrix u_r^mathrmsrcu_i^mathrmsrcendbmatrix beginbmatrix u_r^mathrmdstu_i^mathrmdstendbmatrix p_mathrme tright)\nendaligned","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"There are a few notable differences compared to bus models: Edges are two-port systems, they have two distinct inputs and two distinct outputs. Namely, they receive the dq voltage from both source and destination end, and define the current for both ends separately. In very simple systems without losses, those output currents might be just antisymmetric, in general cases however the current on both ends can differ drastically.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"note: Note\nSource and destination end of a line are purely conventional. It has nothing to do with the actual flow direction. Per convention from Graphs.jl, edges in undirected graphs always go from vertex with lower index to vertex with higher index, i.e. 15 to 23 never 23 to 15.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The above descriptions are important to understand what's happening inside the package. However, since we use ModelingToolkit to define the individual models a lot of this complexity is hidden from the user. In the following, we'll go through the most important concepts when designing models using ModelingToolkit.","category":"page"},{"location":"ModelingConcepts/#Relationship-between-ModelingToolkit-and-NetworkDynamics","page":"Modeling Concepts","title":"Relationship between ModelingToolkit and NetworkDynamics","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A crucial part of using this library is understanding the relationship between ModelingToolkit models and NetworkDynamics.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"In a nutshell, ModelingToolkit models are symbolic models; i.e., they consist of symbolic equations which are not yet \"compiled\" for use as a numeric model. The modeling in MTK is very flexible and similar to the Modelica language. What we need in the end is models in the structure defined in the equations above. For that, we need the MTK models to have a specific structure. Then we can use the compile_bus and compile_line function to compile the MTK models and create EdgeModel and VertexModel objects from them. Those objects are not symbolic anymore but compiled numeric versions of the symbolically created systems.","category":"page"},{"location":"ModelingConcepts/#ModelingToolkit-Models","page":"Modeling Concepts","title":"ModelingToolkit Models","text":"","category":"section"},{"location":"ModelingConcepts/#Terminal","page":"Modeling Concepts","title":"Terminal","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The Terminal-Connector is an important building block for every model. It represents a connection point with constant voltage in dq-coordinates u_r and u_i and enforces the Kirchhoff constraints sum(i_r)=0 and sum(i_i)=0.","category":"page"},{"location":"ModelingConcepts/#Modeling-of-Buses","page":"Modeling Concepts","title":"Modeling of Buses","text":"","category":"section"},{"location":"ModelingConcepts/#Injector-Interface","page":"Modeling Concepts","title":"Model class Injector","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"An injector is a class of components with a single Terminal() (called :terminal). Examples for injectors might be Generators, Shunts, Loads.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"(t)   ┌──────────┐\n o←───┤ Injector │\n      └──────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The current for injectors is always in injector convention; i.e., positive currents flow out of the injector towards the terminal.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"note: Model classes\nModel \"classes\" are nothing formalized. In this document, a model class is just a description for some System from ModelingToolkit.jl, which satisfies certain requirements. For example, any System is considered an \"Injector\" if it contains a connector Terminal() called :terminal.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"You can check if a model satisfies the injector interface using the isinjectormodel function.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: definition of PQ load as injector\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\n@mtkmodel MyPQLoad begin\n    @components begin\n        terminal = Terminal()\n    end\n    @parameters begin\n        Pset, [description=\"Active Power demand\"]\n        Qset, [description=\"Reactive Power demand\"]\n    end\n    @variables begin\n        P(t), [description=\"Active Power\"]\n        Q(t), [description=\"Reactive Power\"]\n    end\n    @equations begin\n        P ~ terminal.u_r*terminal.i_r + terminal.u_i*terminal.i_i\n        Q ~ terminal.u_i*terminal.i_r - terminal.u_r*terminal.i_i\n        # if possible, it's better for the solver to explicitly provide algebraic equations for the current\n        terminal.i_r ~ (Pset*terminal.u_r + Qset*terminal.u_i)/(terminal.u_r^2 + terminal.u_i^2)\n        terminal.i_i ~ (Pset*terminal.u_i - Qset*terminal.u_r)/(terminal.u_r^2 + terminal.u_i^2)\n    end\nend\nMyPQLoad(name=:pqload) #hide\nnothing #hide","category":"page"},{"location":"ModelingConcepts/#MTKBus-Interface","page":"Modeling Concepts","title":"Model class MTKBus","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A MTKBus is a class of models, which are used to describe the dynamic behavior of a full bus in a power grid. Each MTKBus must contain a predefined model of type BusBar() (named :busbar). This busbar represents the connection point to the grid. Optionally, it may contain various injectors. If there are no injectors, the model just describes a junction bus; i.e., a bus that just satisfies the Kirchhoff constraint for the flows of connected lines.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":" ┌───────────────────────────────────┐\n │ MTKBus             ┌───────────┐  │\n │  ┌──────────┐   ┌──┤ Generator │  │\n │  │          │   │  └───────────┘  │\n │  │  BusBar  ├───o                 │\n │  │          │   │  ┌───────────┐  │\n │  └──────────┘   └──┤ Load      │  │\n │                    └───────────┘  │\n └───────────────────────────────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Sometimes it is not possible to connect all injectors directly but instead one needs or wants Branches between the busbar and injector terminal. As long as the :busbar is present at the toplevel, there are few limitations on the overall model complexity.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"For simple models (direct connections of a few injectors), it is possible to use the convenience method MTKBus(injectors...) to create the composite model based on provided injector models.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"You can check if a model satisfies the bus interface using the isbusmodel function.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: definition of a Bus containing a swing equation and a load\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\n@mtkmodel MyMTKBus begin\n    @components begin\n        busbar = BusBar()\n        swing = Swing()\n        load = PQLoad()\n    end\n    @equations begin\n        connect(busbar.terminal, swing.terminal)\n        connect(busbar.terminal, load.terminal)\n    end\nend\nMyMTKBus(name=:bus) #hide\nnothing #hideAlternatively, for that system you could have just calledmybus = MTKBus(Swing(;name=:swing), PQLoad(;name=:load))\nnothing #hideto get an instance of a model which is structurally equivalent to MyMTKBus.","category":"page"},{"location":"ModelingConcepts/#Line-Modeling","page":"Modeling Concepts","title":"Line Modeling","text":"","category":"section"},{"location":"ModelingConcepts/#Branch-Interface","page":"Modeling Concepts","title":"Model class Branch","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A branch is the two-port equivalent to an injector. It needs to have two Terminal()s, one is called :src, the other :dst.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Examples for branches are: PI-model branches, dynamic RL branches or transformers.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"(src) ┌──────────┐ (dst)\n  o←──┤  Branch  ├──→o\n      └──────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Both ends follow the injector interface; i.e., current leaving the device towards the terminals is always positive.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"You can check if a model satisfies the branch interface using the isbranchmodel function.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: algebraic R-line\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\n@mtkmodel MyRLine begin\n    @components begin\n        src = Terminal()\n        dst = Terminal()\n    end\n    @parameters begin\n        R=0, [description=\"Resistance\"]\n    end\n    @equations begin\n        dst.i_r ~ (dst.u_r - src.u_r)/R\n        dst.i_i ~ (dst.u_i - src.u_i)/R\n        src.i_r ~ -dst.i_r\n        src.i_i ~ -dst.i_i\n    end\nend\nMyRLine(name=:rline) #hide\nnothing #hide","category":"page"},{"location":"ModelingConcepts/#MTKLine-Interface","page":"Modeling Concepts","title":"Model class: MTKLine","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Similar to the MTKBus, a MTKLine is a model class which represents a transmission line in the network.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"It must contain two LineEnd() instances, one called :src, one called :dst.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":" ┌────────────────────────────────────────────────┐\n │ MTKLine          ┌──────────┐                  │\n │  ┌─────────┐  ┌──┤ Branch A ├──┐  ┌─────────┐  │\n │  │ LineEnd │  │  └──────────┘  │  │ LineEnd │  │\n │  │  :src   ├──o                o──┤  :dst   │  │\n │  │         │  │  ┌──────────┐  │  │         │  │\n │  └─────────┘  └──┤ Branch B ├──┘  └─────────┘  │\n │                  └──────────┘                  │\n └────────────────────────────────────────────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Simple line models, which consist only of valid Branch models, can be instantiated using the MTKLine(branches...) constructor.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"More complex models can be created manually. For example, you could define a dynamic multi-branch DC line model by chaining (possibly very complex and nested) source and destination inverter/rectifier models with one or many dc branches.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"┌───────────────────────────────────────────────────────────┐\n│ MTKLine                ┌──────────┐                       │\n│                       ┌┤ DC Br. A ├┐                      │\n│┌─────────┐ ┌─────────┐│└──────────┘│┌─────────┐┌─────────┐│\n││ LineEnd ├─┤ src inv ├o            o┤ dst inv ├┤ LineEnd ││\n│└─────────┘ └─────────┘│┌──────────┐│└─────────┘└─────────┘│\n│   :src                └┤ DC Br. B ├┘              :dst    │\n│                        └──────────┘                       │\n└───────────────────────────────────────────────────────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"You can check if a model satisfies the line interface using the islinemodel function.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: Transmission line with two pi-branches\nusing PowerDynamics, PowerDynamics.Library, ModelingToolkit\n@mtkmodel MyMTKLine begin\n    @components begin\n        src = LineEnd()\n        dst = LineEnd()\n        branch1 = PiLine()\n        branch2 = PiLine()\n    end\n    @equations begin\n        connect(src.terminal, branch1.src)\n        connect(src.terminal, branch2.src)\n        connect(dst.terminal, branch1.dst)\n        connect(dst.terminal, branch2.dst)\n    end\nend\nMyMTKLine(name=:mtkline) #hide\nnothing #hideAlternatively, an equivalent model with multiple valid branch models in parallel could be created and instantiated with the convenience constructorline = MTKLine(PiLine(;name=:branch1), PiLine(;name=:branch2))\nnothing #hide","category":"page"},{"location":"ModelingConcepts/#From-MTK-Models-to-NetworkDynamics","page":"Modeling Concepts","title":"From MTK Models to NetworkDynamics","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Both MTKLine and MTKBus are still purely symbolic ModelingToolkit models. However, they have an important property: they possess the correct input-output structure and variable names to be compiled into VertexModel and EdgeModel models. To do so, PowerDynamics.jl provides the compile_line and compile_bus functions.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"At their core, both compile_* functions use ModelingToolkit's mtkcompile to perform symbolic simplifications on your models and reduce the number of states. Most notably, this process can drastically reduce the number of equations, while all previously defined states remain \"observable\", i.e. inspectable after simulation. For example, in the above code example of the PQ load we defined equations for active and reactive powers P and Q. Those equations don't add anything to the actual behavior of the system, however they will be kept around as so-called \"observed\" states, meaning we can reconstruct and plot them from dynamical simulations.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"tip: Tip: Introduce states of interest as observables\nIt is often useful to add derived quantities of interest explicitly to your models. For example, if you're interested in some internal voltage angle just define an equation u_angle ~ atan(u_d, u_q). If nothing else depends on it, this equation will be symbolically reduced,  i.e. you don't add any overhead to your simulation but it will be accessible after the simulation.  This is often far more convenient than \"reconstructing\" such states manually!","category":"page"},{"location":"ModelingConcepts/#(MTK)-Bus-Model-to-VertexModel:-compile_bus","page":"Modeling Concepts","title":"(MTK) Bus Model to VertexModel: compile_bus","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"                                      ╔═════════════════════════╗\n                                      ║ VertexModel (compiled)  ║\n┌────────────────────┐      Network   ║  ┌────────────────────┐ ║\n│MTKBus   ┌─────────┐│     interface  ║  │MTKBus   ┌─────────┐│ ║\n│        ┌┤Generator││                ║  │        ┌┤Generator││ ║\n│┌──────┐│└─────────┘│      current ────→│┌──────┐│└─────────┘│ ║\n││BusBar├o           │  =>            ║  ││BusBar├o           │ ║\n│└──────┘│┌────┐     │      voltage ←────│└──────┘│┌────┐     │ ║\n│        └┤Load│     │                ║  │        └┤Load│     │ ║\n│         └────┘     │                ║  │         └────┘     │ ║\n└────────────────────┘                ║  └────────────────────┘ ║\n                                      ╚═════════════════════════╝","category":"page"},{"location":"ModelingConcepts/#(MTK)-Line-Model-to-EdgeModel:-compile_line","page":"Modeling Concepts","title":"(MTK) Line Model to EdgeModel: compile_line","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"\n                                        ╔══════════════════════════════╗\n                                        ║ EdgeModel (compiled)         ║\n┌─────────────────────────────┐     src ║ ┌──────────────────────────┐ ║ dst\n│MTKLine   ┌───────┐          │  vertex ║ │MTKLine   ┌────┐          │ ║ vertex\n│         ┌┤BranchA├┐         │         ║ │         ┌┤    ├┐         │ ║\n│┌───────┐│└───────┘│┌───────┐│     u ───→│┌───────┐│└────┘│┌───────┐│←─── u\n││LineEnd├o         o┤LineEnd││  =>     ║ ││LineEnd├o      o┤LineEnd││ ║\n│└───────┘│┌───────┐│└───────┘│     i ←───│└───────┘│┌────┐│└───────┘│───→ i\n│  :src   └┤BranchB├┘  :dst   │         ║ │         └┤    ├┘         │ ║\n│          └───────┘          │         ║ │          └────┘          │ ║\n└─────────────────────────────┘         ║ └──────────────────────────┘ ║\n                                        ╚══════════════════════════════╝","category":"page"},{"location":"ModelingConcepts/#End-to-End-Example","page":"Modeling Concepts","title":"End to End Example","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Putting the knowledge from this document together, we can start a short simulation of an example network:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"using PowerDynamics, PowerDynamics.Library, ModelingToolkit\nusing Graphs, NetworkDynamics\nusing OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\nnothing #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"First, we define an MTKBus consisting of two predefined injector models from the library: a Swing generator model and a PQLoad. To do so, we use the MTKBus(injectors...) constructor.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"@named swing = Swing(; Pm=1, V=1, D=0.1)\n@named load = PQLoad(; Pset=-.5, Qset=0)\nbus1mtk = MTKBus(swing, load; name=:swingbus)\nshow(stdout, MIME\"text/plain\"(), bus1mtk) #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"This results in an MTK model, which fulfills the MTKBus interface and thus can be compiled into an actual VertexModel for simulation:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"vertex1f = compile_bus(bus1mtk) # extract component function","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"As a second bus in this example, we use a SlackDifferential from the library. This model is not an Injector but an MTKBus directly, as it does not make sense to connect anything else to a slack bus.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"bus2mtk = SlackDifferential(; name=:slackbus)\nvertex2f = compile_bus(bus2mtk) # extract component function","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"For the connecting line, we instantiate two PiLine from the library. Each PiLine fulfills the Branch interface. Therefore we can define a MTKLine model by putting both Branches in parallel:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"@named branch1 = PiLine()\n@named branch2 = PiLine()\nlinemtk = MTKLine(branch1, branch2; name=:powerline)\nshow(stdout, MIME\"text/plain\"(), bus1mtk) #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Similar to before, we need to compile the MTKModel by calling compile_line.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"edgef = compile_line(linemtk) # extract component function","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"To simulate the system, we place both components on a graph and define their network topology. We define both graph topology as well as the models for the individual components.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"g = complete_graph(2)\nnw = Network(g, [vertex1f, vertex2f], edgef)\nu0 = NWState(nw) # extract parameters and state from models\nu0.v[1, :swing₊θ] = 0 # set missing initial conditions\nu0.v[1, :swing₊ω] = 1\nnothing #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Then we can solve the problem","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"prob = ODEProblem(nw, uflat(u0), (0,1), pflat(u0))\nsol = solve(prob, Rodas5P())\n@assert OrdinaryDiffEqRosenbrock.SciMLBase.successful_retcode(sol) #hide\nnothing #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"And finally we can plot the solution:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"fig = Figure();\nax = Axis(fig[1,1])\nlines!(ax, sol; idxs=VIndex(1,:busbar₊P), label=\"Power injection Bus\", color=Cycled(1))\nlines!(ax, sol; idxs=VIndex(1,:swing₊Pel), label=\"Power injection Swing\", color=Cycled(2))\nlines!(ax, sol; idxs=VIndex(1,:load₊P), label=\"Power injection load\", color=Cycled(3))\naxislegend(ax)\n\nax = Axis(fig[2,1])\nlines!(ax, sol; idxs=VIndex(1,:busbar₊u_arg), label=\"swing bus voltage angle\", color=Cycled(1))\nlines!(ax, sol; idxs=VIndex(2,:busbar₊u_arg), label=\"slack bus voltage angle\", color=Cycled(2))\naxislegend(ax)\nfig #hide","category":"page"},{"location":"ModelingConcepts/#Internals","page":"Modeling Concepts","title":"Internals","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Internally, we use different input/output conventions for bus and line models. The predefined models BusBar() and LineEnd() are defined in the following way:","category":"page"},{"location":"ModelingConcepts/#Model:-BusBar()","page":"Modeling Concepts","title":"Model: BusBar()","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A busbar is a concrete model used in bus modeling. It represents the physical connection within a bus, the component where all injectors and lines attach.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"           ┌──────────┐\ni_lines ──→│          │  (t)\n           │  Busbar  ├───o\n  u_bus ←──│          │\n           └──────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"It receives the sum of all line currents as an input and balances this with the currents flowing into the terminal. As an output, it forwards the terminal voltage to the backend.","category":"page"},{"location":"ModelingConcepts/#Model:-LineEnd()","page":"Modeling Concepts","title":"Model: LineEnd()","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A LineEnd model is very similar to the BusBar model. It represents one end of a transmission line.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"          ┌───────────┐\n u_bus ──→│           │  (t)\n          │  LineEnd  ├───o\ni_line ←──│           │\n          └───────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"It has special input/output connectors which handle the network interconnection. The main difference being the distinct input/output conventions for the network interface.","category":"page"},{"location":"generated/emt_toymodel/#emt-toymodel","page":"EMT Toymodel","title":"EMT Toy Model Example","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"This script can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"This example demonstrates an electromagnetic transient (EMT) simulation of a simple two-bus system using PowerDynamics.jl. The system consists of a slack bus connected to a load bus through an RL transmission line, with the load bus having both a dynamic PQ load and a capacitive shunt element.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"We compare our simulation results with PowerFactory reference data to validate the EMT modeling approach.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"note: Pedagogical Example\nThis is a pedagogical example that demonstrates the modeling concepts in PowerDynamics.jl are generally compatible with EMT simulations. However, this is far from being an actual interesting simulation study. The way we want to handle EMT simulations in PowerDynamics.jl is not yet fully clear and remains an active area of development.The example serves to illustrate the flexibility of the modeling framework rather than provide a production-ready EMT simulation tool.","category":"page"},{"location":"generated/emt_toymodel/#System-Description","page":"EMT Toymodel","title":"System Description","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The test system includes:","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"Bus 1: Slack bus (infinite bus with constant voltage)\nBus 2: Load bus with PQ load and shunt capacitor\nTransmission line: RL model with distributed capacitance\nDisturbance: Load disconnection at t=0.1s","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"using PowerDynamics\nusing PowerDynamics.Library\nusing NetworkDynamics\nusing ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\nusing CSV\nusing SteadyStateDiffEq\nusing OrdinaryDiffEqRosenbrock\nusing DataFrames\nusing CairoMakie","category":"page"},{"location":"generated/emt_toymodel/#System-Parameters","page":"EMT Toymodel","title":"System Parameters","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"First, we define the base system parameters and component values.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"ω0    = 2π*50    ## Nominal frequency [rad/s]\nSbase = 300      ## Base power [MW]\nVbase = 110      ## Base voltage [kV]\n\nRline = 1        ## Line resistance [Ω]\nLline = (1/100π) ## Line inductance [H]\nCline = (2e-6)   ## Line capacitance [F]\nPload = -300     ## Load power (negative = consumption) [MW]\n\n# Convert to per-unit values\nRline_pu = Rline / Zbase(Sbase, Vbase)\nLline_pu = Lline / Zbase(Sbase, Vbase)\nCline_pu = Cline / Ybase(Sbase, Vbase)\nPload_pu = Pload / Sbase\nnothing # hide","category":"page"},{"location":"generated/emt_toymodel/#Bus-Definitions","page":"EMT Toymodel","title":"Bus Definitions","text":"","category":"section"},{"location":"generated/emt_toymodel/#Slack-Bus","page":"EMT Toymodel","title":"Slack Bus","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The slack bus maintains constant voltage magnitude and angle, representing an infinite bus or strong grid connection.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"slackbus = compile_bus(pfSlack(; V=1), vidx=1)","category":"page"},{"location":"generated/emt_toymodel/#Dynamic-Shunt-Capacitor-Model","page":"EMT Toymodel","title":"Dynamic Shunt Capacitor Model","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The shunt capacitor is modeled as a dynamic component in the dq-frame. This allows us to observe the three-phase voltages (u_a, u_b, u_c) by transforming from the dq-frame back to abc coordinates.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The capacitor dynamics are given by:","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"beginaligned\nfracdu_rdt = phantom-omega_0 u_i + frac1C i_r \nfracdu_idt = -omega_0 u_r + frac1C i_i\nendaligned","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"where the omega_0 u_i and -omega_0 u_r terms account for the rotating dq-frame.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"@mtkmodel DynamicShunt begin\n    @components begin\n        terminal = Terminal()\n    end\n    @variables begin\n        u_r(t), [guess=1, description=\"Real part of voltage\"]\n        u_i(t), [guess=0, description=\"Imaginary part of voltage\"]\n        # Three-phase voltages as observables\n        u_a(t), [description=\"Voltage in a phase\"]\n        u_b(t), [description=\"Voltage in b phase\"]\n        u_c(t), [description=\"Voltage in c phase\"]\n    end\n    @parameters begin\n        C, [description=\"Capacitance\"]\n        ω0, [description=\"Angular frequency of dq Frame\"]\n    end\n    begin\n        # Transformation matrix from dq to abc coordinates\n        Tdqinv(δ) = [cos(δ)       -sin(δ)\n                     cos(δ-2pi/3) -sin(δ-2pi/3)\n                     cos(δ+2pi/3) -sin(δ+2pi/3)]\n    end\n    @equations begin\n        # Capacitor dynamics in rotating dq-frame\n        Dt(u_r) ~  ω0*u_i + 1/C * terminal.i_r\n        Dt(u_i) ~ -ω0*u_r + 1/C * terminal.i_i\n        # Terminal connections\n        terminal.u_r ~ u_r\n        terminal.u_i ~ u_i\n        # Transform to three-phase voltages\n        [u_a, u_b, u_c] ~ Tdqinv(ω0*t) * [u_r, u_i]\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/emt_toymodel/#Load-Bus-Components","page":"EMT Toymodel","title":"Load Bus Components","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The load bus combines two components:","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"A PQ load consuming constant active power (injector model from Library)\nA dynamic shunt capacitor representing line charging","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"@named load = PQLoad(Pset=-Pload_pu, Qset=0)\n@named shunt = DynamicShunt(C=Cline_pu, ω0=ω0)\nloadbus = compile_bus(\n    MTKBus(load, shunt);\n    vidx=2\n)","category":"page"},{"location":"generated/emt_toymodel/#Transmission-Line-Model","page":"EMT Toymodel","title":"Transmission Line Model","text":"","category":"section"},{"location":"generated/emt_toymodel/#Dynamic-RL-Branch","page":"EMT Toymodel","title":"Dynamic RL Branch","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The transmission line is modeled as a dynamic RL branch in the dq-frame. The line current dynamics are given by:","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"beginaligned\nfracdi_rdt = phantom-omega_0 i_i - fracRL i_r + frac1L(u_textdstr - u_textsrcr) \nfracdi_idt = -omega_0 i_r - fracRL i_i + frac1L(u_textdsti - u_textsrci)\nendaligned","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"where the voltage difference drives the current through the line impedance.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"@mtkmodel DynamicRLBranch begin\n    @components begin\n        src = Terminal()\n        dst = Terminal()\n    end\n    @variables begin\n        i_r(t)=0, [description=\"Current in real part\"]\n        i_i(t)=-1, [description=\"Current in imaginary part\"]\n    end\n    @parameters begin\n        R, [description=\"Resistance\"]\n        L, [description=\"Inductance\"]\n        ω0, [description=\"Angular frequency of dq Frame\"]\n    end\n    @equations begin\n        # RL line dynamics in rotating dq-frame\n        Dt(i_r) ~  ω0 * i_i  - R/L * i_r + 1/L*(dst.u_r - src.u_r)\n        Dt(i_i) ~ -ω0 * i_r  - R/L * i_i + 1/L*(dst.u_i - src.u_i)\n        # Terminal current connections (KCL enforcement)\n        src.i_r ~ -i_r  ## Current flows out of source\n        src.i_i ~ -i_i\n        dst.i_r ~ i_r   ## Current flows into destination\n        dst.i_i ~ i_i\n    end\nend\n\n@named branch = DynamicRLBranch(; R=Rline_pu, L=Lline_pu, ω0=ω0)\nline_model = compile_line(\n    MTKLine(branch);\n    src=1, dst=2\n)","category":"page"},{"location":"generated/emt_toymodel/#Network-Assembly-and-Initialization","page":"EMT Toymodel","title":"Network Assembly and Initialization","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"We assemble the complete network and attempt initialization.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"nw = Network([slackbus, loadbus], line_model)\ntry #hide\ns0 = find_fixpoint(nw; alg=DynamicSS(Rodas5P()))\ncatch e #hide\n    @error e #hide\nend #hide","category":"page"},{"location":"generated/emt_toymodel/#Initialization-Challenge","page":"EMT Toymodel","title":"Initialization Challenge","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The direct initialization fails due to the stiffness of the PQ load model. When the load current is computed algebraically from i = P fracuu^2, the system becomes numerically challenging to initialize.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"To overcome this, we use a \"less stiff\" load model with dynamics that smooth out the algebraic singularity during initialization.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"We create a \"less stiff\" version of the PQ load that introduces first-order dynamics with a fast time constant (1/1000 s). This smooths the algebraic relation and makes initialization more robust:","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"beginaligned\nfracdi_rdt = 1000 left( P fracu_ru_r^2 + u_i^2 - i_r right) \nfracdi_idt = 1000 left( P fracu_iu_r^2 + u_i^2 - i_i right)\nendaligned","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"This approaches the algebraic PQ load behavior but avoids initialization issues.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"@mtkmodel LessStiffPQLoad begin\n    @components begin\n        terminal = Terminal()\n    end\n    @variables begin\n        i_r(t)=0, [description=\"Current in real part\"]\n        i_i(t)=0, [description=\"Current in imaginary part\"]\n    end\n    @parameters begin\n        Pset, [description=\"Active Power demand\"]\n    end\n    @equations begin\n        # First-order dynamics with fast time constant\n        Dt(i_r) ~ 1e3*(Pset * terminal.u_r/(terminal.u_r^2 + terminal.u_i^2) - i_r)\n        Dt(i_i) ~ 1e3*(Pset * terminal.u_i/(terminal.u_r^2 + terminal.u_i^2) - i_i)\n        terminal.i_r ~ i_r\n        terminal.i_i ~ i_i\n    end\nend\n\n@named less_stiff_load = LessStiffPQLoad(Pset=-Pload_pu)\nless_stiff_loadbus = compile_bus(\n    MTKBus(less_stiff_load, shunt);\n    vidx=2\n)\nless_stiff_nw = Network([slackbus, less_stiff_loadbus], line_model)\nless_stiff_s0 = find_fixpoint(less_stiff_nw; alg=DynamicSS(Rodas5P()))","category":"page"},{"location":"generated/emt_toymodel/#Initialize-Target-System","page":"EMT Toymodel","title":"Initialize Target System","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"Perfect! The less stiff load initialization worked. Now we use this solution as an initial guess for our target system with the algebraic PQ load.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"s0guess = NWState(nw)\n# Transfer key state variables from less stiff solution\ns0guess[VIndex(2, :busbar₊u_i)] = less_stiff_s0[VIndex(2, :busbar₊u_i)]\ns0guess[VIndex(2, :busbar₊u_r)] = less_stiff_s0[VIndex(2, :busbar₊u_r)]\ns0guess[EIndex(1, :branch₊i_i)] = less_stiff_s0[EIndex(1, :branch₊i_i)]\ns0guess[EIndex(1, :branch₊i_r)] = less_stiff_s0[EIndex(1, :branch₊i_r)]\ns0 = find_fixpoint(nw, s0guess; alg=DynamicSS(Rodas5P()))","category":"page"},{"location":"generated/emt_toymodel/#Disturbance-Setup","page":"EMT Toymodel","title":"Disturbance Setup","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"Excellent! The initialization succeeded. Now we set up a disturbance to observe the system's transient response. We'll disable the load at t=0.1s to simulate a sudden load disconnection.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"disable_load_affect = ComponentAffect([], [:load₊Pset]) do u, p, ctx\n    println(\"Disabling load at time $(ctx.t)\")\n    p[:load₊Pset] = 0  ## Set load power to zero\nend\nset_callback!(loadbus, PresetTimeComponentCallback(0.1, disable_load_affect))\nnothing #hide","category":"page"},{"location":"generated/emt_toymodel/#Dynamic-Simulation","page":"EMT Toymodel","title":"Dynamic Simulation","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"With the system properly initialized and the disturbance configured, we can now run the electromagnetic transient simulation.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"prob = ODEProblem(nw, uflat(s0), (0.0, 0.15), copy(pflat(s0)); callback=get_callbacks(nw))\nsol = solve(prob, Rodas5P());\nnothing #hide","category":"page"},{"location":"generated/emt_toymodel/#Results-and-Validation","page":"EMT Toymodel","title":"Results and Validation","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"We compare our EMT simulation results with PowerFactory reference data to validate the modeling approach. The comparison focuses on the three-phase voltages at bus 2 during the load disconnection transient.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"The thick gray lines show the PowerFactory reference, while our PowerDynamics.jl results are overlaid in color. The close agreement validates our EMT modeling approach.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"fig = let\n    fig = Figure()\n    ax = Axis(fig[1,1];\n        title=\"Three-Phase Voltage at Bus 2\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Voltage [pu]\")\n    ts = range(0.09, 0.13; length=2000)\n\n    # Load PowerFactory reference data\n    df = CSV.read(\n        joinpath(pkgdir(PowerDynamics),\"docs\",\"examples\", \"emt_data_minimal.csv.gz\"),\n        DataFrame\n    )\n    # Plot PowerFactory results (thick gray lines)\n    lines!(ax, df.t, df.u_2_a; label=\"PowerFactory A\", color=:lightgray, linewidth=5)\n    lines!(ax, df.t, df.u_2_b; label=\"PowerFactory B\", color=:lightgray, linewidth=5)\n    lines!(ax, df.t, df.u_2_c; label=\"PowerFactory C\", color=:lightgray, linewidth=5)\n\n    # Extract and plot our simulation results\n    a = sol(ts, idxs=VIndex(2, :shunt₊u_a)).u\n    b = sol(ts, idxs=VIndex(2, :shunt₊u_b)).u\n    c = sol(ts, idxs=VIndex(2, :shunt₊u_c)).u\n    lines!(ax, ts, a, label=\"PowerDynamics A\", color=Cycled(1))\n    lines!(ax, ts, b, label=\"PowerDynamics B\", color=Cycled(2))\n    lines!(ax, ts, c, label=\"PowerDynamics C\", color=Cycled(3))\n\n    axislegend(ax, position=:rt)\n    xlims!(ax, ts[begin], ts[end])\n    fig\nend","category":"page"},{"location":"generated/emt_toymodel/#Detailed-View-of-Transient-Response","page":"EMT Toymodel","title":"Detailed View of Transient Response","text":"","category":"section"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"Let's zoom in on the critical period around the load disconnection to better observe the transient behavior and compare with the reference.","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"xlims!(0.0995, 0.105)\nfig","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"","category":"page"},{"location":"generated/emt_toymodel/","page":"EMT Toymodel","title":"EMT Toymodel","text":"This page was generated using Literate.jl.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"The following functions are designed for public use.","category":"page"},{"location":"API/#Modeling-Tools","page":"API","title":"Modeling Tools","text":"","category":"section"},{"location":"API/#Connectors-and-Base-Components","page":"API","title":"Connectors and Base Components","text":"","category":"section"},{"location":"API/#PowerDynamics.Terminal","page":"API","title":"PowerDynamics.Terminal","text":"@named t = Terminal()\n\nA ModelingToolkit connector for electrical terminals in power system components.\n\nRepresents an electrical connection point with complex voltage and current in dq coordinates. The terminal defines the interface between power system components like buses, lines, and machines.\n\nVariables\n\nu_r(t): d-axis voltage component\nu_i(t): q-axis voltage component\ni_r(t): d-axis current component (flow variable)\ni_i(t): q-axis current component (flow variable)\n\nNotes\n\nCurrent variables are defined as flow variables, meaning they sum to zero at connection points according to Kirchhoff's current law.\n\nSee also: BusBar, LineEnd\n\n\n\n\n\n","category":"constant"},{"location":"API/#PowerDynamics.BusBar","page":"API","title":"PowerDynamics.BusBar","text":"@named busbar = BusBar()\n\nA ModelingToolkit model representing the physical connection point within a bus in power systems. It represents the physical busbar where all injectors and lines attach.\n\nWithin PowerDynamics.jl, it serves as an interface between the MTK world and the NetworkDynamics world: A MTK model containing a BusBar the highest level is consdered a busmodel (see isbusmodel) and describes the dynamics of an entire bus. It can be transformed in a VertexModel by calling compile_bus.\n\nSee also: Terminal, MTKBus, compile_bus\n\n\n\n\n\n","category":"constant"},{"location":"API/#PowerDynamics.LineEnd","page":"API","title":"PowerDynamics.LineEnd","text":"LineEnd\n\nA ModelingToolkit model representing one end of a transmission line in power systems. It represents the physical connection point at the end of a transmission line.\n\nWithin PowerDynamics.jl, it serves as an interface between the MTK world and the NetworkDynamics world: A MTK model containing two LineEnds (named :src and :dst) at the highest level is considered a linemodel (see islinemodel) and describes the dynamics of an entire line. It can be transformed in an EdgeModel by calling compile_line.\n\nSee also: Terminal, MTKLine, compile_line\n\n\n\n\n\n","category":"constant"},{"location":"API/#Bus-and-Line-Construction","page":"API","title":"Bus and Line Construction","text":"","category":"section"},{"location":"API/#PowerDynamics.MTKBus","page":"API","title":"PowerDynamics.MTKBus","text":"MTKBus(injectors...; name=:bus)\n\nCreate a ModelingToolkit bus system by connecting multiple injector components.\n\nConstructs a bus System by connecting all provided injector components to a central BusBar. Each injector component must satisfy the injector model interface (see isinjectormodel).\n\nArguments\n\ninjectors...: Variable number of injector components (generators, loads, etc.)\nname=:bus: Name for the resulting bus system\n\nReturns\n\nAn System representing the complete bus with all connected injectors\n\n                                 ┌────────────────────┐\n                                 │MTKBus   ┌─────────┐│\n                                 │        ┌┤Generator││\n        ┌─────────┐   ┌────┐     │┌──────┐│└─────────┘│\nMTKBus(o┤Generator│, o┤Load│) => ││BusBar├o           │\n        └─────────┘   └────┘     │└──────┘│┌────┐     │\n                                 │        └┤Load│     │\n                                 │         └────┘     │\n                                 └────────────────────┘\n\nSee also: compile_bus, BusBar, isinjectormodel\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.MTKLine","page":"API","title":"PowerDynamics.MTKLine","text":"MTKLine(branches...; name=:line)\n\nCreate a ModelingToolkit line system by connecting multiple branch components.\n\nConstructs a line System by connecting all provided branch components between source and destination line ends in parallel. Each branch component must satisfy the branch model interface.\n\nArguments\n\nbranches...: Variable number of branch components (transmission lines, transformers, etc.)\nname=:line: Name for the resulting line system\n\nReturns\n\nAn System representing the complete line with all connected branches\n\n                                     ┌─────────────────────────────┐\n                                     │MTKLine   ┌───────┐          │\n                                     │         ┌┤BranchA├┐         │\n         ┌───────┐    ┌───────┐      │┌───────┐│└───────┘│┌───────┐│\nMTKLine(o┤BranchA├o, o┤BranchB├o) => ││LineEnd├o         o┤LineEnd││\n         └───────┘    └───────┘      │└───────┘│┌───────┐│└───────┘│\n                                     │  :src   └┤BranchB├┘  :dst   │\n                                     │          └───────┘          │\n                                     └─────────────────────────────┘\n\nSee also: compile_line, LineEnd, isbranchmodel\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.CompositeInjector","page":"API","title":"PowerDynamics.CompositeInjector","text":"CompositeInjector(systems, eqs=autoconnections(systems); name=Symbol(join(getname.(systems), \"_\")))\n\nCreate an injector object which contains several subsystems. Every subsystem which has a terminal will be connected to a newly created terminal of the composite injector. The subsystems are namespaced within the composite injector.\n\nThere are two options for additional connections between the subsystems:\n\ninterconnections will be created automatically using some name-matching heuristics using autoconnections(systems): It searches all Blocks.RealOutput and Blocks.RealInput, and tries to find a single matching output for each input.\nalternatively pass connecting equations of the form [connect(sys1.output, sys2.input)] explicitly\n\nFor example, one could create a composite injector with three subsystems:\n\na generator,\na controller, and\na load;\n\nwhich is augmented with 2 connection equations\n\none for the measurements (generator -> controller), and\none for the actuation (controller -> generator).\n\nThe returned model contains a new terminal :terminal at the toplevel, thus satisfying the injector interface, see isinjectormodel). It can be used as such in the MTKBus constructor.\n\n    ┌────────────────────────────────────┐\n    │ CompositeInjector                  │\n    │              ╭───→───╮ measurements│\n    │    ┌─────────┴─┐   ┌─┴──────────┐  │\n(t) │  o─┤ Generator │   │ Controller │  │\n o──┼──┤ └─────────┬─┘   └─┬──────────┘  │\n    │  │           ╰───←───╯ actuation   │\n    │  │ ┌──────┐                        │\n    │  o─┤ Load │                        │\n    │    └──────┘                        │\n    └────────────────────────────────────┘\n\n\n\n\n\n","category":"function"},{"location":"API/#Base-Unit-Calculations","page":"API","title":"Base Unit Calculations","text":"","category":"section"},{"location":"API/#PowerDynamics.Ibase","page":"API","title":"PowerDynamics.Ibase","text":"Ibase(S, V)\n\nCalculates current pu base based on Sbase and Vbase: Ibase = Sbase/Vbase.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.Zbase","page":"API","title":"PowerDynamics.Zbase","text":"Zbase(S, V)\n\nCalculates impedance pu base based on Sbase and Vbase: Zbase = Vbase²/Sbase.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.Ybase","page":"API","title":"PowerDynamics.Ybase","text":"Ybase(S, V)\n\nCalculates admittance pu base based on Sbase and Vbase: Ybase = Sbase/Vbase².\n\n\n\n\n\n","category":"function"},{"location":"API/#Network-Components","page":"API","title":"Network Components","text":"","category":"section"},{"location":"API/#PowerDynamics.compile_bus","page":"API","title":"PowerDynamics.compile_bus","text":"compile_bus(sys::System; verbose=false, name=getname(sys), kwargs...)\n\nCreate a VertexModel from an System that satisfies the bus model interface.\n\nArguments\n\nsys::System: The system must satisfy the bus model interface (see isbusmodel)\nverbose::Bool=false: Enable verbose output during creation\nname: Name for the bus (defaults to system name)\nkwargs...: Additional keyword arguments passed to the Bus constructor\n\nReturns\n\nA VertexModel representing the bus\n\n                                                  ╔═════════════════════════╗\n                                                  ║ VertexModel (compiled)  ║\n            ┌────────────────────┐      Network   ║  ┌────────────────────┐ ║\n            │MTKBus   ┌─────────┐│     interface  ║  │MTKBus   ┌─────────┐│ ║\n            │        ┌┤Generator││                ║  │        ┌┤Generator││ ║\n            │┌──────┐│└─────────┘│      current ────→│┌──────┐│└─────────┘│ ║\ncompile_bus(││BusBar├o           │) =>            ║  ││BusBar├o           │ ║\n            │└──────┘│┌────┐     │      voltage ←────│└──────┘│┌────┐     │ ║\n            │        └┤Load│     │                ║  │        └┤Load│     │ ║\n            │         └────┘     │                ║  │         └────┘     │ ║\n            └────────────────────┘                ║  └────────────────────┘ ║\n                                                  ╚═════════════════════════╝\n\nSee also: MTKBus\n\n\n\n\n\ncompile_bus(template::VertexModel; copy=true, pf=nothing, name=template.name, pairs...)\n\nSimilar to the Bus constructor, but takes a pre-compiled VertexModel. It copies the VertexModel and applies the keyword arguments. This is useful when you want to create new bus models based on a template.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.compile_line","page":"API","title":"PowerDynamics.compile_line","text":"compile_line(sys::System; verbose=false, name=getname(sys), kwargs...)\n\nCreate an EdgeModel from a System that satisfies the line model interface.\n\nArguments\n\nsys::System: The system must satisfy the line model interface (see islinemodel)\nverbose::Bool=false: Enable verbose output during creation\nname: Name for the line (defaults to system name)\nkwargs...: Additional keyword arguments passed to the Line constructor\n\nReturns\n\nAn EdgeModel representing the line\n\n\n                                                     ╔══════════════════════════════╗\n                                                     ║ EdgeModel (compiled)         ║\n             ┌─────────────────────────────┐     src ║ ┌──────────────────────────┐ ║ dst\n             │MTKLine   ┌───────┐          │  vertex ║ │MTKLine   ┌────┐          │ ║ vertex\n             │         ┌┤BranchA├┐         │         ║ │         ┌┤    ├┐         │ ║\n             │┌───────┐│└───────┘│┌───────┐│     u ───→│┌───────┐│└────┘│┌───────┐│←─── u\ncompile_line(││LineEnd├o         o┤LineEnd││) =>     ║ ││LineEnd├o      o┤LineEnd││ ║\n             │└───────┘│┌───────┐│└───────┘│     i ←───│└───────┘│┌────┐│└───────┘│───→ i\n             │  :src   └┤BranchB├┘  :dst   │         ║ │         └┤    ├┘         │ ║\n             │          └───────┘          │         ║ │          └────┘          │ ║\n             └─────────────────────────────┘         ║ └──────────────────────────┘ ║\n                                                     ╚══════════════════════════════╝\n\nSee also: MTKLine\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.simplify_mtkbus","page":"API","title":"PowerDynamics.simplify_mtkbus","text":"simplify_mtkbus(sys::System; busbar=:busbar)\n\nStructurally simplify a bus model System by eliminating equations.\n\nClosely matches what VertexModel does, but returns the System after the simplifications rather than compiling it into a VertexModel.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.simplify_mtkline","page":"API","title":"PowerDynamics.simplify_mtkline","text":"simplify_mtkline(sys::System; src=:src, dst=:dst)\n\nStructurally simplify a line model System by eliminating equations.\n\nClosely matches what EdgeModel does, but returns the System after the simplifications rather than compiling it into an EdgeModel.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.Bus","page":"API","title":"PowerDynamics.Bus","text":"Bus(args...; kwargs...) => compile_bus(args...; kwargs...)\n\nDEPRECATED! Use compile_bus instead.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.Line","page":"API","title":"PowerDynamics.Line","text":"Line(args...; kwargs...) => compile_line(args...; kwargs...)\n\nDEPRECATED! Use compile_line instead.\n\n\n\n\n\n","category":"function"},{"location":"API/#Interface-Checking-Functions","page":"API","title":"Interface Checking Functions","text":"","category":"section"},{"location":"API/#PowerDynamics.isinjectormodel","page":"API","title":"PowerDynamics.isinjectormodel","text":"isinjectormodel(sys::System)\n\nCheck if a System satisfies the injector model interface.\n\nAn injector model must contain a Terminal named :terminal. Injector models represent components like generators, loads, and other devices that connect to a single bus. They can have arbitrary internal complexity as long as they have exactly one terminal.\n\n   (t)    ┌──────────┐\n    o─────┤ Injector │\n:terminal └──────────┘\n\nSee also: Terminal\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.isbusmodel","page":"API","title":"PowerDynamics.isbusmodel","text":"isbusmodel(sys::System)\n\nCheck if a System satisfies the bus model interface.\n\nA bus model must contain a component named :busbar that satisfies the busbar interface. Bus models represent the complete dynamics of a power system bus and can be transformed into a VertexModel using compile_bus.\n\n┌───────────────────────────┐\n│BusModel     ┌────────────┐│\n│           ┌─┤ Injector 1 ││\n│┌────────┐ │ └────────────┘│\n││ BusBar ├─o               │\n│└────────┘ │               │\n│ :busbar   └ ...           │\n│                           │\n└───────────────────────────┘\n\nNote: The BusModel musst contain exaclty one BusBar, the rest of the structure is free. For example, you could also put a Brach between an injector and a Busbar or have multiple injectors and controllers connected.\n\nSee also: compile_bus, BusBar, MTKBus\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.isbranchmodel","page":"API","title":"PowerDynamics.isbranchmodel","text":"isbranchmodel(sys::System)\n\nCheck if a System satisfies the branch model interface.\n\nA branch model must contain two Terminal components named :src and :dst. Branch models represent two-port network elements like transmission lines, transformers, and other connecting devices.\n\n (t) ┌────────┐ (t)\n  o──┤ Branch ├──o\n:src └────────┘ :dst\n\nSee also: Terminal\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.islinemodel","page":"API","title":"PowerDynamics.islinemodel","text":"islinemodel(sys::System)\n\nCheck if a System satisfies the line model interface.\n\nA line model must contain two components named :src and :dst that both satisfy the line end interface. Line models represent transmission lines and can be transformed into an EdgeModel using compile_line.\n\n┌──────────────────────────────────────┐\n│LineModel     ┌────────┐              │\n│            ┌─┤ Branch ├─┐            │\n│┌─────────┐ │ └────────┘ │ ┌─────────┐│\n││ LineEnd ├─o            o─┤ LineEnd ││\n│└─────────┘ │            │ └─────────┘│\n│   :src     └    ....    ┘    :dst    │\n│                                      │\n└──────────────────────────────────────┘\n\nNote: Between the LineEnds there can be arbeitrary structures, for example branches in series or parallel.\n\nSee also: compile_line, LineEnd, MTKBus\n\n\n\n\n\n","category":"function"},{"location":"API/#Power-Flow-Analysis","page":"API","title":"Power Flow Analysis","text":"","category":"section"},{"location":"API/#Power-Flow-Bus-Types","page":"API","title":"Power Flow Bus Types","text":"","category":"section"},{"location":"API/#PowerDynamics.pfSlack","page":"API","title":"PowerDynamics.pfSlack","text":"pfSlack(; V=missing, δ=missing, u_r=missing, u_i=missing, name=:slackbus)\n\nCreate a slack bus for power flow analysis.\n\nA slack bus maintains constant voltage magnitude and phase angle (or real and imaginary voltage components). Either provide voltage magnitude V and phase angle δ, or provide real and imaginary voltage components u_r and u_i.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.pfPV","page":"API","title":"PowerDynamics.pfPV","text":"pfPV(; P, V, name=:pvbus)\n\nCreate a PV bus for power flow analysis.\n\nA PV bus maintains constant active power injection and voltage magnitude. The reactive power and voltage phase angle are determined by the power flow solution.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.pfPQ","page":"API","title":"PowerDynamics.pfPQ","text":"pfPQ(; P=0, Q=0, name=:pqbus)\n\nCreate a PQ bus for power flow analysis.\n\nA PQ bus has specified active and reactive power injections. The voltage magnitude and phase angle are determined by the power flow solution.\n\n\n\n\n\n","category":"function"},{"location":"API/#Power-Flow-Solution-Functions","page":"API","title":"Power Flow Solution Functions","text":"","category":"section"},{"location":"API/#PowerDynamics.solve_powerflow","page":"API","title":"PowerDynamics.solve_powerflow","text":"solve_powerflow(nw::Network;\n                pfnw = powerflow_model(nw),\n                pfs0 = NWState(nw),\n                fill_busbar_defaults=true\n                verbose=true)\n\nSolve the power flow equations for a given network.\n\nUses find_fixpoint from NetworkDynamics to solve the algebraic power flow equations.\n\nParameters\n\nnw: The dynamic network model\npfnw: The power flow network model (default: created from nw)\npfs0: Initial state for the power flow calculation\nfill_busbar_defaults: Whether to fill missing default values for busbar states (i.e. ur=1 ui=0)\nverbose: Whether to print the power flow solution\n\nReturns\n\nA NWState containing the solved power flow solution\n\nSee also initialize_from_pf.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.initialize_from_pf!","page":"API","title":"PowerDynamics.initialize_from_pf!","text":"initialize_from_pf[!](\n    nw::Network;\n    verbose = true,\n    subverbose = false,\n    pfnw = powerflow_model(nw),\n    pfs0 = NWState(pfnw),\n    pfs = solve_powerflow(nw; pfnw, pfs0, verbose),\n    kwargs...\n)\n\nInitialize a dynamic network model from a power flow solution.\n\nThis function performs a two-step initialization process:\n\nSolve the power flow equations for the network\nUse the power flow solution to initialize the dynamic model\n\nPer default, the powerflow solution is computed as\n\npfnw = powerflow_model(nw)                     # get powerflow network model\npfs0 = NWState(pfnw)                           # initial condition for network model\npfs = solve_powerflow(nw; pfnw, pfs0, verbose) # solve powerflow\n\nYou can override any of these steps by providing pfnw, pfs0, or pfs directly as a keyword argument.\n\nThere are two versions of this function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses initialize_componentwise! internally, the non-mutating one initialize_componentwise. When the mutating version is used, NWState(nw) after initialization will return the same initialized state again, as it is stored in the metadata.\n\nParameters\n\nnw: The dynamic network model to initialize\nverbose: Whether to print information about the power flow solution (default: true)\nsubverbose: Whether to print detailed information during component initialization (default: false). Can be Vector [VIndex(1), EIndex(3), ...] for selective output\npfnw: Power flow network model (default: created from nw using powerflow_model)\npfs0: Initial state for power flow calculation (default: created from pfnw)\npfs: Power flow solution (default: calculated using solve_powerflow)\nAdditional keyword arguments are passed to initialize_componentwise[!]\n\nReturns\n\nA fully initialized network state\n\nSee also: solve_powerflow, initialize_componentwise, interface_values\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.initialize_from_pf","page":"API","title":"PowerDynamics.initialize_from_pf","text":"initialize_from_pf[!](\n    nw::Network;\n    verbose = true,\n    subverbose = false,\n    pfnw = powerflow_model(nw),\n    pfs0 = NWState(pfnw),\n    pfs = solve_powerflow(nw; pfnw, pfs0, verbose),\n    kwargs...\n)\n\nInitialize a dynamic network model from a power flow solution.\n\nThis function performs a two-step initialization process:\n\nSolve the power flow equations for the network\nUse the power flow solution to initialize the dynamic model\n\nPer default, the powerflow solution is computed as\n\npfnw = powerflow_model(nw)                     # get powerflow network model\npfs0 = NWState(pfnw)                           # initial condition for network model\npfs = solve_powerflow(nw; pfnw, pfs0, verbose) # solve powerflow\n\nYou can override any of these steps by providing pfnw, pfs0, or pfs directly as a keyword argument.\n\nThere are two versions of this function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses initialize_componentwise! internally, the non-mutating one initialize_componentwise. When the mutating version is used, NWState(nw) after initialization will return the same initialized state again, as it is stored in the metadata.\n\nParameters\n\nnw: The dynamic network model to initialize\nverbose: Whether to print information about the power flow solution (default: true)\nsubverbose: Whether to print detailed information during component initialization (default: false). Can be Vector [VIndex(1), EIndex(3), ...] for selective output\npfnw: Power flow network model (default: created from nw using powerflow_model)\npfs0: Initial state for power flow calculation (default: created from pfnw)\npfs: Power flow solution (default: calculated using solve_powerflow)\nAdditional keyword arguments are passed to initialize_componentwise[!]\n\nReturns\n\nA fully initialized network state\n\nSee also: solve_powerflow, initialize_componentwise, interface_values\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.show_powerflow","page":"API","title":"PowerDynamics.show_powerflow","text":"show_powerflow(s::NWState/Network)\n\nDisplay power flow results in a tabular format.\n\nExtract and format power flow solution data from a network state, showing bus-level information including voltage magnitudes, phase angles, active power, and reactive power.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.powerflow_model","page":"API","title":"PowerDynamics.powerflow_model","text":"powerflow_model(cf::NetworkDynamics.ComponentModel; check=:error)\n\nExtract or create a power flow component model from a dynamic component model.\n\nIf the component has :pfmodel metadata, use that model (after validation)\nIf the component is already a valid power flow model (i.e. no ODE, just constraints), return it as-is\n\nParameters\n\ncf: The component model to extract/create a power flow model from\ncheck: Validation behavior (:error, :warn, or :none) when model validation fails\n\nReturns\n\nA component model suitable for power flow analysis (no dynamics)\n\nValidation\n\nThe returned model must satisfy ispfmodel criteria:\n\nEither no states or zero mass matrix (no dynamics)\n\nSee also: ispfmodel, pfSlack, pfPV, pfPQ\n\n\n\n\n\npowerflow_model(nw::Network; check=:error)\n\nCreate a power flow network model from a dynamic network model.\n\nThis method applies powerflow_model to all vertex and edge components in the network, creating a new network suitable for steady-state power flow analysis.\n\nParameters\n\nnw: The network to create a power flow model from\ncheck: Validation behavior (:error, :warn, or :none) passed to component-level powerflow_model calls\n\nReturns\n\nA new Network with the same graph structure but power flow component models\n\nSee also: solve_powerflow\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.ispfmodel","page":"API","title":"PowerDynamics.ispfmodel","text":"ispfmodel(cf::NetworkDynamics.ComponentModel)\n\nCheck if a component model is suitable for power flow analysis.\n\nA component model is considered a valid power flow model if it has no dynamics, i.e., either no states or a zero mass matrix.\n\nReturns\n\ntrue if the component is suitable for power flow analysis\nfalse otherwise\n\n\n\n\n\n","category":"function"},{"location":"API/#Power-Flow-Model-Management-Functions","page":"API","title":"Power Flow Model Management Functions","text":"","category":"section"},{"location":"API/#PowerDynamics.has_pfmodel","page":"API","title":"PowerDynamics.has_pfmodel","text":"has_pfmodel(c::ComponentModel)\nhas_pfmodel(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has a power flow model in metadata.\n\nSee also: get_pfmodel, set_pfmodel!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.get_pfmodel","page":"API","title":"PowerDynamics.get_pfmodel","text":"get_pfmodel(c::NetworkDynamics.ComponentModel)\nget_pfmodel(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the power flow model for the component model. May error if no power flow model is present. Use has_pfmodel to check first.\n\nSee also: has_pfmodel, set_pfmodel!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.set_pfmodel!","page":"API","title":"PowerDynamics.set_pfmodel!","text":"set_pfmodel!(c::NetworkDynamics.ComponentModel, model)\nset_pfmodel!(nw::Network, idx::Union{VIndex,EIndex}, model)\n\nSets the power flow model for the component. Overwrites any existing power flow model.\n\nSee also delete_pfmodel!, get_pfmodel.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.delete_pfmodel!","page":"API","title":"PowerDynamics.delete_pfmodel!","text":"delete_pfmodel!(c::NetworkDynamics.ComponentModel)\ndelete_pfmodel!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the power flow model from the component model, or from a component referenced by idx in a network. Returns true if the power flow model existed and was removed, false otherwise.\n\nSee also: set_pfmodel!.\n\n\n\n\n\n","category":"function"},{"location":"API/#Power-Flow-Initialization-Constraints","page":"API","title":"Power Flow Initialization Constraints","text":"","category":"section"},{"location":"API/#Constraint-Types","page":"API","title":"Constraint Types","text":"","category":"section"},{"location":"API/#PowerDynamics.PFInitConstraint","page":"API","title":"PowerDynamics.PFInitConstraint","text":"struct PFInitConstraint{F}\nPFInitConstraint(f, sym, pfsym, dim)\n\nA representation of an additional constraint that is applied during the initialization phase of a component. In contrast to a InitConstraint, this constraint may access additional variables which are available in the full NWState of the solved power flow!\n\nCrucially, this is only necessary for constraints, which cannot be expressed in terms of the interface variables (voltages and currents).\n\nSee also: @pfinitconstraint for a macro to create such constraints, PFInitConstraint, set_pfinitconstraint!, add_pfinitconstraint!\n\n\n\n\n\n","category":"type"},{"location":"API/#PowerDynamics.@pfinitconstraint","page":"API","title":"PowerDynamics.@pfinitconstraint","text":"@pfinitconstraint expr\n@pfinitconstraint begin\n    constraint1\n    constraint2\nend\n\nCreate a PFInitConstraint using macro syntax. Component variables are accessed with :symbol and power flow state variables with @pf(:symbol). Multiple constraints can be defined in a begin...end block.\n\nFor example, the following code creates constraints Pset/Qset of the dynamic model in reference to the variables P and Q of the powerflow model.\n\n@pfinitconstraint :dynamic₊Pset - @pf(:static₊P)\n@pfinitconstraint begin\n    :dynamic₊Pset - @pf(:static₊P)\n    :dynamic₊Qset - @pf(:static₊Q)\nend\n\nNote that this particiular example could have been a PFInitFormula, since we can solve it directly.\n\nSee also: PFInitConstraint, set_pfinitconstraint!, add_pfinitconstraint!\n\n\n\n\n\n","category":"macro"},{"location":"API/#PowerDynamics.PFInitFormula","page":"API","title":"PowerDynamics.PFInitFormula","text":"struct PFInitFormula{F}\nPFInitFormula(f, outsym, sym, pfsym)\n\nA representation of an initialization formula that is applied during the initialization phase of a component. In contrast to a InitFormula, this formula may access additional variables which are available in the full NWState of the solved power flow!\n\nCrucially, this is only necessary for formulas, which cannot be expressed in terms of the interface variables (voltages and currents).\n\nSimilar to InitFormula, this sets defaults rather than adding constraint equations. The formula is applied early in the initialization pipeline before constraints are solved.\n\nSee also: @pfinitformula for a macro to create such formulas, PFInitFormula, set_pfinitformula!, add_pfinitformula!\n\n\n\n\n\n","category":"type"},{"location":"API/#PowerDynamics.@pfinitformula","page":"API","title":"PowerDynamics.@pfinitformula","text":"@pfinitformula expr\n@pfinitformula begin\n    :var1 = expr1\n    :var2 = expr2\nend\n\nCreate a PFInitFormula using macro syntax. Component variables are accessed with :symbol and power flow state variables with @pf(:symbol). Multiple formulas can be defined in a begin...end block.\n\nUnlike constraints, formulas use assignment syntax (:var = expression) to set variable values during initialization. The left-hand side specifies output variables, and the right-hand side can access both component variables and power flow state variables.\n\nFor example, the following code creates formulas for Pset/Qset of the dynamic model in reference to the variables P and Q of the powerflow model.\n\n@pfinitformula :dynamic₊Pset = @pf(:static₊P)\n@pfinitformula begin\n    :dynamic₊Pset = @pf(:static₊P)\n    :dynamic₊Qset = @pf(:static₊Q)\nend\n\nSee also: PFInitFormula, set_pfinitformula!, add_pfinitformula!\n\n\n\n\n\n","category":"macro"},{"location":"API/#Constraint-Management-Functions","page":"API","title":"Constraint Management Functions","text":"","category":"section"},{"location":"API/#PowerDynamics.add_pfinitconstraint!","page":"API","title":"PowerDynamics.add_pfinitconstraint!","text":"add_pfinitconstraint!(c::NetworkDynamics.ComponentModel, constraint::PFInitConstraint) -> Bool\nadd_pfinitconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint) -> Bool\n\nAdds a new initialization constraint which depends on the powerflow solution to the component. If constraints already exist, the new constraint is added to the existing ones. If no constraints exist, this is equivalent to set_pfinitconstraint!.\n\nReturns true if the constraint was successfully added, false if it already exists.\n\nSee also set_pfinitconstraint!, delete_pfinitconstraints!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.add_pfinitformula!","page":"API","title":"PowerDynamics.add_pfinitformula!","text":"add_pfinitformula!(c::NetworkDynamics.ComponentModel, formula::PFInitFormula) -> Bool\nadd_pfinitformula!(nw::Network, idx::Union{VIndex,EIndex}, formula) -> Bool\n\nAdds a new initialization formula which depends on the powerflow solution to the component. If formulas already exist, the new formula is added to the existing ones. If no formulas exist, this is equivalent to set_pfinitformula!.\n\nReturns true if the formula was successfully added, false if it already exists.\n\nSee also set_pfinitformula!, delete_pfinitformulas!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.set_pfinitconstraint!","page":"API","title":"PowerDynamics.set_pfinitconstraint!","text":"set_pfinitconstraint!(c::NetworkDynamics.ComponentModel, constraint; check=true)\nset_pfinitconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint; check=true)\n\nSets initialization constraints which depend on the powerflow solution to the component. Accepts either a single PFInitConstraint or a tuple of PFInitConstraint objects. Overwrites any existing pf constraints. See also delete_pfinitconstraints!, add_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.set_pfinitformula!","page":"API","title":"PowerDynamics.set_pfinitformula!","text":"set_pfinitformula!(c::NetworkDynamics.ComponentModel, formula; check=true)\nset_pfinitformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)\n\nSets initialization formulas which depend on the powerflow solution to the component. Accepts either a single PFInitFormula or a tuple of PFInitFormula objects. Overwrites any existing pf formulas. See also delete_pfinitformulas!, add_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.has_pfinitconstraint","page":"API","title":"PowerDynamics.has_pfinitconstraint","text":"has_pfinitconstraint(c::ComponentModel)\nhas_pfinitconstraint(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has an initialization constraint which depends on the pf state in metadata.\n\nSee also: get_pfinitconstraints, set_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.has_pfinitformula","page":"API","title":"PowerDynamics.has_pfinitformula","text":"has_pfinitformula(c::ComponentModel)\nhas_pfinitformula(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has an initialization formula which depends on the pf state in metadata.\n\nSee also: get_pfinitformulas, set_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.get_pfinitconstraints","page":"API","title":"PowerDynamics.get_pfinitconstraints","text":"get_pfinitconstraints(c::NetworkDynamics.ComponentModel)\nget_pfinitconstraints(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the initialization constraints which depend on pf state for the component model. Returns a tuple of constraints, even if only one constraint is present. May error if no constraints are present. Use has_pfinitconstraint to check first.\n\nSee also: has_pfinitconstraint, set_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.get_pfinitformulas","page":"API","title":"PowerDynamics.get_pfinitformulas","text":"get_pfinitformulas(c::NetworkDynamics.ComponentModel)\nget_pfinitformulas(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the initialization formulas which depend on pf state for the component model. Returns a tuple of formulas, even if only one formula is present. May error if no formulas are present. Use has_pfinitformula to check first.\n\nSee also: has_pfinitformula, set_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.delete_pfinitconstraints!","page":"API","title":"PowerDynamics.delete_pfinitconstraints!","text":"delete_pfinitconstraints!(c::NetworkDynamics.ComponentModel)\ndelete_pfinitconstraints!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the powerflow dependent initialization constraint from the component model, or from a component referenced by idx in a network. Returns true if the constraint existed and was removed, false otherwise.\n\nSee also: set_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.delete_pfinitformulas!","page":"API","title":"PowerDynamics.delete_pfinitformulas!","text":"delete_pfinitformulas!(c::NetworkDynamics.ComponentModel)\ndelete_pfinitformulas!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the powerflow dependent initialization formula from the component model, or from a component referenced by idx in a network. Returns true if the formula existed and was removed, false otherwise.\n\nSee also: set_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#PowerDynamics.copy_pf_parameters","page":"API","title":"PowerDynamics.copy_pf_parameters","text":"copy_pf_parameters(cm::ComponentModel) -> PFInitFormula\n\nCreates a PFInitFormula that copies all parameters from the powerflow model to the component model. This formula can then be added to the component using add_pfinitformula!.\n\nThis is useful for components where the powerflow and dynamic models should have identical parameter values, ensuring consistency between the two models.\n\nSee also: PFInitFormula, add_pfinitformula!\n\n\n\n\n\n","category":"function"},{"location":"API/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"API/#PowerDynamics.refine_timeseries","page":"API","title":"PowerDynamics.refine_timeseries","text":"refine_timeseries(ts, factor=10)\n\nRefine a time series by interpolating additional time points between existing ones. Usefull for creating denser plots based on refine_timeseries(sol.t).\n\nArguments\n\nts: Input time series vector\nfactor: Number of subdivisions between each pair of consecutive time points (default: 10)\n\n\n\n\n\n","category":"function"},{"location":"generated/custom_bus/#custom-bus","page":"Custom Generator Bus","title":"Define a Custom Bus Model","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"This tutorial can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"In this Tutorial, we will define a custom bus model that can be used in PowerDynamics.jl.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The model we set out to recreate is the classical machine from Chapter 15.1 from Milano's book","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"F. Milano, Power System Modelling and Scripting,  Berlin, Heidelberg: Springer Berlin Heidelberg, 2010. doi: 10.1007/978-3-642-13669-6.","category":"page"},{"location":"generated/custom_bus/#Defining-the-Machine-as-Injector","page":"Custom Generator Bus","title":"Defining the Machine as Injector","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"In order to use this model in a Bus, we need to define it in a way that it specifies the Injector Interface.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"            ┌───────────────────┐\nterminal    │                   │\n   o←───────┤ Machine Equations │\nu_r, u_i    │                   │\ni_r, i_i    └───────────────────┘\n","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The received values for u_r, u_i, i_r, and i_i at the terminal are in the global synchronous dq frame. The internal state δ describes the rotor angle of the machine in this frame. In order to obtain the local dq-frame voltages and currents, we need to apply a Park transformation.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"<picture>\n<source srcset=\"../../assets/dqgrafic-dark.svg\" media=\"(prefers-color-scheme: dark)\">\n<img src=\"../../assets/dqgrafic.svg\" width=\"70%\" height=\"70%\"/>\n</picture>","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"In addition to the transformation, the model is defined by the following equations:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"beginaligned\nfracddeltadt = omega_b(omega - 1) text(Milano 155) \n2H fracdomegadt = fracP_momega - tau_e text(Power form of Milano 155) \npsi_d = V_q + R_s I_q text(Milano 1511) \npsi_q = -V_d - R_s I_d text(Milano 1511) \ntau_e = psi_d I_q - psi_q I_d text(Milano 156) \n0 = V_q + R_s I_q + X_d I_d - v_ftextset text(Milano 1536) \n0 = V_d + R_s I_d - X_d I_q text(Milano 1536)\nendaligned","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We can use the ModelingToolkit DSL to define the full injector model:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"using PowerDynamics, NetworkDynamics, ModelingToolkit\nusing PowerDynamics.Library\nusing ModelingToolkit: t_nounits as t, D_nounits as Dt\nusing ModelingToolkitStandardLibrary.Blocks\nusing OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\n\n@mtkmodel MilanoClassicalMachine begin\n    @components begin\n        terminal=Terminal()\n    end\n    @parameters begin\n        R_s=0.000124, [description=\"stator resistance\"]\n        X′_d=0.0608, [description=\"d-axis transient reactance\"]\n        H=23.64, [description=\"inertia constant\"]\n        ω_b=2π*50, [description=\"System base frequency in rad/s\"]\n        vf_set, [guess=1, description=\"field voltage\"]\n        P_m, [guess=1, description=\"mechanical power\"]\n    end\n    @variables begin\n        δ(t), [guess=0, description=\"rotor angle\"]\n        ω(t), [guess=1, description=\"rotor speed\"]\n        τ_e(t), [description=\"electrical torque\"]\n        I_d(t), [description=\"d-axis current\"]\n        I_q(t), [description=\"q-axis current\"]\n        V_d(t), [description=\"d-axis voltage\"]\n        V_q(t), [description=\"q-axis voltage\"]\n        ψ_d(t), [description=\"d-axis flux linkage\"]\n        ψ_q(t), [description=\"q-axis flux linkage\"]\n    end\n    begin\n        T_to_loc(α)  = [ sin(α) -cos(α);\n                         cos(α)  sin(α)]\n        T_to_glob(α) = [ sin(α)  cos(α);\n                        -cos(α)  sin(α)]\n    end\n    @equations begin\n        # Park's transformations\n        [terminal.u_r, terminal.u_i] .~ T_to_glob(δ)*[V_d, V_q]\n        [I_d, I_q] .~ T_to_loc(δ)*[terminal.i_r, terminal.i_i]\n\n        # mechanical swing equation Milano 15.5\n        Dt(δ) ~ ω_b*(ω - 1)\n        2*H * Dt(ω) ~ P_m/ω - τ_e\n\n        # static flux linkage equations Milano 15.11\n        ψ_d ~  V_q + R_s*I_q\n        ψ_q ~ -V_d - R_s*I_d\n\n        # electrical torque Milano 15.6\n        τ_e ~ ψ_d*I_q - ψ_q*I_d\n\n        # magnetic equations from static model Milano 15.36\n        0 ~ V_q + R_s*I_q + X′_d*I_d - vf_set\n        0 ~ V_d + R_s*I_d - X′_d*I_q\n    end\nend\n\n\n@named machine = MilanoClassicalMachine();\nnothing #hide","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We can verify that the model satisfies the Injector Interface by checking","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"isinjectormodel(machine)","category":"page"},{"location":"generated/custom_bus/#Attaching-the-Machine-to-a-Busbar","page":"Custom Generator Bus","title":"Attaching the Machine to a Busbar","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"In order to use the machine model, we need to attach it to a busbar, thus forming a system which satisfies the MTKBus Interface. There are two ways of doing so: manually and using the MTKBus constructor.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Manual Construction","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We need to define a new MTK model, which has 2 components: a busbar and the machine. Both components have a terminal as a subcomponent, we can use the connect function to hook the machine on the busbar.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"@mtkmodel MyMTKBus begin\n    @components begin\n        busbar = BusBar()\n        machine = MilanoClassicalMachine()\n    end\n    @equations begin\n        connect(busbar.terminal, machine.terminal)\n    end\nend\nmtkbus = MyMTKBus(name=:bus)\nisbusmodel(mtkbus) # assert that the created model satisfies the interface","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Automatic Construction","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We can also use the MTKBus constructor to create a busbar with a machine attached. This constructor takes a list of injector models and hooks them all to the same busbar.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"mtkbus = MTKBus(machine; name=:bus)\nisbusmodel(mtkbus) # assert that the created model satisfies the interface","category":"page"},{"location":"generated/custom_bus/#Compiling-bus-to-VertexModel","page":"Custom Generator Bus","title":"Compiling bus to VertexModel","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"To actually simulate the system, we need to compile the model, i.e. transforming it from a purely symbolic representation to a numerical one.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"compile_bus(mtkbus)","category":"page"},{"location":"generated/custom_bus/#Defining-a-Simulation-Scenario","page":"Custom Generator Bus","title":"Defining a Simulation Scenario","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"To simulate the model, we need to define some kind of scenario. We'll create a simple two-bus system where our custom Milano machine is connected to a slack bus through a transmission line. This will allow us to observe the machine's dynamic behavior in response to a frequency disturbance.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"First, we create a slack bus that provides the voltage and frequency reference for the system.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"slackbus = compile_bus(\n    PowerDynamics.VariableFrequencySlack(name=:variable_slack),\n    vidx=1,\n    pf=pfSlack(V=1)\n)","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We define a frequency event that increases the system frequency at t=1 second (see ND docs on Callbacks for details). This disturbance will cause our machine to respond dynamically as it tries to maintain synchronism with the network.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"freq_event = PresetTimeComponentCallback(\n    1, # trigger at time 1\n    ComponentAffect([],[:V,:ω]) do u, p, ctx\n        p[:ω] = 1.01 # set frequency to 1.01 pu\n    end\n)\nset_callback!(slackbus, freq_event)\nnothing #hide","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Next, we create the generator bus using our custom Milano machine model. We specify it as a PV bus for the power flow with 1 pu voltage and 1 pu active power.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"genbus = compile_bus(\n    mtkbus,\n    vidx=2,\n    pf=pfPV(V=1, P=1)\n)","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We connect the two buses with a simple PI transmission line model.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"line = compile_line(MTKLine(PiLine(; name=:piline)); src=1,dst=2)","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Now we can build the complete network with our two buses and the connecting line.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"nw = Network([slackbus, genbus], line)","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Before running dynamic simulation, we initialize the system from power flow. This ensures that all dynamic states start from a steady-state condition.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"To do so, we use the function initialize_from_pf!, which does several steps:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Calculate the powerflow according to the powerflow models.\nInitialize the \"free\" states and parameters of the dynamical components, such that the system is in a steady state.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"More information on initialization can be found in the docs on Powergrid Initialization.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"initialize_from_pf!(nw)\nnothing #hide","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Let's examine the initial state of our generator bus to verify proper initialization.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"dump_initial_state(nw[VIndex(2)])","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The printout shows us several important aspects: The free internal states delta, omega and the free internal parameters P_mathrm m and vf_mathrmset have been initialized. We see, that both power and excitation voltage are slightly above the given (1,1) for the powerflow, which is expected since there are some losses in the model. However the initialized state matches the powerflow solution at the network interface, i.e. busbar₊P and busbar₊u_mag are both 1 pu.","category":"page"},{"location":"generated/custom_bus/#Dynamic-Simulation","page":"Custom Generator Bus","title":"Dynamic Simulation","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"With the system properly initialized, we can set up and solve the dynamic simulation. We simulate for 100 seconds to capture the machine's response to the frequency disturbance.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"s0 = NWState(nw)\nprob = ODEProblem(nw, uflat(s0), (0,100), pflat(s0), callback=get_callbacks(nw))\nsol = solve(prob, Rodas5P())\nnothing #hide","category":"page"},{"location":"generated/custom_bus/#Visualizing-the-Results","page":"Custom Generator Bus","title":"Visualizing the Results","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Now let's create comprehensive plots to visualize how our custom Milano machine responds to the frequency disturbance. We'll plot several key variables that demonstrate the machine's electromechanical dynamics.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"let\n    fig = Figure(size=(800, 600));\n\n    ax1 = Axis(fig[1, 1];\n        title=\"Rotor Angle\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Rotor Angle δ [rad]\")\n    lines!(ax1, sol; idxs=VIndex(2, :machine₊δ), linewidth=2)\n    axislegend(ax1)\n\n    ax2 = Axis(fig[2, 1];\n        title=\"Rotor Speed\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Rotor Speed ω [pu]\")\n    lines!(ax2, sol; idxs=VIndex(2, :machine₊ω), linewidth=2)\n    axislegend(ax2)\n\n    ax3 = Axis(fig[3, 1];\n        title=\"Machine Voltages\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Voltage [pu]\")\n    lines!(ax3, sol; idxs=VIndex(2, :machine₊V_d), color=Cycled(1), linewidth=2)\n    lines!(ax3, sol; idxs=VIndex(2, :machine₊V_q), color=Cycled(2), linewidth=2)\n    axislegend(ax3)\n    fig\nend","category":"page"},{"location":"generated/custom_bus/#Observing-the-Poor-Damping-Problem","page":"Custom Generator Bus","title":"Observing the Poor Damping Problem","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"From the plots above, we can see that the Milano classical machine exhibits very lightly damped oscillations that persist for a very long time. The rotor angle and speed oscillate for hundreds of seconds without settling to a steady state.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"This poor damping behavior occurs because:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"No damper windings: The model lacks electromagnetic damping mechanisms\nConstant field voltage: No dynamic response to help stabilize the machine\nNo mechanical damping: The swing equation has no friction losses","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The only source of damping here is, that we have specified a constant mechanical power rather than a constant mechanical torque.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"To solve this problem, real power systems use control systems, particularly Power System Stabilizers (PSS) that are specifically designed to damp electromechanical oscillations.","category":"page"},{"location":"generated/custom_bus/#Adding-a-Power-System-Stabilizer-(PSS)","page":"Custom Generator Bus","title":"Adding a Power System Stabilizer (PSS)","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Let's create an improved machine model with controllable field voltage and add the simplest possible PSS to demonstrate the damping improvement.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The implemented PSS is a simple device, which adjusts the excitation voltage based on frequency deviation. It consists of a washout filter to remove steady-state errors and only react to frequency changes, and a gain to amplify the response.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"To achieve this goal we will:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Modify the Milano machine model to include a controllable field voltage input and a rotor frequency measurement output.\nCreate a simple PSS model that takes the frequency input and outputs a stabilizing signal to the field voltage.\nCombine the machine and PSS into a new composite model that forms an injector.\nRepeat the simulation above with our new controlled-generator model and compare the results.","category":"page"},{"location":"generated/custom_bus/#Controllable-Machine-Model","page":"Custom Generator Bus","title":"Controllable Machine Model","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"First, we create a modified Milano machine with control inputs/outputs: vf_in for field voltage and ω_out for frequency output.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"@mtkmodel MilanoControllableMachine begin\n    @components begin\n        terminal=Terminal()\n        # Control interface\n        vf_in = RealInput(guess=1)  # field voltage input\n        ω_out = RealOutput()        # frequency output for PSS\n    end\n    @parameters begin\n        R_s=0.000124, [description=\"stator resistance\"]\n        X′_d=0.0608, [description=\"d-axis transient reactance\"]\n        H=23.64, [description=\"inertia constant\"]\n        ω_b=2π*50, [description=\"System base frequency in rad/s\"]\n        P_m, [guess=1, description=\"mechanical power\"]\n    end\n    @variables begin\n        δ(t), [guess=0, description=\"rotor angle\"]\n        ω(t), [guess=1, description=\"rotor speed\"]\n        τ_e(t), [description=\"electrical torque\"]\n        I_d(t), [description=\"d-axis current\"]\n        I_q(t), [description=\"q-axis current\"]\n        V_d(t), [description=\"d-axis voltage\"]\n        V_q(t), [description=\"q-axis voltage\"]\n        ψ_d(t), [description=\"d-axis flux linkage\"]\n        ψ_q(t), [description=\"q-axis flux linkage\"]\n    end\n    begin\n        T_to_loc(α)  = [ sin(α) -cos(α);\n                         cos(α)  sin(α)]\n        T_to_glob(α) = [ sin(α)  cos(α);\n                        -cos(α)  sin(α)]\n    end\n    @equations begin\n        # Park's transformations\n        [terminal.u_r, terminal.u_i] .~ T_to_glob(δ)*[V_d, V_q]\n        [I_d, I_q] .~ T_to_loc(δ)*[terminal.i_r, terminal.i_i]\n\n        # mechanical swing equation Milano 15.5\n        Dt(δ) ~ ω_b*(ω - 1)\n        2*H * Dt(ω) ~ P_m/ω - τ_e\n\n        # static flux linkage equations Milano 15.11\n        ψ_d ~  V_q + R_s*I_q\n        ψ_q ~ -V_d - R_s*I_d\n\n        # electrical torque Milano 15.6\n        τ_e ~ ψ_d*I_q - ψ_q*I_d\n\n        # magnetic equations from static model Milano 15.36\n        0 ~ V_q + R_s*I_q + X′_d*I_d - vf_in.u  # Use controllable input\n        0 ~ V_d + R_s*I_d - X′_d*I_q\n\n        # Control interface - output frequency for PSS\n        ω_out.u ~ ω\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_bus/#Simple-Power-System-Stabilizer","page":"Custom Generator Bus","title":"Simple Power System Stabilizer","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The simplest PSS consists of a washout filter with gain. The washout filter ensures the PSS only responds to frequency changes, not steady-state errors.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"@mtkmodel SimplePSS begin\n    @components begin\n        ω_in = RealInput() # frequency input from machine\n        vst = RealOutput() # stabilizer output signal\n    end\n    @parameters begin\n        Tw=10, [description=\"washout time constant\"]\n        Ks=20, [description=\"stabilizer gain\"]\n    end\n    @variables begin\n        y(t), [guess=0, description=\"washout filter output\"]\n    end\n    @equations begin\n        # Washout filter: dy/dt = (ω - y)/Tw\n        Dt(y) ~ (ω_in.u - y) / Tw\n        # output gain\n        vst.u ~ Ks * (ω_in.u - y)\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/custom_bus/#Complete-Generator-with-PSS","page":"Custom Generator Bus","title":"Complete Generator with PSS","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"The PSS only adds an offset to the field voltage based on the frequency input. Therefore, our combined injector model needs to look something like this:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"    ┌───────────────────────────┐\n    │GeneratorWithPss           │\n    │         ╭─────→─────╮     │\n(t) │ ┌───────┴─┐ ω_out ┌─┴───┐ │\n o──┼─┤ Machine │       │ PSS │ │\n    │ └───────┬─┘       └─┬───┘ │\n    │   vf_in ╰──←─(+)──←─╯ vst │\n    │               ↑           │\n    │            vf_base        │\n    └───────────────────────────┘","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Notably, similar to how we left vf_set free for initialization in the previous example, now we need to leave vf_base free.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"We define a new mtkmodel which combines machine with controller and forms a new injector:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"@mtkmodel GeneratorWithPSS begin\n    @components begin\n        terminal = Terminal()\n        machine = MilanoControllableMachine()\n        pss = SimplePSS()\n    end\n    @parameters begin\n        vf_base, [guess=1.0, description=\"base field voltage\"]\n    end\n    @equations begin\n        # Connect terminals\n        connect(terminal, machine.terminal)\n        # Connect control loop: machine frequency → PSS → back to machine field voltage\n        connect(machine.ω_out, pss.ω_in)\n        # Sum base field voltage with PSS output\n        machine.vf_in.u ~ vf_base + pss.vst.u\n    end\nend\n\n@named gen_with_pss = GeneratorWithPSS()\nisinjectormodel(gen_with_pss) # Verify it's still an injector","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Since this is an injector, we can use MTKBus(gen_with_pss) to build the symbolic bus model. However, this leads to another level of namespacing, as the overall bus will have variable names like gen_with_pss₊machine₊δ due to the encapsulation.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Alternatively, we could define a model which directly implements the MTKBus interface:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"┌─────────────────────────────────────┐\n│MyMTKBus                             │\n│                   ╭─────→─────╮     │\n│┌──────┐   ┌───────┴─┐ ω_out ┌─┴───┐ │\n││BusBar├─o─┤ Machine │       │ PSS │ │\n│└──────┘   └───────┬─┘       └─┬───┘ │\n│             vf_in ╰──←─(+)──←─╯ vst │\n│                         ↑           │\n│                      vf_base        │\n└─────────────────────────────────────┘","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"@mtkmodel CustomMTKBus begin\n    @components begin\n        busbar = BusBar()\n        machine = MilanoControllableMachine()\n        pss = SimplePSS()\n    end\n    @parameters begin\n        vf_base, [guess=1.0, description=\"base field voltage\"]\n    end\n    @equations begin\n        connect(busbar.terminal, machine.terminal)\n        connect(machine.ω_out, pss.ω_in)\n        machine.vf_in.u ~ vf_base + pss.vst.u\n    end\nend\n@named genbus_custom = CustomMTKBus()\n@assert isbusmodel(genbus_custom)","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"In practice, it doesn't really matter which approach you choose, as both will work. However this highlights the flexibility of the MTK modeling framework before you go to the compiled-model domain by calling compile_bus on the model fulfilling the MTKBus interface.","category":"page"},{"location":"generated/custom_bus/#Simulation-with-PSS","page":"Custom Generator Bus","title":"Simulation with PSS","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Now let's run the same simulation scenario with the PSS-equipped generator to observe the damping improvement.","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Create the improved generator bus with simple PSS","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"genbus_pss = compile_bus(\n    MTKBus(gen_with_pss; name=:bus_pss),\n    vidx=2,\n    pf=pfPV(V=1, P=1)\n)","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Create network with PSS-equipped generator","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"nw_pss = Network([slackbus, genbus_pss], line)\ninitialize_from_pf!(nw_pss)\nnothing #hide","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Run simulation with simple PSS","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"s0_pss = NWState(nw_pss)\nprob_pss = ODEProblem(nw_pss, uflat(s0_pss), (0,100), pflat(s0_pss), callback=get_callbacks(nw_pss))\nsol_pss = solve(prob_pss, Rodas5P())\nnothing #hide","category":"page"},{"location":"generated/custom_bus/#Comparing-Results:-With-and-Without-PSS","page":"Custom Generator Bus","title":"Comparing Results: With and Without PSS","text":"","category":"section"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"Let's create comparison plots to clearly see the damping improvement:","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"let\n    fig = Figure(size=(800, 600));\n\n    # Compare rotor speeds\n    ax1 = Axis(fig[1, 1];\n        title=\"Rotor Speed Comparison: Effect of PSS on Damping\",\n        xlabel=\"Time [s]\",\n        ylabel=\"Rotor Speed ω [pu]\")\n    lines!(ax1, sol; idxs=VIndex(2, :machine₊ω), label=\"No PSS\", color=Cycled(2))\n    lines!(ax1, sol_pss; idxs=VIndex(2, :gen_with_pss₊machine₊ω), label=\"Simple PSS\", color=Cycled(1), linewidth=2)\n    axislegend(ax1, position=:rt)\n    xlims!(ax1, 0, 30)  # Focus on first 30 seconds\n\n    # PSS Output - shows the actual stabilizer signal\n    ax2 = Axis(fig[2, 1];\n        title=\"PSS Output Signal\",\n        xlabel=\"Time [s]\",\n        ylabel=\"PSS Output [pu]\")\n    lines!(ax2, sol_pss; idxs=VIndex(2, :gen_with_pss₊pss₊vst₊u), label=\"PSS Output\", linewidth=2)\n    axislegend(ax2, position=:rt)\n    xlims!(ax2, 0, 30)\n\n    fig\nend","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"","category":"page"},{"location":"generated/custom_bus/","page":"Custom Generator Bus","title":"Custom Generator Bus","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#PowerDynamics","page":"Home","title":"PowerDynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PowerDynamics.jl is a Julia package for modeling and simulating power grid dynamics. It provides a comprehensive framework for analyzing electrical power systems, including synchronous machines, loads, lines, and various control elements. The package is built on top of NetworkDynamics.jl and offers both predefined component models and the flexibility to create custom power system components.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: PowerDynamics.Library Under Active Development\nThe PowerDynamics.Library component library is currently excluded from semantic versioning and is under heavy development.While PowerDynamics itself follows semantic versioning, the Library submodule's API is highly unstable and variable names, function signatures, and model interfaces may change frequently without notice. If you are using specific models from PowerDynamics.Library in their current state, we strongly recommend copying them to your own source code to avoid breaking changes in future updates.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation is roughly split into 3 parts: we have the reference and concepts documentation, which contains technical descriptions of different aspects of PowerDynamics.jl. We have the Tutorials, which are pedagogical examples which aim to show a specific aspect of working with the package and we have the advanced examples, which are less focused than the tutorials but also consist of copy-pastable examples showing different aspects of modeling and simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you're new to Julia, start with the Julia Setup guide to set up your development environment.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a first step, it is advised to read through the Getting Started tutorial to understand the core philosophy and SciML integration. Then, work through the Typical Simulation Workflow tutorial for a hands-on walkthrough of building and simulating a power system. Afterwards, it's a good idea to read on the Modeling Concepts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is also highly recommended to check out the docs on NetworkDynamics.jl as those explain lots of the underlying functionality and concepts","category":"page"},{"location":"#Reference-and-Concepts","page":"Home","title":"Reference & Concepts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modeling Concepts - Learn the fundamental concepts behind PowerDynamics modeling\nComponent Library - Explore the available power system component models\nPowergrid Initialization - Understand how to properly initialize power system simulations\nAPI Reference - Complete function and type documentation","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Getting Started - Introduction to the core philosophy behind PowerDynamics.jl and its integration with the SciML ecosystem\nTypical Simulation Workflow - Hands-on walkthrough of a small 3-bus example system, covering all stages from modeling to simulation\nCustom Components - Shows how to implement Milano's classical synchronous machine model with a power system stabilizer (PSS)\nCustom Transmission Lines - Demonstrates creating a PI-branch transmission line model with overcurrent protection that can trip during faults","category":"page"},{"location":"#Advanced-Examples","page":"Home","title":"Advanced Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IEEE 9-Bus System - Simulates the complete 9-bus IEEE test system with synchronous generators and dynamic load changes\nIEEE 39-Bus System Part 1 - Shows how to build the 39-bus New England test system from custom CSV data files with proper component modeling\nIEEE 39-Bus System Part 2 - Demonstrates the detailed initialization process for the 39-bus system including power flow and initialization of dynamic models\nIEEE 39-Bus System Part 3 - Runs dynamic simulation of the 39-bus system with a short circuit disturbance and fault clearing\nIEEE 39-Bus System Part 4 - Implements a custom droop-controlled inverter model and performs parameter optimization using sensitivity analysis\nEMT Toy Model Example - Demonstrates very basic EMT modeling using dynamic shunt capacitor and RL transmission line components in rotating dq coordinates","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>Direct dependencies used for this documentation:</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg #hide\nPkg.status() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>Julia Version:</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils #hide\nversioninfo() #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>Full Manifest:</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg #hide\nPkg.status(; mode = PKGMODE_MANIFEST) #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Development of this project was in part funded by the German Federal Ministry for Economic Affairs and Climate Action as part of the OpPoDyn-Project (Project ID 01258425/1, 2024-2027).","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/bmwk_logo_en.svg\" width=\"300\"/>","category":"page"}]
}
